import{S as e,i as t,s as a,M as r,e as s,a as o,c as n,b as i,m as c,n as d,t as u,d as l,f,g as m,h as p,o as y,r as g,k as h,p as w,q as b,j as _,u as A,v as T,x as D,y as I,C as x,D as M,w as k,H as E,G as U,B as v,as as C,z as j,A as L,E as R,I as P}from"./engine.js";import{c as S}from"./skybox.js";import{c as G,a as N}from"./polyhedron.js";import{c as O,a as H}from"./debug.js";import{l as B}from"./rgbe-loader.js";import{c as $,g as F,h as q,a as z,b as W}from"./environment-map-texture.js";import{c as Y}from"./specular.js";import{l as J,m as K,i as Q,c as V}from"./gltf-loader.js";let X={taskID:0,pending:!1,decode:async function(e,t,a,r){const s={attributeIDs:a,attributeTypes:r,useUniqueIDs:!0,vertexColorSpace:"SRGB"};return await new Promise(((a,r)=>{const{worker:o}=e;let{taskID:n}=e;o._callbacks[n]={resolve:a,reject:r},o.postMessage({type:"decode",id:n,taskConfig:s,buffer:t},[t]),n++}))}};async function Z(e){if(X.pending)return X.promise;let t={};const a=new Promise(((e,a)=>{t.resolve=e,t.reject=a}));X.promise=a,X.pending=!0;const r=fetch(e+"draco_wasm_wrapper.js"),s=fetch(e+"draco_decoder.wasm");await Promise.all([r,s]);const o=await(await r).text(),n=await(await s).arrayBuffer(),i=function(e){const t=ee.toString(),a=["/* draco decoder */",e,"","/* worker */",t.substring(t.indexOf("{")+1,t.lastIndexOf("}"))].join("\n");return URL.createObjectURL(new Blob([a]))}(o),c=new Worker(i);return c._callbacks={},c.postMessage({type:"init",decoderConfig:{wasmBinary:n}}),c.onmessage=function(e){const t=e.data;switch(t.type){case"decode":c._callbacks[t.id].resolve(t);break;case"error":c._callbacks[t.id].reject(t);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+t.type+'"')}},X.worker=c,X.taskID=0,t.resolve(),X}function ee(){let e,t;function a(e,t,a,r,s,o){const n=o.num_components(),i=a.num_points()*n,c=i*s.BYTES_PER_ELEMENT,d=function(e,t){switch(t){case Float32Array:return e.DT_FLOAT32;case Int8Array:return e.DT_INT8;case Int16Array:return e.DT_INT16;case Int32Array:return e.DT_INT32;case Uint8Array:return e.DT_UINT8;case Uint16Array:return e.DT_UINT16;case Uint32Array:return e.DT_UINT32}}(e,s),u=e._malloc(c);t.GetAttributeDataArrayForAllPoints(a,o,d,c,u);const l=new s(e.HEAPF32.buffer,u,i).slice();return e._free(u),{name:r,array:l,itemSize:n}}onmessage=function(r){const s=r.data;switch(s.type){case"init":e=s.decoderConfig,t=new Promise((function(t){e.onModuleLoaded=function(e){t({draco:e})},DracoDecoderModule(e)}));break;case"decode":const r=s.buffer,o=s.taskConfig;t.then((e=>{const t=e.draco,n=new t.Decoder;try{const e=function(e,t,r,s){const o=s.attributeIDs,n=s.attributeTypes;let i,c;const d=t.GetEncodedGeometryType(r);if(d===e.TRIANGULAR_MESH)i=new e.Mesh,c=t.DecodeArrayToMesh(r,r.byteLength,i);else{if(d!==e.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");i=new e.PointCloud,c=t.DecodeArrayToPointCloud(r,r.byteLength,i)}if(!c.ok()||0===i.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+c.error_msg());const u={index:null,attributes:[]};for(const r in o){const c=self[n[r]];let d,l;if(s.useUniqueIDs)l=o[r],d=t.GetAttributeByUniqueId(i,l);else{if(l=t.GetAttributeId(i,e[o[r]]),-1===l)continue;d=t.GetAttribute(i,l)}const f=a(e,t,i,r,c,d);"color"===r&&(f.vertexColorSpace=s.vertexColorSpace),u.attributes.push(f)}d===e.TRIANGULAR_MESH&&(u.index=function(e,t,a){const r=a.num_faces(),s=3*r,o=4*s,n=e._malloc(o);t.GetTrianglesUInt32Array(a,o,n);const i=new Uint32Array(e.HEAPF32.buffer,n,s).slice();return e._free(n),{array:i,itemSize:1}}(e,t,i));return e.destroy(i),u}(t,n,new Int8Array(r),o),i=e.attributes.map((e=>e.array.buffer));e.index&&i.push(e.index.array.buffer),self.postMessage({type:"decode",id:s.id,geometry:e},i)}catch(e){console.error(e),self.postMessage({type:"error",id:s.id,error:e.message})}finally{t.destroy(n)}}))}}}function te(e){let t,a,p,y;return p=new r({}),{c(){t=s("canvas"),a=o(),n(p.$$.fragment)},m(r,s){i(r,t,s),e[1](t),i(r,a,s),c(p,r,s),y=!0},p:d,i(e){y||(u(p.$$.fragment,e),y=!0)},o(e){l(p.$$.fragment,e),y=!1},d(r){r&&(f(t),f(a)),e[1](null),m(p,r)}}}function ae(e,t,a){let r,s,o,n,i,c,d,u;function l(){u.delta(0,0,.002)}return p(e,g,(e=>a(4,r=e))),p(e,h,(e=>a(5,s=e))),p(e,w,(e=>a(6,o=e))),p(e,b,(e=>a(7,n=e))),p(e,_,(e=>a(8,i=e))),y((async()=>{A(g,r={...r,canvas:c,backgroundColor:T,ambientLightColor:[16777215,.1],toneMappings:[$({exposure:1})]},r),A(_,i={...i,position:[4,.8,2],target:[2,0,-1],fov:75},i),d=await B("christmas_photo_studio_01_4k.hdr");const e=F(1),t=await S({typedArray:d.data,convertToCube:q,width:d.width,height:d.height,cubeSize:2048,toneMapping:e}),a=z(d);A(b,n=[t,a],n);const f=G(2,5,N),m=D(I()),p=k({diffuse:[1,0,0],metalness:0,program:H()});O({...f,matrix:m,material:p}),x(M({position:[-2,2,2],color:[1,1,1],intensity:5,cutoffDistance:0,decayExponent:2}));const y=W({envMap:a.getTexture,width:a.width,height:a.height,lodMax:a.lodMax});k({diffuse:[1,1,1],metalness:1,specular:Y({roughness:.05,ior:1.5,intensity:1,color:[1,1,1]}),envMap:y});const P=await Z("draco/"),X=await J("models/gamefont-a-draco.gltf","models/gamefont-a-draco.bin",P),ee=K(X.scene).find(Q),te=V(X,ee),ae=k({metalness:.95,specular:Y({roughness:.08,ior:1.4,intensity:.8,color:[1,1,1]}),diffuse:[1,215/255,0],envMap:y}),re=k({metalness:0,specular:Y({roughness:.08,ior:1.4,intensity:.8,color:[1,1,1]}),diffuse:[1,215/255,0],envMap:y}),se=D(I());E(se,se,[8,8,8]),U(se,se,Math.PI/4),v(se,se,Math.PI/2);const oe=C(I(),se);j(oe,oe,[.5,0,0]),A(w,o=[...o,re,ae],o),A(h,s=[...s,L({...te,matrix:se,material:re}),L({...te,matrix:oe,material:ae})],s),A(g,r={...r,loop:l,enabled:!0},r),u=R(c,_)})),[c,function(e){P[e?"unshift":"push"]((()=>{c=e,a(0,c)}))}]}class re extends e{constructor(e){super(),t(this,e,ae,te,a,{})}}export{re as default};
