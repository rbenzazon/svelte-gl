import{S as e,i as t,s as r,M as a,e as s,a as n,c as o,b as i,m as c,n as u,t as d,d as l,f,g as p,h as m,o as g,r as y,j as w,k as h,q as b,p as T,A,B as x,H as I,y as _,z as D,w as k,K as M,I as E,as as U,x as C,E as j,F as v,G as L}from"./engine.js";import{c as R}from"./skybox.js";import{c as P,g as S,h as G,a as N,b as O}from"./environment-map-texture.js";import{c as H}from"./specular.js";import{l as B,m as F,i as $,b as q}from"./gltf-loader.js";import{d as z}from"./jpeg-hdr-loader.js";let K={taskID:0,pending:!1,decode:async function(e,t,r,a){const s={attributeIDs:r,attributeTypes:a,useUniqueIDs:!0,vertexColorSpace:"SRGB"};return await new Promise(((r,a)=>{const{worker:n}=e;let{taskID:o}=e;n._callbacks[o]={resolve:r,reject:a},n.postMessage({type:"decode",id:o,taskConfig:s,buffer:t},[t]),o++}))}};async function W(e){if(K.pending)return K.promise;let t={};const r=new Promise(((e,r)=>{t.resolve=e,t.reject=r}));K.promise=r,K.pending=!0;const a=fetch(e+"draco_wasm_wrapper.js"),s=fetch(e+"draco_decoder.wasm");await Promise.all([a,s]);const n=await(await a).text(),o=await(await s).arrayBuffer(),i=function(e){const t=Y.toString(),r=["/* draco decoder */",e,"","/* worker */",t.substring(t.indexOf("{")+1,t.lastIndexOf("}"))].join("\n");return URL.createObjectURL(new Blob([r]))}(n),c=new Worker(i);return c._callbacks={},c.postMessage({type:"init",decoderConfig:{wasmBinary:o}}),c.onmessage=function(e){const t=e.data;switch(t.type){case"decode":c._callbacks[t.id].resolve(t);break;case"error":c._callbacks[t.id].reject(t);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+t.type+'"')}},K.worker=c,K.taskID=0,t.resolve(),K}function Y(){let e,t;function r(e,t,r,a,s,n){const o=n.num_components(),i=r.num_points()*o,c=i*s.BYTES_PER_ELEMENT,u=function(e,t){switch(t){case Float32Array:return e.DT_FLOAT32;case Int8Array:return e.DT_INT8;case Int16Array:return e.DT_INT16;case Int32Array:return e.DT_INT32;case Uint8Array:return e.DT_UINT8;case Uint16Array:return e.DT_UINT16;case Uint32Array:return e.DT_UINT32}}(e,s),d=e._malloc(c);t.GetAttributeDataArrayForAllPoints(r,n,u,c,d);const l=new s(e.HEAPF32.buffer,d,i).slice();return e._free(d),{name:a,array:l,itemSize:o}}onmessage=function(a){const s=a.data;switch(s.type){case"init":e=s.decoderConfig,t=new Promise((function(t){e.onModuleLoaded=function(e){t({draco:e})},DracoDecoderModule(e)}));break;case"decode":const a=s.buffer,n=s.taskConfig;t.then((e=>{const t=e.draco,o=new t.Decoder;try{const e=function(e,t,a,s){const n=s.attributeIDs,o=s.attributeTypes;let i,c;const u=t.GetEncodedGeometryType(a);if(u===e.TRIANGULAR_MESH)i=new e.Mesh,c=t.DecodeArrayToMesh(a,a.byteLength,i);else{if(u!==e.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");i=new e.PointCloud,c=t.DecodeArrayToPointCloud(a,a.byteLength,i)}if(!c.ok()||0===i.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+c.error_msg());const d={index:null,attributes:[]};for(const l in n){const a=self[o[l]];let c,u;if(s.useUniqueIDs)u=n[l],c=t.GetAttributeByUniqueId(i,u);else{if(u=t.GetAttributeId(i,e[n[l]]),-1===u)continue;c=t.GetAttribute(i,u)}const f=r(e,t,i,l,a,c);"color"===l&&(f.vertexColorSpace=s.vertexColorSpace),d.attributes.push(f)}u===e.TRIANGULAR_MESH&&(d.index=function(e,t,r){const a=r.num_faces(),s=3*a,n=4*s,o=e._malloc(n);t.GetTrianglesUInt32Array(r,n,o);const i=new Uint32Array(e.HEAPF32.buffer,o,s).slice();return e._free(o),{array:i,itemSize:1}}(e,t,i));return e.destroy(i),d}(t,o,new Int8Array(a),n),i=e.attributes.map((e=>e.array.buffer));e.index&&i.push(e.index.array.buffer),self.postMessage({type:"decode",id:s.id,geometry:e},i)}catch(i){console.error(i),self.postMessage({type:"error",id:s.id,error:i.message})}finally{t.destroy(o)}}))}}}function J(e){let t,r,m,g;return m=new a({}),{c(){t=s("canvas"),r=n(),o(m.$$.fragment)},m(a,s){i(a,t,s),e[1](t),i(a,r,s),c(m,a,s),g=!0},p:u,i(e){g||(d(m.$$.fragment,e),g=!0)},o(e){l(m.$$.fragment,e),g=!1},d(a){a&&(f(t),f(r)),e[1](null),p(m,a)}}}function Q(){}function V(e,t,r){let a,s,n,o,i,c;return m(e,y,(e=>r(3,a=e))),m(e,w,(e=>r(4,s=e))),m(e,h,(e=>r(5,n=e))),m(e,b,(e=>r(6,o=e))),m(e,T,(e=>r(7,i=e))),g((async()=>{A(y,a={...a,canvas:c,backgroundColor:x,ambientLightColor:[16777215,.1],toneMappings:[P({exposure:1})]},a),A(T,i={...i,position:[4,.8,2],target:[2,0,-1],fov:75},i);const e=await z("skyboxes/spruit-sunrise-8k-hdr.jpg"),t=S(1),r=await R({texture:e.texture,width:e.texture.width,height:e.texture.height,convertToCube:G,cubeSize:2048,toneMapping:t}),u=N(e.texture,e.width,e.height);A(b,o=[r,u],o);const d=O({envMap:u.getTexture,width:u.width,height:u.height,lodMax:u.lodMax}),l=await W("draco/"),f=await B("models/gamefont-a-draco.gltf","models/gamefont-a-draco.bin",l),p=F(f.scene).find($),m=q(f,p),g=I({metalness:.95,specular:H({roughness:.08,ior:1.4,intensity:.8,color:[1,1,1]}),diffuse:[1,215/255,0],envMap:d}),L=I({metalness:0,specular:H({roughness:.08,ior:1.4,intensity:.8,color:[1,1,1]}),diffuse:[1,215/255,0],envMap:d}),K=_(D());k(K,K,[8,8,8]),M(K,K,Math.PI/4),E(K,K,Math.PI/2);const Y=U(D(),K);C(Y,Y,[.5,0,0]),A(h,n=[...n,L,g],n),A(w,s=[...s,j({...m,matrix:K,material:L}),j({...m,matrix:Y,material:g})],s),A(y,a={...a,loop:Q,enabled:!0},a),v(c,T)})),[c,function(e){L[e?"unshift":"push"]((()=>{c=e,r(0,c)}))}]}new class extends e{constructor(e){super(),t(this,e,V,J,r,{})}}({target:document.body});
