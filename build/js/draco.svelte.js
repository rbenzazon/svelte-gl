import{S as e,i as t,s as r,M as a,e as s,a as n,c as o,b as i,m as c,n as u,t as d,d as l,f,g as p,h as m,o as g,r as y,k as h,p as w,q as b,j as T,u as A,v as x,w as I,x as _,y as D,H as k,G as M,B as E,as as U,z as v,A as C,E as j,I as L}from"./engine.js";import{c as R}from"./skybox.js";import{c as P,g as S,h as G,a as N,b as O}from"./environment-map-texture.js";import{c as H}from"./specular.js";import{l as B,m as $,i as F,c as q}from"./gltf-loader.js";import{d as z}from"./jpeg-hdr-loader.js";let W={taskID:0,pending:!1,decode:async function(e,t,r,a){const s={attributeIDs:r,attributeTypes:a,useUniqueIDs:!0,vertexColorSpace:"SRGB"};return await new Promise(((r,a)=>{const{worker:n}=e;let{taskID:o}=e;n._callbacks[o]={resolve:r,reject:a},n.postMessage({type:"decode",id:o,taskConfig:s,buffer:t},[t]),o++}))}};async function Y(e){if(W.pending)return W.promise;let t={};const r=new Promise(((e,r)=>{t.resolve=e,t.reject=r}));W.promise=r,W.pending=!0;const a=fetch(e+"draco_wasm_wrapper.js"),s=fetch(e+"draco_decoder.wasm");await Promise.all([a,s]);const n=await(await a).text(),o=await(await s).arrayBuffer(),i=function(e){const t=J.toString(),r=["/* draco decoder */",e,"","/* worker */",t.substring(t.indexOf("{")+1,t.lastIndexOf("}"))].join("\n");return URL.createObjectURL(new Blob([r]))}(n),c=new Worker(i);return c._callbacks={},c.postMessage({type:"init",decoderConfig:{wasmBinary:o}}),c.onmessage=function(e){const t=e.data;switch(t.type){case"decode":c._callbacks[t.id].resolve(t);break;case"error":c._callbacks[t.id].reject(t);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+t.type+'"')}},W.worker=c,W.taskID=0,t.resolve(),W}function J(){let e,t;function r(e,t,r,a,s,n){const o=n.num_components(),i=r.num_points()*o,c=i*s.BYTES_PER_ELEMENT,u=function(e,t){switch(t){case Float32Array:return e.DT_FLOAT32;case Int8Array:return e.DT_INT8;case Int16Array:return e.DT_INT16;case Int32Array:return e.DT_INT32;case Uint8Array:return e.DT_UINT8;case Uint16Array:return e.DT_UINT16;case Uint32Array:return e.DT_UINT32}}(e,s),d=e._malloc(c);t.GetAttributeDataArrayForAllPoints(r,n,u,c,d);const l=new s(e.HEAPF32.buffer,d,i).slice();return e._free(d),{name:a,array:l,itemSize:o}}onmessage=function(a){const s=a.data;switch(s.type){case"init":e=s.decoderConfig,t=new Promise((function(t){e.onModuleLoaded=function(e){t({draco:e})},DracoDecoderModule(e)}));break;case"decode":const a=s.buffer,n=s.taskConfig;t.then((e=>{const t=e.draco,o=new t.Decoder;try{const e=function(e,t,a,s){const n=s.attributeIDs,o=s.attributeTypes;let i,c;const u=t.GetEncodedGeometryType(a);if(u===e.TRIANGULAR_MESH)i=new e.Mesh,c=t.DecodeArrayToMesh(a,a.byteLength,i);else{if(u!==e.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");i=new e.PointCloud,c=t.DecodeArrayToPointCloud(a,a.byteLength,i)}if(!c.ok()||0===i.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+c.error_msg());const d={index:null,attributes:[]};for(const a in n){const c=self[o[a]];let u,l;if(s.useUniqueIDs)l=n[a],u=t.GetAttributeByUniqueId(i,l);else{if(l=t.GetAttributeId(i,e[n[a]]),-1===l)continue;u=t.GetAttribute(i,l)}const f=r(e,t,i,a,c,u);"color"===a&&(f.vertexColorSpace=s.vertexColorSpace),d.attributes.push(f)}u===e.TRIANGULAR_MESH&&(d.index=function(e,t,r){const a=r.num_faces(),s=3*a,n=4*s,o=e._malloc(n);t.GetTrianglesUInt32Array(r,n,o);const i=new Uint32Array(e.HEAPF32.buffer,o,s).slice();return e._free(o),{array:i,itemSize:1}}(e,t,i));return e.destroy(i),d}(t,o,new Int8Array(a),n),i=e.attributes.map((e=>e.array.buffer));e.index&&i.push(e.index.array.buffer),self.postMessage({type:"decode",id:s.id,geometry:e},i)}catch(e){console.error(e),self.postMessage({type:"error",id:s.id,error:e.message})}finally{t.destroy(o)}}))}}}function K(e){let t,r,m,g;return m=new a({}),{c(){t=s("canvas"),r=n(),o(m.$$.fragment)},m(a,s){i(a,t,s),e[1](t),i(a,r,s),c(m,a,s),g=!0},p:u,i(e){g||(d(m.$$.fragment,e),g=!0)},o(e){l(m.$$.fragment,e),g=!1},d(a){a&&(f(t),f(r)),e[1](null),p(m,a)}}}function Q(){}function V(e,t,r){let a,s,n,o,i,c;return m(e,y,(e=>r(3,a=e))),m(e,h,(e=>r(4,s=e))),m(e,w,(e=>r(5,n=e))),m(e,b,(e=>r(6,o=e))),m(e,T,(e=>r(7,i=e))),g((async()=>{A(y,a={...a,canvas:c,backgroundColor:x,ambientLightColor:[16777215,.1],toneMappings:[P({exposure:1})]},a),A(T,i={...i,position:[4,.8,2],target:[2,0,-1],fov:75},i);const e=await z("spruit-sunrise-8k-hdr.jpg"),t=S(1),r=await R({texture:e.texture,width:e.texture.width,height:e.texture.height,convertToCube:G,cubeSize:2048,toneMapping:t}),u=N(e.texture,e.width,e.height);A(b,o=[r,u],o);const d=O({envMap:u.getTexture,width:u.width,height:u.height,lodMax:u.lodMax}),l=await Y("draco/"),f=await B("models/gamefont-a-draco.gltf","models/gamefont-a-draco.bin",l),p=$(f.scene).find(F),m=q(f,p),g=I({metalness:.95,specular:H({roughness:.08,ior:1.4,intensity:.8,color:[1,1,1]}),diffuse:[1,215/255,0],envMap:d}),L=I({metalness:0,specular:H({roughness:.08,ior:1.4,intensity:.8,color:[1,1,1]}),diffuse:[1,215/255,0],envMap:d}),W=_(D());k(W,W,[8,8,8]),M(W,W,Math.PI/4),E(W,W,Math.PI/2);const J=U(D(),W);v(J,J,[.5,0,0]),A(w,n=[...n,L,g],n),A(h,s=[...s,C({...m,matrix:W,material:L}),C({...m,matrix:J,material:g})],s),A(y,a={...a,loop:Q,enabled:!0},a),j(c,T)})),[c,function(e){L[e?"unshift":"push"]((()=>{c=e,r(0,c)}))}]}class X extends e{constructor(e){super(),t(this,e,V,K,r,{})}}export{X as default};
