import{Q as r,av as a,Z as e,_ as t,a0 as n,a1 as o,a6 as i,aA as s,U as l,T as c}from"./engine-B_VjxpyI.js";function v(a){const{normals:e,positions:t}=a.attributes,n="Float32Array"!=typeof t&&"data"in t?t.data:t,o="Float32Array"!=typeof e&&"data"in e?e.data:e,i=[];for(let r=0;r<n.length;r+=3)i.push(n[r],n[r+1],n[r+2]),i.push(n[r]+.2*o[r],n[r+1]+.2*o[r+1],n[r+2]+.2*o[r+2]);return{attributes:{positions:new Float32Array(i)},matrix:a.matrix.value,material:a.material,drawMode:r[1]}}var m="#version 300 es\r\nprecision mediump float;\r\n\r\n#define SHADER_NAME basicFragment\r\n\r\n// Input from vertex shader\r\nin vec3 vertexColor;\r\nin vec3 vNormal;\r\nin vec3 vertex;\r\nin vec3 vViewPosition;\r\nin highp vec2 vUv;\r\n\r\n// Output color\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n    // Simply use the vertex color for the fragment color\r\n    // This will create a simple colored line with no lighting effects\r\n    fragColor = vec4(vertexColor, 1.0);\r\n    \r\n    // Alternative: if you want slightly smoother lines with anti-aliasing\r\n    // float intensity = 1.0;\r\n    // fragColor = vec4(vertexColor * intensity, 1.0);\r\n}";function f(){return{createProgram:a,setupProgram:[p,e,t],setupMaterial:[],useProgram:n,selectProgram:o,updateProgram:[]}}function p(){const{gl:r,program:a}=c,e=i(s,{instances:!1,declarations:"",positionModifier:""})({instances:!1,declarations:"",positionModifier:""});l(r,a,e,m)}export{f as a,v as c};
