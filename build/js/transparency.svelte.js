import { S as SvelteComponent, i as init, s as safe_not_equal, M as Menu, e as element, a as space, c as create_component, b as insert, m as mount_component, n as noop, t as transition_in, d as transition_out, f as detach, g as destroy_component, h as component_subscribe, o as onMount, r as renderer, j as scene, k as camera, x as set_store_value, y as skyblue, w as identity, v as translate, z as createLightStore, A as createPointLight, B as create3DObject, C as createOrbitControls, D as binding_callbacks, W as createFlatShadedNormals } from './Menu-UFopFIWZ.js';
import { c as createPolyhedron, a as createSmoothShadedNormals } from './polyhedron-Cd9snOK7.js';
import { c as createCube } from './cube-CAZxzDAW.js';
import { c as createPlane } from './plane-D3PAFwSq.js';

/* src\transparency.svelte generated by Svelte v4.2.18 */

function create_fragment(ctx) {
	let canvas_1;
	let t;
	let menu;
	let current;
	menu = new Menu({});

	return {
		c() {
			canvas_1 = element("canvas");
			t = space();
			create_component(menu.$$.fragment);
		},
		m(target, anchor) {
			insert(target, canvas_1, anchor);
			/*canvas_1_binding*/ ctx[1](canvas_1);
			insert(target, t, anchor);
			mount_component(menu, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(menu.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(menu.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(canvas_1);
				detach(t);
			}

			/*canvas_1_binding*/ ctx[1](null);
			destroy_component(menu, detaching);
		}
	};
}

function animate() {
	
} // animate here

function instance($$self, $$props, $$invalidate) {
	let $renderer;
	let $scene;
	let $camera;
	component_subscribe($$self, renderer, $$value => $$invalidate(2, $renderer = $$value));
	component_subscribe($$self, scene, $$value => $$invalidate(3, $scene = $$value));
	component_subscribe($$self, camera, $$value => $$invalidate(4, $camera = $$value));
	let canvas;

	onMount(async () => {
		set_store_value(
			renderer,
			$renderer = {
				...$renderer,
				canvas,
				backgroundColor: skyblue,
				ambientLightColor: [0xffffff, 0.1]
			},
			$renderer
		);

		set_store_value(
			camera,
			$camera = {
				position: [0, 5, -5],
				target: [0, 1, 0],
				fov: 75
			},
			$camera
		);

		const cubeMesh = createCube();
		const cubePos = identity(new Float32Array(16));
		translate(cubePos, cubePos, [3, 1.5, 0]);
		const material = { diffuse: [1, 0.5, 0.5], metalness: 0 };
		const sphereMesh = createPolyhedron(1, 5, createSmoothShadedNormals);
		const spherePos = identity(new Float32Array(16));
		translate(spherePos, spherePos, [-3, 1.5, 0]);

		const transparentMaterial = {
			diffuse: [1, 1, 0.5],
			metalness: 0,
			opacity: 0.5
		};

		const polyhedronMesh = createPolyhedron(1, 2, createFlatShadedNormals);
		const polyhedronPos = identity(new Float32Array(16));
		translate(polyhedronPos, polyhedronPos, [0, 1.5, 0]);
		const groundMesh = createPlane(10, 10, 1, 1);
		const groundMatrix = identity(new Float32Array(16));
		translate(groundMatrix, groundMatrix, [0, 0, 0]);
		const groundMaterial = { diffuse: [1, 1, 1], metalness: 0 };

		const light = createLightStore(createPointLight({
			position: [-2, 3, -3],
			color: [1, 1, 1],
			intensity: 20,
			cutoffDistance: 0,
			decayExponent: 2
		}));

		const light2 = createLightStore(createPointLight({
			position: [2, 0, -4],
			color: [1, 1, 1],
			intensity: 5,
			cutoffDistance: 0,
			decayExponent: 2
		}));

		set_store_value(
			scene,
			$scene = [
				...$scene,
				create3DObject({
					...sphereMesh,
					matrix: spherePos,
					material: transparentMaterial
				}),
				create3DObject({
					...polyhedronMesh,
					matrix: polyhedronPos,
					material: transparentMaterial
				}),
				create3DObject({ ...cubeMesh, matrix: cubePos, material }),
				create3DObject({
					...groundMesh,
					matrix: groundMatrix,
					material: groundMaterial
				}),
				light,
				light2
			],
			$scene
		);

		set_store_value(
			renderer,
			$renderer = {
				...$renderer,
				loop: animate,
				enabled: true
			},
			$renderer
		);

		createOrbitControls(canvas, camera);
	});

	function canvas_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvas = $$value;
			$$invalidate(0, canvas);
		});
	}

	return [canvas, canvas_1_binding];
}

class Transparency extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export { Transparency as default };
