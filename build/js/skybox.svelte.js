import{av as e,r,a7 as t,X as n,Y as o,Z as a,_ as i,R as s,L as c,aw as E,ax as u,z as l,$ as f,K as T,J as m,U as p,I as _,ay as d,W as g,S as A,i as h,s as R,M as v,e as U,a as P,c as M,b,m as w,n as x,t as y,d as C,f as S,g as F,h as I,o as L,l as X,j as B,k as D,q as G,p as O,A as N,B as H,C as V,D as k,y as $,E as j,F as z,G as W,H as Y}from"./Menu-Bv4_14nS.js";import{c as q}from"./cube-Bf1EfJoq.js";import{c as Z,a as K}from"./debug-program-hoaZlCQG.js";var J="#version 300 es\r\n\r\n#define SHADER_NAME skyboxVertex\r\n\r\nin vec4 position;\r\nout vec4 v_position;\r\nvoid main() {\r\n    v_position = position;\r\n    gl_Position = position;\r\n    gl_Position.z = 1.0;\r\n}",Q="#version 300 es\r\nprecision highp float;\r\n\r\n#define SHADER_NAME skyboxFragment\r\n\r\nuniform samplerCube skybox;\r\nuniform mat4 viewDirectionProjectionInverse;\r\n\r\n${declarations}\r\n  \r\nin vec4 v_position;\r\n  \r\n// we need to declare an output for the fragment shader\r\nout vec4 fragColor;\r\n  \r\nvoid main() {\r\n  vec4 t = viewDirectionProjectionInverse * v_position;\r\n  fragColor = texture(skybox, normalize(t.xyz / t.w));\r\n  ${toneMappings}\r\n}";async function ee(t){let E,u;function l(e){E=e}function f(){return E}const T={createProgram:e,setupProgram:[n,o],setupMaterial:[],bindTextures:[oe(f)],setupCamera:te,useProgram:a,selectProgram:i,updateProgram:[ae((function(e){u=e}))],meshes:[{attributes:{positionsSize:2,positions:new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1])},drawMode:c[4]}],postDraw:ie((function(){return u}))};let m,p,_;return!function(e){return"url"in e&&"string"==typeof e.url}(t)?function(e){return"typedArray"in e&&e.typedArray instanceof Uint16Array}(t)&&(p=t.typedArray,T.createProgram=function(r){return function(t){return function(){null!=r&&r(),e(t)()}}}(function(e,t,n,o,a,i){return function(){const{gl:c}=s,E=n(e,c,o,a,i);t(E),console.log("setupHDRTexture"),r.update((e=>e))}}(p,l,t.convertToCube,t.width,t.height,t.cubeSize)),_=t.toneMapping,T.setupProgram=[re(_),...T.setupProgram],T.setupMaterial=[oe(f)],m={}):(T.setupMaterial=[await ne(t.url,l)],T.setupProgram=[re(),...T.setupProgram],m={url:t.url}),{...m,order:1,programs:[T]}}function re(e){return function(){const{gl:r,program:n}=s,o=r.createShader(r.VERTEX_SHADER);r.shaderSource(o,J),r.compileShader(o),r.getShaderParameter(o,r.COMPILE_STATUS)||console.error(r.getShaderInfoLog(o)),r.attachShader(n,o);const a=r.createShader(r.FRAGMENT_SHADER);let i="",c="";null!=e&&(i=e.shader({declaration:!0,exposure:e.exposure}),c=e.shader({color:!0}));const E=t(Q,{declarations:"",toneMappings:""})({declarations:i,toneMappings:c});r.shaderSource(a,E),r.compileShader(a),r.getShaderParameter(a,r.COMPILE_STATUS)||console.error(r.getShaderInfoLog(a)),r.attachShader(n,a)}}function te(e){return function(){const{gl:r,program:t,canvas:n}=s,{projection:o}=E(e,n.width,n.height);console.log("camera",e);const a=(i=e.position,c=e.target,d=e.up,g=l(),A=T(p(),m(p(),i,c)),h=T(p(),_(p(),d,A)),R=T(p(),_(p(),A,h)),g[0]=h[0],g[1]=h[1],g[2]=h[2],g[3]=0,g[4]=R[0],g[5]=R[1],g[6]=R[2],g[7]=0,g[8]=A[0],g[9]=A[1],g[10]=A[2],g[11]=0,g[12]=i[0],g[13]=i[1],g[14]=i[2],g[15]=1,g);var i,c,d,g,A,h,R;const v=u(l(),a);v[12]=0,v[13]=0,v[14]=0;const U=f(l(),o,v),P=u(l(),U),M=r.getUniformLocation(t,"viewDirectionProjectionInverse");console.log("viewDirectionProjectionInverseMatrix",P),r.uniformMatrix4fv(M,!1,P),console.log("after")}}async function ne(e,t){const n=new Image;return await new Promise(((r,t)=>{n.src=e,n.onload=function(){r(n)},n.onerror=t})),function(){const{gl:n}=s,o=n.createTexture();t(o),n.bindTexture(n.TEXTURE_CUBE_MAP,o);const a=new Image;a.src=e,n.bindTexture(n.TEXTURE_CUBE_MAP,o),function(e,r){const t=document.createElement("canvas"),n=t.getContext("2d"),o=e.width/4,a=e.height/3;t.width=o,t.height=a;const i=[[2,1,r.TEXTURE_CUBE_MAP_POSITIVE_X],[0,1,r.TEXTURE_CUBE_MAP_NEGATIVE_X],[1,0,r.TEXTURE_CUBE_MAP_POSITIVE_Y],[1,2,r.TEXTURE_CUBE_MAP_NEGATIVE_Y],[1,1,r.TEXTURE_CUBE_MAP_POSITIVE_Z],[3,1,r.TEXTURE_CUBE_MAP_NEGATIVE_Z]];i.forEach((([i,s,c])=>{n.clearRect(0,0,o,a),n.drawImage(e,i*o,s*a,o,a,0,0,o,a),r.texImage2D(c,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,t)}))}(a,n),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MIN_FILTER,n.LINEAR_MIPMAP_LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_MAG_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_CUBE_MAP,n.TEXTURE_WRAP_R,n.CLAMP_TO_EDGE),n.generateMipmap(n.TEXTURE_CUBE_MAP),r.update((e=>e))}}function oe(e){return function(){console.log("bindSkyBoxTexture");const{gl:r,program:t}=s,n=r.getUniformLocation(t,"skybox");r.uniform1i(n,0),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_CUBE_MAP,e())}}function ae(e){return function(){const{gl:r}=s;e(r.getParameter(r.DEPTH_FUNC)),r.depthFunc(r.LEQUAL)}}function ie(e){return function(){const{gl:r}=s;r.depthFunc(e())}}const se=1016,ce=1015;async function Ee(e){const r=await fetch(e);return function(e){const r=se,t=1,n=2,o=3,a=4,i=1,s=2,c=4,E="\n",u=new Uint8Array(e);u.pos=0;const l=A(u),f=l.width,T=l.height,m=h(u.subarray(u.pos),f,T);let p,_;switch(r){case ce:_=m.length/4;const e=new Float32Array(4*_);for(let r=0;r<_;r++)R(m,4*r,e,4*r);p=e;break;case se:_=m.length/4;const t=new Uint16Array(4*_);for(let e=0;e<_;e++)v(m,4*e,t,4*e);p=t;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+r)}return{width:f,height:T,data:p,header:l.string,gamma:l.gamma,exposure:l.exposure,type:r};function d(e,r){switch(e){case t:throw new Error("THREE.RGBELoader: Read Error: "+(r||""));case n:throw new Error("THREE.RGBELoader: Write Error: "+(r||""));case o:throw new Error("THREE.RGBELoader: Bad File Format: "+(r||""));default:throw new Error("THREE.RGBELoader: Memory Error: "+(r||""))}}function g(e,r,t){const n=128;r=r||1024;let o=e.pos,a=-1,i=0,s="",c=String.fromCharCode.apply(null,new Uint16Array(e.subarray(o,o+n)));for(;0>(a=c.indexOf(E))&&i<r&&o<e.byteLength;)s+=c,i+=c.length,o+=n,c+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(o,o+n)));return-1<a&&(e.pos+=i+a+1,s+c.slice(0,a))}function A(e){const r=/^#\?(\S+)/,n=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,E=/^\s*FORMAT=(\S+)\s*$/,u=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,l={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let f,T;for((e.pos>=e.byteLength||!(f=g(e)))&&d(t,"no header found"),(T=f.match(r))||d(o,"bad initial token"),l.valid|=i,l.programtype=T[1],l.string+=f+"\n";f=g(e),!1!==f;)if(l.string+=f+"\n","#"!==f.charAt(0)){if((T=f.match(n))&&(l.gamma=parseFloat(T[1])),(T=f.match(a))&&(l.exposure=parseFloat(T[1])),(T=f.match(E))&&(l.valid|=s,l.format=T[1]),(T=f.match(u))&&(l.valid|=c,l.height=parseInt(T[1],10),l.width=parseInt(T[2],10)),l.valid&s&&l.valid&c)break}else l.comments+=f+"\n";return l.valid&s||d(o,"missing format specifier"),l.valid&c||d(o,"missing image size specifier"),l}function h(e,r,n){const i=r;if(i<8||i>32767||2!==e[0]||2!==e[1]||128&e[2])return new Uint8Array(e);i!==(e[2]<<8|e[3])&&d(o,"wrong scanline width");const s=new Uint8Array(4*r*n);s.length||d(a,"unable to allocate buffer space");let c=0,E=0;const u=4*i,l=new Uint8Array(4),f=new Uint8Array(u);let T=n;for(;T>0&&E<e.byteLength;){E+4>e.byteLength&&d(t),l[0]=e[E++],l[1]=e[E++],l[2]=e[E++],l[3]=e[E++],2==l[0]&&2==l[1]&&(l[2]<<8|l[3])==i||d(o,"bad rgbe scanline format");let r,n=0;for(;n<u&&E<e.byteLength;){r=e[E++];const t=r>128;if(t&&(r-=128),(0===r||n+r>u)&&d(o,"bad scanline data"),t){const t=e[E++];for(let e=0;e<r;e++)f[n++]=t}else f.set(e.subarray(E,E+r),n),n+=r,E+=r}const a=i;for(let e=0;e<a;e++){let r=0;s[c]=f[e+r],r+=i,s[c+1]=f[e+r],r+=i,s[c+2]=f[e+r],r+=i,s[c+3]=f[e+r],c+=4}T--}return s}function R(e,r,t,n){const o=e[r+3],a=Math.pow(2,o-128)/255;t[n+0]=e[r+0]*a,t[n+1]=e[r+1]*a,t[n+2]=e[r+2]*a,t[n+3]=1}function v(e,r,t,n){const o=e[r+3],a=Math.pow(2,o-128)/255;t[n+0]=ue(Math.min(e[r+0]*a,65504)),t[n+1]=ue(Math.min(e[r+1]*a,65504)),t[n+2]=ue(Math.min(e[r+2]*a,65504)),t[n+3]=ue(1)}}(await r.arrayBuffer())}function ue(e){var r,t,n;Math.abs(e)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),r=e,t=-65504,n=65504,e=Math.max(t,Math.min(n,r)),le.floatView[0]=e;const o=le.uint32View[0],a=o>>23&511;return le.baseTable[a]+((8388607&o)>>le.shiftTable[a])}const le=fe();function fe(){const e=new ArrayBuffer(4),r=new Float32Array(e),t=new Uint32Array(e),n=new Uint32Array(512),o=new Uint32Array(512);for(let e=0;e<256;++e){const r=e-127;r<-27?(n[e]=0,n[256|e]=32768,o[e]=24,o[256|e]=24):r<-14?(n[e]=1024>>-r-14,n[256|e]=1024>>-r-14|32768,o[e]=-r-1,o[256|e]=-r-1):r<=15?(n[e]=r+15<<10,n[256|e]=r+15<<10|32768,o[e]=13,o[256|e]=13):r<128?(n[e]=31744,n[256|e]=64512,o[e]=24,o[256|e]=24):(n[e]=31744,n[256|e]=64512,o[e]=13,o[256|e]=13)}const a=new Uint32Array(2048),i=new Uint32Array(64),s=new Uint32Array(64);for(let e=1;e<1024;++e){let r=e<<13,t=0;for(;!(8388608&r);)r<<=1,t-=8388608;r&=-8388609,t+=947912704,a[e]=r|t}for(let e=1024;e<2048;++e)a[e]=939524096+(e-1024<<13);for(let e=1;e<31;++e)i[e]=e<<23;i[31]=1199570944,i[32]=2147483648;for(let e=33;e<63;++e)i[e]=2147483648+(e-32<<23);i[63]=3347054592;for(let e=1;e<64;++e)32!==e&&(s[e]=1024);return{floatView:r,uint32View:t,baseTable:n,shiftTable:o,mantissaTable:a,exponentTable:i,offsetTable:s}}const Te=e=>({exposure:`${e.exposure.toLocaleString("en",{minimumFractionDigits:1})}f`,shader:t("${declaration?\r\n`\r\n#ifndef saturate\r\n    #define saturate( a ) clamp( a, 0.0, 1.0 )\r\n#endif\r\n\r\nfloat toneMappingExposure = ${exposure};\r\n\r\nvec3 RRTAndODTFit( vec3 v ) {\r\n    vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\r\n    vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\r\n    return a / b;\r\n}\r\nvec3 ACESFilmicToneMapping( vec3 color ) {\r\n    const mat3 ACESInputMat = mat3(\r\n    vec3( 0.59719, 0.07600, 0.02840 ), vec3( 0.35458, 0.90834, 0.13383 ), vec3( 0.04823, 0.01566, 0.83777 )\r\n    );\r\n    const mat3 ACESOutputMat = mat3(\r\n    vec3(  1.60475, -0.10208, -0.00327 ), vec3( -0.53108, 1.10813, -0.07276 ), vec3( -0.07367, -0.00605, 1.07602 )\r\n    );\r\n    color *= toneMappingExposure / 0.6;\r\n    color = ACESInputMat * color;\r\n    color = RRTAndODTFit( color );\r\n    color = ACESOutputMat * color;\r\n    return saturate( color );\r\n}\r\nvec4 sRGBTransferOETF( in vec4 value ) {\r\n    return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\r\n}\r\n` : ''\r\n}\r\n${color?\r\n`\r\n    fragColor = vec4(ACESFilmicToneMapping(fragColor.rgb),1.0f);\r\n    fragColor = sRGBTransferOETF(fragColor);\r\n    \r\n` : ''\r\n}",{declaration:!1,exposure:1,color:!1})});function me(e,r,t,n,o=1024){console.log("hdrToCube");if(!r.getExtension("EXT_color_buffer_float"))throw new Error("EXT_color_buffer_float extension not supported");const a=function(e,r,t,n){const o=e.createTexture();return e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,e.RGBA16F,t,n,0,e.RGBA,e.HALF_FLOAT,r),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),o}(r,e,t,n),i=function(e,r){const t=e.createTexture();e.bindTexture(e.TEXTURE_CUBE_MAP,t);for(let t=0;t<6;t++)e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,e.RGBA16F,r,r,0,e.RGBA,e.HALF_FLOAT,null);return e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_R,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MAG_FILTER,e.LINEAR),t}(r,o),{program:s,vertexArray:c}=function(e){const r="#version 300 es\n\n    #define SHADER_NAME hdrToCubeVertex\n\n    layout(location = 0) in vec2 position;\n    out vec3 localPos;\n    uniform mat4 projection;\n    uniform mat4 view;\n\n    void main() {\n        // Use the quad positions directly for rendering\n        gl_Position = vec4(position, 0.0, 1.0);\n        \n        // Create the ray direction for this fragment\n        // Map from [-1,1] to [-1,1] in view space for proper cubemap sampling\n        vec4 viewPos = inverse(projection * view) * vec4(position, 1.0, 1.0);\n        localPos = viewPos.xyz / viewPos.w;\n    }",t="#version 300 es\n\n    #define SHADER_NAME hdrToCubeFragment\n\n    precision highp float;\n    in vec3 localPos;\n    out vec4 fragColor;\n    uniform sampler2D equirectangularMap;\n\n    vec2 SampleSphericalMap(vec3 v) {\n        // Convert direction vector to spherical coordinates\n        float phi = atan(v.z, v.x);\n        float theta = asin(v.y);\n        \n        // Map from [-π to π] for phi and [-π/2 to π/2] for theta to [0,1] range\n        vec2 uv = vec2(\n            0.5 + 0.5 * phi / 3.1415926535897932,\n            0.5 - theta / 3.1415926535897932\n        );\n        \n        return uv;\n    }\n\n    void main() {\n        vec3 direction = normalize(localPos);\n        vec2 uv = SampleSphericalMap(direction);\n        fragColor = texture(equirectangularMap, uv);\n    }",n=e.createShader(e.VERTEX_SHADER);e.shaderSource(n,r),e.compileShader(n);const o=e.createShader(e.FRAGMENT_SHADER);e.shaderSource(o,t),e.compileShader(o);const a=e.createProgram();if(e.attachShader(a,n),e.attachShader(a,o),e.linkProgram(a),!e.getProgramParameter(a,e.LINK_STATUS))throw console.error("Shader program error:",e.getProgramInfoLog(a)),console.error("Vertex shader log:",e.getShaderInfoLog(n)),console.error("Fragment shader log:",e.getShaderInfoLog(o)),new Error("Failed to compile shaders");const i=e.createVertexArray();e.bindVertexArray(i);const s=new Float32Array([-1,-1,1,-1,-1,1,1,1]),c=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,c),e.bufferData(e.ARRAY_BUFFER,s,e.STATIC_DRAW),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,0,0),{program:a,vertexArray:i}}(r),E=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,E),r.useProgram(s),r.bindVertexArray(c),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,a),r.uniform1i(r.getUniformLocation(s,"equirectangularMap"),0);const u=l(),f=Math.PI/2,T=1/Math.tan(f/2);u[0]=T/1,u[5]=T,u[10]=10.1/-9.9,u[11]=-1,u[14]=2/-9.9;const m=r.getUniformLocation(s,"projection");console.log("projectionLocation",m),r.uniformMatrix4fv(m,!1,u);const _=[],A=p();for(let e=0;e<6;e++){const r=d();let t,n;switch(e){case 0:t=[1,0,0],n=[0,-1,0];break;case 1:t=[-1,0,0],n=[0,-1,0];break;case 2:t=[0,1,0],n=[0,0,1];break;case 3:t=[0,-1,0],n=[0,0,-1];break;case 4:t=[0,0,1],n=[0,-1,0];break;case 5:t=[0,0,-1],n=[0,-1,0]}const o=[A[0]+t[0],A[1]+t[1],A[2]+t[2]];g(r,A,o,n),_.push(r)}for(let e=0;e<6;e++){r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_CUBE_MAP_POSITIVE_X+e,i,0);const t=r.checkFramebufferStatus(r.FRAMEBUFFER);if(t!==r.FRAMEBUFFER_COMPLETE){console.error("Framebuffer not complete:",t);continue}const n=r.getUniformLocation(s,"view");console.log("viewLocation",n),r.uniformMatrix4fv(r.getUniformLocation(s,"view"),!1,_[e]),r.viewport(0,0,o,o),r.clear(r.COLOR_BUFFER_BIT|r.DEPTH_BUFFER_BIT),r.drawArrays(r.TRIANGLE_STRIP,0,4)}return r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteFramebuffer(E),r.deleteTexture(a),r.bindTexture(r.TEXTURE_CUBE_MAP,i),r.generateMipmap(r.TEXTURE_CUBE_MAP),console.log("hdrToCube end"),i}function pe(e){let r,t,n,o;return n=new v({}),{c(){r=U("canvas"),t=P(),M(n.$$.fragment)},m(a,i){b(a,r,i),e[1](r),b(a,t,i),w(n,a,i),o=!0},p:x,i(e){o||(y(n.$$.fragment,e),o=!0)},o(e){C(n.$$.fragment,e),o=!1},d(o){o&&(S(r),S(t)),e[1](null),F(n,o)}}}function _e(){}function de(e,t,n){let o,a,i,s,c,E,u,f;return I(e,r,(e=>n(3,o=e))),I(e,X,(e=>n(4,a=e))),I(e,B,(e=>n(5,i=e))),I(e,D,(e=>n(6,s=e))),I(e,G,(e=>n(7,c=e))),I(e,O,(e=>n(8,E=e))),L((async()=>{N(r,o={...o,canvas:u,backgroundColor:H,ambientLightColor:[16777215,.1]},o),N(O,E={...E,position:[0,2,-5],target:[0,0,0],fov:75},E),f=await Ee("christmas_photo_studio_01_2k.hdr");const e=Te({exposure:3});const t=await ee({typedArray:f.data,convertToCube:me,width:f.width,height:f.height,cubeSize:2048,toneMapping:e});N(G,c=[t],c);const n=q(),T=V(k({position:[-2,2,-2],color:[1,1,1],intensity:20,cutoffDistance:0,decayExponent:2})),m=$(l()),p=Y({diffuse:[1,0,0],metalness:0,program:K()}),_=Z({...n,matrix:m,material:p}),d=Y({diffuse:[1,.5,.5],metalness:0});N(D,s=[...s,d,p],s),N(B,i=[...i,j({...n,matrix:m,material:d}),j(_)],i),N(X,a=[...a,T],a),N(r,o={...o,loop:_e,enabled:!0},o),z(u,O)})),[u,function(e){W[e?"unshift":"push"]((()=>{u=e,n(0,u)}))}]}class ge extends A{constructor(e){super(),h(this,e,de,pe,R,{})}}export{ge as default};
