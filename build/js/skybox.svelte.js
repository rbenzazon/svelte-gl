import{aa as r,V as e,ay as n,X as t,T as o,z as a,Y as i,Z as c,$ as s,a0 as f,a1 as l,q as u,P as E,az as m,R as p,L as T,S as g,i as d,s as v,M as _,e as x,a as R,c as A,b as h,m as M,n as U,t as b,d as P,f as L,g as I,h as F,o as C,r as w,l as D,j as y,k as X,p as B,A as S,B as O,C as G,D as z,y as H,E as N,F as V,G as W,H as k}from"./Menu-BvECENcu.js";import{c as $}from"./skybox-CefWEENh.js";import{c as Y}from"./cube-Bvveh-LG.js";import{c as q,a as j}from"./debug-program-DMSf4kdG.js";const K=1016,Z=1015;async function J(r){const e=await fetch(r);return function(r){const e=K,n=1,t=2,o=3,a=4,i=1,c=2,s=4,f="\n",l=new Uint8Array(r);l.pos=0;const u=_(l),E=u.width,m=u.height,p=x(l.subarray(l.pos),E,m);let T,g;switch(e){case Z:g=p.length/4;const r=new Float32Array(4*g);for(let e=0;e<g;e++)R(p,4*e,r,4*e);T=r;break;case K:g=p.length/4;const n=new Uint16Array(4*g);for(let r=0;r<g;r++)A(p,4*r,n,4*r);T=n;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+e)}return{width:E,height:m,data:T,header:u.string,gamma:u.gamma,exposure:u.exposure,type:e};function d(r,e){switch(r){case n:throw new Error("THREE.RGBELoader: Read Error: "+(e||""));case t:throw new Error("THREE.RGBELoader: Write Error: "+(e||""));case o:throw new Error("THREE.RGBELoader: Bad File Format: "+(e||""));default:throw new Error("THREE.RGBELoader: Memory Error: "+(e||""))}}function v(r,e,n){const t=128;e=e||1024;let o=r.pos,a=-1,i=0,c="",s=String.fromCharCode.apply(null,new Uint16Array(r.subarray(o,o+t)));for(;0>(a=s.indexOf(f))&&i<e&&o<r.byteLength;)c+=s,i+=s.length,o+=t,s+=String.fromCharCode.apply(null,new Uint16Array(r.subarray(o,o+t)));return-1<a&&(r.pos+=i+a+1,c+s.slice(0,a))}function _(r){const e=/^#\?(\S+)/,t=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,f=/^\s*FORMAT=(\S+)\s*$/,l=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,u={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let E,m;for((r.pos>=r.byteLength||!(E=v(r)))&&d(n,"no header found"),(m=E.match(e))||d(o,"bad initial token"),u.valid|=i,u.programtype=m[1],u.string+=E+"\n";E=v(r),!1!==E;)if(u.string+=E+"\n","#"!==E.charAt(0)){if((m=E.match(t))&&(u.gamma=parseFloat(m[1])),(m=E.match(a))&&(u.exposure=parseFloat(m[1])),(m=E.match(f))&&(u.valid|=c,u.format=m[1]),(m=E.match(l))&&(u.valid|=s,u.height=parseInt(m[1],10),u.width=parseInt(m[2],10)),u.valid&c&&u.valid&s)break}else u.comments+=E+"\n";return u.valid&c||d(o,"missing format specifier"),u.valid&s||d(o,"missing image size specifier"),u}function x(r,e,t){const i=e;if(i<8||i>32767||2!==r[0]||2!==r[1]||128&r[2])return new Uint8Array(r);i!==(r[2]<<8|r[3])&&d(o,"wrong scanline width");const c=new Uint8Array(4*e*t);c.length||d(a,"unable to allocate buffer space");let s=0,f=0;const l=4*i,u=new Uint8Array(4),E=new Uint8Array(l);let m=t;for(;m>0&&f<r.byteLength;){f+4>r.byteLength&&d(n),u[0]=r[f++],u[1]=r[f++],u[2]=r[f++],u[3]=r[f++],2==u[0]&&2==u[1]&&(u[2]<<8|u[3])==i||d(o,"bad rgbe scanline format");let e,t=0;for(;t<l&&f<r.byteLength;){e=r[f++];const n=e>128;if(n&&(e-=128),(0===e||t+e>l)&&d(o,"bad scanline data"),n){const n=r[f++];for(let r=0;r<e;r++)E[t++]=n}else E.set(r.subarray(f,f+e),t),t+=e,f+=e}const a=i;for(let r=0;r<a;r++){let e=0;c[s]=E[r+e],e+=i,c[s+1]=E[r+e],e+=i,c[s+2]=E[r+e],e+=i,c[s+3]=E[r+e],s+=4}m--}return c}function R(r,e,n,t){const o=r[e+3],a=Math.pow(2,o-128)/255;n[t+0]=r[e+0]*a,n[t+1]=r[e+1]*a,n[t+2]=r[e+2]*a,n[t+3]=1}function A(r,e,n,t){const o=r[e+3],a=Math.pow(2,o-128)/255;n[t+0]=Q(Math.min(r[e+0]*a,65504)),n[t+1]=Q(Math.min(r[e+1]*a,65504)),n[t+2]=Q(Math.min(r[e+2]*a,65504)),n[t+3]=Q(1)}}(await e.arrayBuffer())}function Q(r){var e,n,t;Math.abs(r)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),e=r,n=-65504,t=65504,r=Math.max(n,Math.min(t,e)),rr.floatView[0]=r;const o=rr.uint32View[0],a=o>>23&511;return rr.baseTable[a]+((8388607&o)>>rr.shiftTable[a])}const rr=er();function er(){const r=new ArrayBuffer(4),e=new Float32Array(r),n=new Uint32Array(r),t=new Uint32Array(512),o=new Uint32Array(512);for(let r=0;r<256;++r){const e=r-127;e<-27?(t[r]=0,t[256|r]=32768,o[r]=24,o[256|r]=24):e<-14?(t[r]=1024>>-e-14,t[256|r]=1024>>-e-14|32768,o[r]=-e-1,o[256|r]=-e-1):e<=15?(t[r]=e+15<<10,t[256|r]=e+15<<10|32768,o[r]=13,o[256|r]=13):e<128?(t[r]=31744,t[256|r]=64512,o[r]=24,o[256|r]=24):(t[r]=31744,t[256|r]=64512,o[r]=13,o[256|r]=13)}const a=new Uint32Array(2048),i=new Uint32Array(64),c=new Uint32Array(64);for(let r=1;r<1024;++r){let e=r<<13,n=0;for(;!(8388608&e);)e<<=1,n-=8388608;e&=-8388609,n+=947912704,a[r]=e|n}for(let r=1024;r<2048;++r)a[r]=939524096+(r-1024<<13);for(let r=1;r<31;++r)i[r]=r<<23;i[31]=1199570944,i[32]=2147483648;for(let r=33;r<63;++r)i[r]=2147483648+(r-32<<23);i[63]=3347054592;for(let r=1;r<64;++r)32!==r&&(c[r]=1024);return{floatView:e,uint32View:n,baseTable:t,shiftTable:o,mantissaTable:a,exponentTable:i,offsetTable:c}}const nr=e=>({exposure:`${e.exposure.toLocaleString("en",{minimumFractionDigits:1})}f`,shader:r("${declaration?\r\n`\r\n// tone mapping taken from three.js\r\nfloat toneMappingExposure = ${exposure};\r\n\r\n    // Matrices for rec 2020 <> rec 709 color space conversion\r\n    // matrix provided in row-major order so it has been transposed\r\n    // https://www.itu.int/pub/R-REP-BT.2407-2017\r\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(vec3(1.6605f, -0.1246f, -0.0182f), vec3(-0.5876f, 1.1329f, -0.1006f), vec3(-0.0728f, -0.0083f, 1.1187f));\r\n\r\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(vec3(0.6274f, 0.0691f, 0.0164f), vec3(0.3293f, 0.9195f, 0.0880f), vec3(0.0433f, 0.0113f, 0.8956f));\r\n\r\n    // https://iolite-engine.com/blog_posts/minimal_agx_implementation\r\n    // Mean error^2: 3.6705141e-06\r\nvec3 agxDefaultContrastApprox(vec3 x) {\r\n\r\n    vec3 x2 = x * x;\r\n    vec3 x4 = x2 * x2;\r\n\r\n    return +15.5f * x4 * x2 - 40.14f * x4 * x + 31.96f * x4 - 6.868f * x2 * x + 0.4298f * x2 + 0.1191f * x - 0.00232f;\r\n\r\n}\r\n\r\nvec3 AgXToneMapping(vec3 color) {\r\n\r\n        // AgX constants\r\n    const mat3 AgXInsetMatrix = mat3(vec3(0.856627153315983f, 0.137318972929847f, 0.11189821299995f), vec3(0.0951212405381588f, 0.761241990602591f, 0.0767994186031903f), vec3(0.0482516061458583f, 0.101439036467562f, 0.811302368396859f));\r\n\r\n        // explicit AgXOutsetMatrix generated from Filaments AgXOutsetMatrixInv\r\n    const mat3 AgXOutsetMatrix = mat3(vec3(1.1271005818144368f, -0.1413297634984383f, -0.14132976349843826f), vec3(-0.11060664309660323f, 1.157823702216272f, -0.11060664309660294f), vec3(-0.016493938717834573f, -0.016493938717834257f, 1.2519364065950405f));\r\n\r\n        // LOG2_MIN      = -10.0\r\n        // LOG2_MAX      =  +6.5\r\n        // MIDDLE_GRAY   =  0.18\r\n    const float AgxMinEv = -12.47393f;  // log2( pow( 2, LOG2_MIN ) * MIDDLE_GRAY )\r\n    const float AgxMaxEv = 4.026069f;    // log2( pow( 2, LOG2_MAX ) * MIDDLE_GRAY )\r\n\r\n    color *= toneMappingExposure;\r\n\r\n    color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\r\n\r\n    color = AgXInsetMatrix * color;\r\n\r\n        // Log2 encoding\r\n    color = max(color, 1e-10f); // avoid 0 or negative numbers for log2\r\n    color = log2(color);\r\n    color = (color - AgxMinEv) / (AgxMaxEv - AgxMinEv);\r\n\r\n    color = clamp(color, 0.0f, 1.0f);\r\n\r\n        // Apply sigmoid\r\n    color = agxDefaultContrastApprox(color);\r\n\r\n        // Apply AgX look\r\n        // v = agxLook(v, look);\r\n\r\n    color = AgXOutsetMatrix * color;\r\n\r\n        // Linearize\r\n    color = pow(max(vec3(0.0f), color), vec3(2.2f));\r\n\r\n    color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\r\n\r\n        // Gamut mapping. Simple clamp for now.\r\n    color = clamp(color, 0.0f, 1.0f);\r\n\r\n    return color;\r\n\r\n}\r\nvec4 sRGBTransferOETF( in vec4 value ) {\r\n    return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\r\n}\r\n` : ''\r\n}\r\n${color?\r\n`\r\n    fragColor = vec4(AgXToneMapping(fragColor.xyz),1.0f);\r\n    fragColor = sRGBTransferOETF(fragColor);\r\n` : ''\r\n}",{declaration:!1,exposure:1,color:!1})});function tr(r,i,c,s,f=1024){if(!i.getExtension("EXT_color_buffer_float"))throw new Error("EXT_color_buffer_float extension not supported");const l=function(r,e,n,t){const o=r.createTexture();return r.bindTexture(r.TEXTURE_2D,o),r.texImage2D(r.TEXTURE_2D,0,r.RGBA16F,n,t,0,r.RGBA,r.HALF_FLOAT,e),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.LINEAR),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.LINEAR),o}(i,r,c,s),u=function(r,e){const n=r.createTexture();r.bindTexture(r.TEXTURE_CUBE_MAP,n);for(let n=0;n<6;n++)r.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+n,0,r.RGBA16F,e,e,0,r.RGBA,r.HALF_FLOAT,null);return r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_WRAP_R,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_MIN_FILTER,r.LINEAR_MIPMAP_LINEAR),r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_MAG_FILTER,r.LINEAR),n}(i,f),{program:E,vertexArray:m}=function(r){const e="#version 300 es\n\n    #define SHADER_NAME hdrToCubeVertex\n\n    layout(location = 0) in vec2 position;\n    out vec3 localPos;\n    uniform mat4 projection;\n    uniform mat4 view;\n\n    void main() {\n        // Use the quad positions directly for rendering\n        gl_Position = vec4(position, 0.0, 1.0);\n        \n        // Create the ray direction for this fragment\n        // Map from [-1,1] to [-1,1] in view space for proper cubemap sampling\n        vec4 viewPos = inverse(projection * view) * vec4(position, 1.0, 1.0);\n        localPos = viewPos.xyz / viewPos.w;\n    }",n="#version 300 es\n\n    #define SHADER_NAME hdrToCubeFragment\n\n    precision highp float;\n    in vec3 localPos;\n    out vec4 fragColor;\n    uniform sampler2D equirectangularMap;\n\n    vec2 SampleSphericalMap(vec3 v) {\n        // Convert direction vector to spherical coordinates\n        float phi = atan(v.z, v.x);\n        float theta = asin(v.y);\n        \n        // Map from [-π to π] for phi and [-π/2 to π/2] for theta to [0,1] range\n        vec2 uv = vec2(\n            0.5 + 0.5 * phi / 3.1415926535897932,\n            0.5 - theta / 3.1415926535897932\n        );\n        \n        return uv;\n    }\n\n    void main() {\n        vec3 direction = normalize(localPos);\n        vec2 uv = SampleSphericalMap(direction);\n        fragColor = texture(equirectangularMap, uv);\n    }",t=r.createProgram();if(o(r,t,e,n),r.linkProgram(t),!r.getProgramParameter(t,r.LINK_STATUS))throw console.error("Shader program error:",r.getProgramInfoLog(t)),new Error("Failed to compile shaders");const a=r.createVertexArray();r.bindVertexArray(a);const i=new Float32Array([-1,-1,1,-1,-1,1,1,1]),c=r.createBuffer();return r.bindBuffer(r.ARRAY_BUFFER,c),r.bufferData(r.ARRAY_BUFFER,i,r.STATIC_DRAW),r.enableVertexAttribArray(0),r.vertexAttribPointer(0,2,r.FLOAT,!1,0,0),{program:t,vertexArray:a}}(i),p=i.createFramebuffer();i.bindFramebuffer(i.FRAMEBUFFER,p),i.useProgram(E),i.bindVertexArray(m),i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,l),i.uniform1i(i.getUniformLocation(E,"equirectangularMap"),0);const T=a(),g=Math.PI/2,d=1/Math.tan(g/2);T[0]=d/1,T[5]=d,T[10]=10.1/-9.9,T[11]=-1,T[14]=2/-9.9;const v=i.getUniformLocation(E,"projection");i.uniformMatrix4fv(v,!1,T);const _=[],x=e();for(let r=0;r<6;r++){const e=n();let o,a;switch(r){case 0:o=[1,0,0],a=[0,-1,0];break;case 1:o=[-1,0,0],a=[0,-1,0];break;case 2:o=[0,1,0],a=[0,0,1];break;case 3:o=[0,-1,0],a=[0,0,-1];break;case 4:o=[0,0,1],a=[0,-1,0];break;case 5:o=[0,0,-1],a=[0,-1,0]}const i=[x[0]+o[0],x[1]+o[1],x[2]+o[2]];t(e,x,i,a),_.push(e)}for(let r=0;r<6;r++){i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_CUBE_MAP_POSITIVE_X+r,u,0);const e=i.checkFramebufferStatus(i.FRAMEBUFFER);e===i.FRAMEBUFFER_COMPLETE?(i.uniformMatrix4fv(i.getUniformLocation(E,"view"),!1,_[r]),i.viewport(0,0,f,f),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT),i.drawArrays(i.TRIANGLE_STRIP,0,4)):console.error("Framebuffer not complete:",e)}return i.bindFramebuffer(i.FRAMEBUFFER,null),i.deleteFramebuffer(p),i.deleteTexture(l),i.bindTexture(i.TEXTURE_CUBE_MAP,u),i.generateMipmap(i.TEXTURE_CUBE_MAP),u}var or="#version 300 es\r\n\r\nprecision mediump float;\r\nprecision mediump int;\r\n\r\nin vec3 position;\r\nin vec2 uv;\r\nin float faceIndex;\r\n\r\nout vec3 vOutputDirection;\r\n\r\n// RH coordinate system; PMREM face-indexing convention\r\nvec3 getDirection(vec2 uv, float face) {\r\n\r\n    uv = 2.0 * uv - 1.0;\r\n\r\n    vec3 direction = vec3(uv, 1.0);\r\n\r\n    if(face == 0.0) {\r\n        // 0 0 0\r\n        // X 0 0\r\n        direction = direction.zyx; // ( 1, v, u ) pos x\r\n\r\n    } else if(face == 1.0) {\r\n        //0 0 0\r\n        //0 X 0\r\n        direction = direction.xzy;\r\n        direction.xz *= -1.0; // ( -u, 1, -v ) pos y\r\n\r\n    } else if(face == 2.0) {\r\n        //0 0 0\r\n        //0 0 X\r\n        direction.x *= -1.0; // ( -u, v, 1 ) pos z\r\n\r\n    } else if(face == 3.0) {\r\n        // X 0 0\r\n        // 0 0 0\r\n        direction = direction.zyx;\r\n        direction.xz *= -1.0; // ( -1, v, -u ) neg x\r\n\r\n    } else if(face == 4.0) {\r\n        //0 X 0\r\n        //0 0 0\r\n        direction = direction.xzy;\r\n        direction.xy *= -1.0; // ( -u, -1, v ) neg y\r\n\r\n    } else if(face == 5.0) {\r\n        //0 0 X\r\n        //0 0 0\r\n        direction.z *= -1.0; // ( u, v, -1 ) neg z\r\n    }\r\n\r\n    return direction;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n    vOutputDirection = getDirection(uv, faceIndex);\r\n    gl_Position = vec4(position, 1.0);\r\n\r\n}",ar="#version 300 es\r\n\r\nprecision mediump float;\r\nprecision mediump int;\r\n\r\n#define n 20\r\n#define CUBEUV_TEXEL_WIDTH ${CUBEUV_TEXEL_WIDTH}\r\n#define CUBEUV_TEXEL_HEIGHT ${CUBEUV_TEXEL_HEIGHT}\r\n#define CUBEUV_MAX_MIP ${CUBEUV_MAX_MIP}\r\n#define cubeUV_minMipLevel 4.0\r\n#define cubeUV_minTileSize 16.0\r\n\r\nin vec3 vOutputDirection;\r\n\r\nuniform sampler2D envMap;\r\n\r\nuniform int samples;\r\nuniform float weights[n];\r\nuniform bool latitudinal;\r\nuniform float dTheta;\r\nuniform float mipInt;\r\nuniform vec3 poleAxis;\r\n\r\nout vec4 fragColor;\r\n\r\nfloat getFace(vec3 direction) {\r\n    vec3 absDirection = abs(direction);\r\n    float face = -1.0;\r\n    if(absDirection.x > absDirection.z) {\r\n        if(absDirection.x > absDirection.y)\r\n            face = direction.x > 0.0 ? 0.0 : 3.0;\r\n        else\r\n            face = direction.y > 0.0 ? 1.0 : 4.0;\r\n    } else {\r\n        if(absDirection.z > absDirection.y)\r\n            face = direction.z > 0.0 ? 2.0 : 5.0;\r\n        else\r\n            face = direction.y > 0.0 ? 1.0 : 4.0;\r\n    }\r\n    return face;\r\n}\r\n\r\n// RH coordinate system; PMREM face-indexing convention\r\nvec2 getUV( vec3 direction, float face ) {\r\n    vec2 uv;\r\n    if ( face == 0.0 ) {\r\n        uv = vec2( direction.z, direction.y ) / abs( direction.x );\r\n    }\r\n    else if ( face == 1.0 ) {\r\n        uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\r\n    }\r\n    else if ( face == 2.0 ) {\r\n        uv = vec2( - direction.x, direction.y ) / abs( direction.z );\r\n    }\r\n    else if ( face == 3.0 ) {\r\n        uv = vec2( - direction.z, direction.y ) / abs( direction.x );\r\n    }\r\n    else if ( face == 4.0 ) {\r\n        uv = vec2( - direction.x, direction.z ) / abs( direction.y );\r\n    }\r\n    else {\r\n        uv = vec2( direction.x, direction.y ) / abs( direction.z );\r\n    }\r\n    return 0.5 * ( uv + 1.0 );\r\n}\r\n\r\nvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\r\n    float face = getFace( direction );\r\n    float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\r\n    mipInt = max( mipInt, cubeUV_minMipLevel );\r\n    float faceSize = exp2( mipInt );\r\n    highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\r\n    if ( face > 2.0 ) {\r\n        uv.y += faceSize;\r\n        face -= 3.0;\r\n    }\r\n    uv.x += face * faceSize;\r\n    uv.x += filterInt * 3.0 * cubeUV_minTileSize;\r\n    uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\r\n    uv.x *= CUBEUV_TEXEL_WIDTH;\r\n    uv.y *= CUBEUV_TEXEL_HEIGHT;\r\n    //return texture( envMap, uv).rgb;\r\n    return textureGrad( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\r\n}\r\n\r\nvec3 getSample(float theta, vec3 axis) {\r\n    float cosTheta = cos(theta);\r\n    // Rodrigues' axis-angle rotation\r\n    vec3 sampleDirection = vOutputDirection * cosTheta\r\n    + cross(axis, vOutputDirection) * sin(theta)\r\n    + axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\r\n    return bilinearCubeUV(envMap, sampleDirection, mipInt);\r\n}\r\n\r\nvoid main() {\r\n\r\n    vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\r\n    if(all(equal(axis, vec3(0.0)))) {\r\n        axis = vec3(vOutputDirection.z, 0.0, -vOutputDirection.x);\r\n    }\r\n\r\n    axis = normalize(axis);\r\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n    //fragColor = vec4(mipInt/10.0, mipInt/10.0, mipInt/10.0, 1.0f);\r\n    //fragColor = vec4(dTheta*40.0, dTheta*40.0, dTheta*40.0, 1.0f);\r\n    //fragColor.rgb = dTheta;\r\n    //fragColor.rgb += texture(envMap, vOutputDirection.xy).rgb;\r\n    fragColor.rgb += weights[0] * getSample(0.0, axis);\r\n    for(int i = 1; i < n; i++) {\r\n        if(i >= samples) {\r\n            break;\r\n        }\r\n        float theta = dTheta * float(i);\r\n        fragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\r\n        fragColor.rgb += weights[i] * getSample(theta, axis);\r\n    }\r\n}",ir="#version 300 es\r\n\r\nprecision highp float;\r\nprecision highp int;\r\nprecision highp sampler2D;\r\n\r\n#define RECIPROCAL_PI 0.3183098861837907\r\n#define RECIPROCAL_PI2 0.15915494309189535\r\n\r\nuniform float flipEnvMap;\r\n\r\nin vec3 vOutputDirection;\r\n\r\nuniform sampler2D envMap;\r\n\r\nout highp vec4 fragColor;\r\n\r\nvec2 equirectUv( in vec3 dir ) {\r\n    float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\r\n    float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n    return vec2( u, v );\r\n}\r\n\r\nvoid main() {\r\n    vec3 outputDirection = normalize( vOutputDirection );\r\n    vec2 uv = equirectUv( outputDirection );\r\n    fragColor = vec4( texture ( envMap, uv ).rgb, 1.0 );\r\n}";const cr=4,sr=[.125,.215,.35,.446,.526,.582],fr=20,lr=(1+Math.sqrt(5))/2,ur=1/lr,Er=[[-lr,ur,0],[lr,ur,0],[-ur,0,lr],[ur,0,lr],[0,lr,-ur],[0,lr,ur],[-1,1,-1],[1,1,-1],[-1,1,1],[1,1,1]];function mr(r){let e={};e.image=r,e.cubeImageSize=r.width/4,e.lodMax=Math.floor(Math.log2(e.cubeImageSize)),e.cubeSize=Math.pow(2,e.lodMax),e.renderTargetWidth=3*Math.max(e.cubeSize,112),e.renderTargetHeight=4*e.cubeSize,function(r){const e=[],n=[],t=[];let o=r.lodMax;const a=r.lodMax-cr+1+sr.length;for(let i=0;i<a;i++){const a=Math.pow(2,o);n.push(a);let c=1/a;i>r.lodMax-cr?c=sr[i-r.lodMax+cr-1]:0===i&&(c=0),t.push(c);const s=1/(a-2),f=-s,l=1+s,u=[f,f,l,f,l,l,f,f,l,l,f,l],E=6,m=6,p=3,g=2,d=1,v=new Float32Array(p*m*E),_=new Float32Array(g*m*E),x=new Float32Array(d*m*E);for(let r=0;r<E;r++){const e=r%3*2/3-1,n=r>2?0:-1,t=[e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0];v.set(t,p*m*r),_.set(u,g*m*r);const o=[r,r,r,r,r,r];x.set(o,d*m*r)}const R={attributes:{positions:v,uvs:_,faceIndex:{array:x,itemSize:d}},drawMode:T[4],lodPlaneID:e.length};e.push(R),o>cr&&o--}r.lodPlanes=e,r.sizeLods=n,r.sigmas=t}(e);const n={n:fr,CUBEUV_TEXEL_WIDTH:1/e.renderTargetWidth,CUBEUV_TEXEL_HEIGHT:1/e.renderTargetHeight,CUBEUV_MAX_MIP:`${e.lodMax}.0`};let t,o,a,l,u;function E(){return o}function m(){return a}function p(r){l=r}function g(){return l}function d(r){u=r}function v(){return u}return{programs:[{createProgram:vr(e,r,(function(r){t=r})),setupProgram:[_r,i,c,Rr(e,(function(r){a=r}),(function(r){o=r}))],useProgram:s,selectProgram:f,setupMaterial:[Ar,hr((function(){return t}))],setupCamera:()=>()=>{},setFrameBuffer:Mr(m,e,gr,!0),meshes:[e.lodPlanes[0]]},...new Array(2*(e.lodPlanes.length-1)).fill(0).map(((r,t)=>{const o=Math.floor(t/2)+1,a=t%2==0,l=a?"latitudinal":"longitudinal",u=a?v:m,T=a?E:g,_=Math.sqrt(e.sigmas[o]*e.sigmas[o]-e.sigmas[o-1]*e.sigmas[o-1]),x=Er[(e.lodPlanes.length-o-1)%Er.length],R=a?o-1:o,A=o,h=e.sizeLods[R]-1,M=isFinite(_)?Math.PI/(2*h):2*Math.PI/(2*fr-1),U=_/M,b=isFinite(_)?1+Math.floor(3*U):fr,P=[];let L=0;for(let r=0;r<fr;++r){const e=r/U,n=Math.exp(-e*e/2);P.push(n),0===r?L+=n:r<b&&(L+=2*n)}for(let r=0;r<P.length;r++)P[r]=P[r]/L;const I=e.sizeLods[A],F=3*I*(A>e.lodMax-cr?A-e.lodMax+cr:0),C=4*(e.cubeSize-I),w=3*I,D=2*I;return{createProgram:Ur(0!==t),setupProgram:[...0===t?[xr(n),i,c,Rr(e,d,p)]:[]],setupMaterial:[],useProgram:s,selectProgram:f,setupCamera:()=>()=>{},setFrameBuffer:Mr(u,e,dr(F,C,w,D)),updateProgram:[hr(T),Tr(b,P,"latitudinal"===l,x,M,e.lodMax-R)],meshes:[e.lodPlanes[o]],...t===2*(e.lodPlanes.length-1)-1?{postDraw:pr}:{}}}))],getTexture:E,order:-1,type:"environmentMap"}}function pr(){!function(){const{gl:r}=p;r.enable(r.DEPTH_TEST),r.depthMask(!0)}(),function(){const{gl:r}=p;r.disable(r.SCISSOR_TEST)}(),function(){const{gl:r}=p;r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,!1)}(),l(),u.set(E(u).filter((r=>"environmentMap"!==r.type)))}function Tr(r,e,n,t,o,a){return function(){const{gl:i,program:c}=p,s=i.getUniformLocation(c,"samples");i.uniform1i(s,r);const f=i.getUniformLocation(c,"weights");i.uniform1fv(f,e);const l=i.getUniformLocation(c,"latitudinal");if(i.uniform1i(l,n?1:0),t){const r=i.getUniformLocation(c,"poleAxis");i.uniform3fv(r,t)}const u=i.getUniformLocation(c,"dTheta");i.uniform1f(u,o);const E=i.getUniformLocation(c,"mipInt");i.uniform1f(E,a)}}function gr(r){const e=r.cubeSize;return{x:0,y:0,width:3*e,height:2*e}}function dr(r,e,n,t){return function(){return{x:r,y:e,width:n,height:t}}}function vr(r,e,n){return function(r){return function(){!function(r,e){const{gl:n}=p;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,!0),n.pixelStorei(n.UNPACK_ALIGNMENT,1),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1);const t=n.createTexture();e(t),n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,n.RGBA16F,r.width,r.height,0,n.RGBA,n.HALF_FLOAT,r.data),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,!0),n.pixelStorei(n.UNPACK_ALIGNMENT,1),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),n.bindTexture(n.TEXTURE_2D,null)}(e,n),m(r)(),function(){const{gl:r}=p;r.disable(r.DEPTH_TEST),r.depthMask(!1)}(),function(){const{gl:r}=p;r.enable(r.SCISSOR_TEST)}()}}}function _r(){const{gl:r,program:e}=p;o(r,e,or,ir)}function xr(e){return function(){const{gl:n,program:t}=p,a=r(ar,e)(e);o(n,t,or,a)}}function Rr(r,e,n){return function(){const{gl:t}=p,{renderTargetWidth:o,renderTargetHeight:a}=r,i=t.createTexture();n(i),t.bindTexture(t.TEXTURE_2D,i),t.texImage2D(t.TEXTURE_2D,0,t.RGBA16F,o,a,0,t.RGBA,t.HALF_FLOAT,null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR);const c=t.createFramebuffer();e(c),t.bindFramebuffer(t.FRAMEBUFFER,c),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,i,0),t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null)}}function Ar(){return function(){const{gl:r,program:e}=p,n=r.getUniformLocation(e,"flipEnvMap");r.uniform1f(n,-1)}}function hr(r){return function(){const{gl:e,program:n}=p,t=e.getUniformLocation(n,"envMap");e.uniform1i(t,0),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,r())}}function Mr(r=null,e,n,t=!1){return function(){const{gl:o}=p,a=r?r():null,{renderTargetWidth:i,renderTargetHeight:c}=e;if(o.bindFramebuffer(o.FRAMEBUFFER,a),p.fbo!==a&&null!=a){const{x:r,y:a,width:s,height:f}=n(e);o.viewport(r,a,s,f),o.scissor(r,a,s,f),p.frameBufferWidth=i,p.frameBufferHeight=c,t&&(o.clearColor(0,0,0,0),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT|o.STENCIL_BUFFER_BIT))}p.fbo=a}}function Ur(r=!1){return function(e){return function(){const{gl:n,programMap:t,vaoMap:o}=p;if(t.has(e)||r)r?(t.set(e,p.program),o.set(e,new Map)):p.program=p.programMap.get(e);else{const r=n.createProgram();t.set(e,r),o.set(e,new Map),p.program=r}}}}function br(r){let e,n,t,o;return t=new _({}),{c(){e=x("canvas"),n=R(),A(t.$$.fragment)},m(a,i){h(a,e,i),r[1](e),h(a,n,i),M(t,a,i),o=!0},p:U,i(r){o||(b(t.$$.fragment,r),o=!0)},o(r){P(t.$$.fragment,r),o=!1},d(o){o&&(L(e),L(n)),r[1](null),I(t,o)}}}function Pr(){}function Lr(r,e,n){let t,o,i,c,s,f,l,E;return F(r,w,(r=>n(3,t=r))),F(r,D,(r=>n(4,o=r))),F(r,y,(r=>n(5,i=r))),F(r,X,(r=>n(6,c=r))),F(r,u,(r=>n(7,s=r))),F(r,B,(r=>n(8,f=r))),C((async()=>{S(w,t={...t,canvas:l,backgroundColor:O,ambientLightColor:[16777215,.1]},t),S(B,f={...f,position:[-4.5,.8,-2.5],target:[0,0,0],fov:75},f),E=await J("christmas_photo_studio_01_4k.hdr");const r=nr({exposure:1.5});const e=await $({typedArray:E.data,convertToCube:tr,width:E.width,height:E.height,cubeSize:2048,toneMapping:r}),n=mr(E);console.log("environmentMap",n),S(u,s=[e,n],s);const m=Y(),p=G(z({position:[-2,2,2],color:[1,1,1],intensity:20,cutoffDistance:0,decayExponent:2})),T=H(a()),g=k({diffuse:[1,0,0],metalness:0,program:j()}),d=q({...m,matrix:T,material:g}),v=k({diffuse:[1,.5,.5],metalness:0});S(X,c=[...c,v,g],c),S(y,i=[...i,N({...m,matrix:T,material:v}),N(d)],i),S(D,o=[...o,p],o),S(w,t={...t,loop:Pr,enabled:!0},t),V(l,B)})),[l,function(r){W[r?"unshift":"push"]((()=>{l=r,n(0,l)}))}]}class Ir extends g{constructor(r){super(),d(this,r,Lr,br,v,{})}}export{Ir as default};
