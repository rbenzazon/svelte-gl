import{a7 as r,U as e,av as n,W as t,z as a,S as o,i,s,M as c,e as f,a as l,c as E,b as u,m,n as p,t as g,d as T,f as A,g as _,h as R,o as d,r as h,l as v,j as x,k as M,q as b,p as w,A as U,B as L,C as y,D as F,y as P,E as I,F as X,G as B,H as C}from"./Menu-BeccOEjd.js";import{c as S}from"./skybox-DkcOsqvo.js";import{c as D}from"./cube-CIxgEHM0.js";import{c as G,a as O}from"./debug-program-Bwhl8KtH.js";const N=1016,k=1015;async function H(r){const e=await fetch(r);return function(r){const e=N,n=1,t=2,a=3,o=4,i=1,s=2,c=4,f="\n",l=new Uint8Array(r);l.pos=0;const E=R(l),u=E.width,m=E.height,p=d(l.subarray(l.pos),u,m);let g,T;switch(e){case k:T=p.length/4;const r=new Float32Array(4*T);for(let e=0;e<T;e++)h(p,4*e,r,4*e);g=r;break;case N:T=p.length/4;const n=new Uint16Array(4*T);for(let r=0;r<T;r++)v(p,4*r,n,4*r);g=n;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+e)}return{width:u,height:m,data:g,header:E.string,gamma:E.gamma,exposure:E.exposure,type:e};function A(r,e){switch(r){case n:throw new Error("THREE.RGBELoader: Read Error: "+(e||""));case t:throw new Error("THREE.RGBELoader: Write Error: "+(e||""));case a:throw new Error("THREE.RGBELoader: Bad File Format: "+(e||""));default:throw new Error("THREE.RGBELoader: Memory Error: "+(e||""))}}function _(r,e,n){const t=128;e=e||1024;let a=r.pos,o=-1,i=0,s="",c=String.fromCharCode.apply(null,new Uint16Array(r.subarray(a,a+t)));for(;0>(o=c.indexOf(f))&&i<e&&a<r.byteLength;)s+=c,i+=c.length,a+=t,c+=String.fromCharCode.apply(null,new Uint16Array(r.subarray(a,a+t)));return-1<o&&(r.pos+=i+o+1,s+c.slice(0,o))}function R(r){const e=/^#\?(\S+)/,t=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,o=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,f=/^\s*FORMAT=(\S+)\s*$/,l=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,E={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let u,m;for((r.pos>=r.byteLength||!(u=_(r)))&&A(n,"no header found"),(m=u.match(e))||A(a,"bad initial token"),E.valid|=i,E.programtype=m[1],E.string+=u+"\n";u=_(r),!1!==u;)if(E.string+=u+"\n","#"!==u.charAt(0)){if((m=u.match(t))&&(E.gamma=parseFloat(m[1])),(m=u.match(o))&&(E.exposure=parseFloat(m[1])),(m=u.match(f))&&(E.valid|=s,E.format=m[1]),(m=u.match(l))&&(E.valid|=c,E.height=parseInt(m[1],10),E.width=parseInt(m[2],10)),E.valid&s&&E.valid&c)break}else E.comments+=u+"\n";return E.valid&s||A(a,"missing format specifier"),E.valid&c||A(a,"missing image size specifier"),E}function d(r,e,t){const i=e;if(i<8||i>32767||2!==r[0]||2!==r[1]||128&r[2])return new Uint8Array(r);i!==(r[2]<<8|r[3])&&A(a,"wrong scanline width");const s=new Uint8Array(4*e*t);s.length||A(o,"unable to allocate buffer space");let c=0,f=0;const l=4*i,E=new Uint8Array(4),u=new Uint8Array(l);let m=t;for(;m>0&&f<r.byteLength;){f+4>r.byteLength&&A(n),E[0]=r[f++],E[1]=r[f++],E[2]=r[f++],E[3]=r[f++],2==E[0]&&2==E[1]&&(E[2]<<8|E[3])==i||A(a,"bad rgbe scanline format");let e,t=0;for(;t<l&&f<r.byteLength;){e=r[f++];const n=e>128;if(n&&(e-=128),(0===e||t+e>l)&&A(a,"bad scanline data"),n){const n=r[f++];for(let r=0;r<e;r++)u[t++]=n}else u.set(r.subarray(f,f+e),t),t+=e,f+=e}const o=i;for(let r=0;r<o;r++){let e=0;s[c]=u[r+e],e+=i,s[c+1]=u[r+e],e+=i,s[c+2]=u[r+e],e+=i,s[c+3]=u[r+e],c+=4}m--}return s}function h(r,e,n,t){const a=r[e+3],o=Math.pow(2,a-128)/255;n[t+0]=r[e+0]*o,n[t+1]=r[e+1]*o,n[t+2]=r[e+2]*o,n[t+3]=1}function v(r,e,n,t){const a=r[e+3],o=Math.pow(2,a-128)/255;n[t+0]=V(Math.min(r[e+0]*o,65504)),n[t+1]=V(Math.min(r[e+1]*o,65504)),n[t+2]=V(Math.min(r[e+2]*o,65504)),n[t+3]=V(1)}}(await e.arrayBuffer())}function V(r){var e,n,t;Math.abs(r)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),e=r,n=-65504,t=65504,r=Math.max(n,Math.min(t,e)),$.floatView[0]=r;const a=$.uint32View[0],o=a>>23&511;return $.baseTable[o]+((8388607&a)>>$.shiftTable[o])}const $=j();function j(){const r=new ArrayBuffer(4),e=new Float32Array(r),n=new Uint32Array(r),t=new Uint32Array(512),a=new Uint32Array(512);for(let r=0;r<256;++r){const e=r-127;e<-27?(t[r]=0,t[256|r]=32768,a[r]=24,a[256|r]=24):e<-14?(t[r]=1024>>-e-14,t[256|r]=1024>>-e-14|32768,a[r]=-e-1,a[256|r]=-e-1):e<=15?(t[r]=e+15<<10,t[256|r]=e+15<<10|32768,a[r]=13,a[256|r]=13):e<128?(t[r]=31744,t[256|r]=64512,a[r]=24,a[256|r]=24):(t[r]=31744,t[256|r]=64512,a[r]=13,a[256|r]=13)}const o=new Uint32Array(2048),i=new Uint32Array(64),s=new Uint32Array(64);for(let r=1;r<1024;++r){let e=r<<13,n=0;for(;!(8388608&e);)e<<=1,n-=8388608;e&=-8388609,n+=947912704,o[r]=e|n}for(let r=1024;r<2048;++r)o[r]=939524096+(r-1024<<13);for(let r=1;r<31;++r)i[r]=r<<23;i[31]=1199570944,i[32]=2147483648;for(let r=33;r<63;++r)i[r]=2147483648+(r-32<<23);i[63]=3347054592;for(let r=1;r<64;++r)32!==r&&(s[r]=1024);return{floatView:e,uint32View:n,baseTable:t,shiftTable:a,mantissaTable:o,exponentTable:i,offsetTable:s}}const z=e=>({exposure:`${e.exposure.toLocaleString("en",{minimumFractionDigits:1})}f`,shader:r("${declaration?\r\n`\r\n// tone mapping taken from three.js\r\nfloat toneMappingExposure = ${exposure};\r\n\r\n    // Matrices for rec 2020 <> rec 709 color space conversion\r\n    // matrix provided in row-major order so it has been transposed\r\n    // https://www.itu.int/pub/R-REP-BT.2407-2017\r\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(vec3(1.6605f, -0.1246f, -0.0182f), vec3(-0.5876f, 1.1329f, -0.1006f), vec3(-0.0728f, -0.0083f, 1.1187f));\r\n\r\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(vec3(0.6274f, 0.0691f, 0.0164f), vec3(0.3293f, 0.9195f, 0.0880f), vec3(0.0433f, 0.0113f, 0.8956f));\r\n\r\n    // https://iolite-engine.com/blog_posts/minimal_agx_implementation\r\n    // Mean error^2: 3.6705141e-06\r\nvec3 agxDefaultContrastApprox(vec3 x) {\r\n\r\n    vec3 x2 = x * x;\r\n    vec3 x4 = x2 * x2;\r\n\r\n    return +15.5f * x4 * x2 - 40.14f * x4 * x + 31.96f * x4 - 6.868f * x2 * x + 0.4298f * x2 + 0.1191f * x - 0.00232f;\r\n\r\n}\r\n\r\nvec3 AgXToneMapping(vec3 color) {\r\n\r\n        // AgX constants\r\n    const mat3 AgXInsetMatrix = mat3(vec3(0.856627153315983f, 0.137318972929847f, 0.11189821299995f), vec3(0.0951212405381588f, 0.761241990602591f, 0.0767994186031903f), vec3(0.0482516061458583f, 0.101439036467562f, 0.811302368396859f));\r\n\r\n        // explicit AgXOutsetMatrix generated from Filaments AgXOutsetMatrixInv\r\n    const mat3 AgXOutsetMatrix = mat3(vec3(1.1271005818144368f, -0.1413297634984383f, -0.14132976349843826f), vec3(-0.11060664309660323f, 1.157823702216272f, -0.11060664309660294f), vec3(-0.016493938717834573f, -0.016493938717834257f, 1.2519364065950405f));\r\n\r\n        // LOG2_MIN      = -10.0\r\n        // LOG2_MAX      =  +6.5\r\n        // MIDDLE_GRAY   =  0.18\r\n    const float AgxMinEv = -12.47393f;  // log2( pow( 2, LOG2_MIN ) * MIDDLE_GRAY )\r\n    const float AgxMaxEv = 4.026069f;    // log2( pow( 2, LOG2_MAX ) * MIDDLE_GRAY )\r\n\r\n    color *= toneMappingExposure;\r\n\r\n    color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\r\n\r\n    color = AgXInsetMatrix * color;\r\n\r\n        // Log2 encoding\r\n    color = max(color, 1e-10f); // avoid 0 or negative numbers for log2\r\n    color = log2(color);\r\n    color = (color - AgxMinEv) / (AgxMaxEv - AgxMinEv);\r\n\r\n    color = clamp(color, 0.0f, 1.0f);\r\n\r\n        // Apply sigmoid\r\n    color = agxDefaultContrastApprox(color);\r\n\r\n        // Apply AgX look\r\n        // v = agxLook(v, look);\r\n\r\n    color = AgXOutsetMatrix * color;\r\n\r\n        // Linearize\r\n    color = pow(max(vec3(0.0f), color), vec3(2.2f));\r\n\r\n    color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\r\n\r\n        // Gamut mapping. Simple clamp for now.\r\n    color = clamp(color, 0.0f, 1.0f);\r\n\r\n    return color;\r\n\r\n}\r\nvec4 sRGBTransferOETF( in vec4 value ) {\r\n    return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\r\n}\r\n` : ''\r\n}\r\n${color?\r\n`\r\n    fragColor = vec4(AgXToneMapping(fragColor.xyz),1.0f);\r\n    fragColor = sRGBTransferOETF(fragColor);\r\n` : ''\r\n}",{declaration:!1,exposure:1,color:!1})});function W(r,o,i,s,c=1024){if(!o.getExtension("EXT_color_buffer_float"))throw new Error("EXT_color_buffer_float extension not supported");const f=function(r,e,n,t){const a=r.createTexture();return r.bindTexture(r.TEXTURE_2D,a),r.texImage2D(r.TEXTURE_2D,0,r.RGBA16F,n,t,0,r.RGBA,r.HALF_FLOAT,e),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.LINEAR),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.LINEAR),a}(o,r,i,s),l=function(r,e){const n=r.createTexture();r.bindTexture(r.TEXTURE_CUBE_MAP,n);for(let n=0;n<6;n++)r.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+n,0,r.RGBA16F,e,e,0,r.RGBA,r.HALF_FLOAT,null);return r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_WRAP_R,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_MIN_FILTER,r.LINEAR_MIPMAP_LINEAR),r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_MAG_FILTER,r.LINEAR),n}(o,c),{program:E,vertexArray:u}=function(r){const e="#version 300 es\n\n    #define SHADER_NAME hdrToCubeVertex\n\n    layout(location = 0) in vec2 position;\n    out vec3 localPos;\n    uniform mat4 projection;\n    uniform mat4 view;\n\n    void main() {\n        // Use the quad positions directly for rendering\n        gl_Position = vec4(position, 0.0, 1.0);\n        \n        // Create the ray direction for this fragment\n        // Map from [-1,1] to [-1,1] in view space for proper cubemap sampling\n        vec4 viewPos = inverse(projection * view) * vec4(position, 1.0, 1.0);\n        localPos = viewPos.xyz / viewPos.w;\n    }",n="#version 300 es\n\n    #define SHADER_NAME hdrToCubeFragment\n\n    precision highp float;\n    in vec3 localPos;\n    out vec4 fragColor;\n    uniform sampler2D equirectangularMap;\n\n    vec2 SampleSphericalMap(vec3 v) {\n        // Convert direction vector to spherical coordinates\n        float phi = atan(v.z, v.x);\n        float theta = asin(v.y);\n        \n        // Map from [-π to π] for phi and [-π/2 to π/2] for theta to [0,1] range\n        vec2 uv = vec2(\n            0.5 + 0.5 * phi / 3.1415926535897932,\n            0.5 - theta / 3.1415926535897932\n        );\n        \n        return uv;\n    }\n\n    void main() {\n        vec3 direction = normalize(localPos);\n        vec2 uv = SampleSphericalMap(direction);\n        fragColor = texture(equirectangularMap, uv);\n    }",t=r.createShader(r.VERTEX_SHADER);r.shaderSource(t,e),r.compileShader(t);const a=r.createShader(r.FRAGMENT_SHADER);r.shaderSource(a,n),r.compileShader(a);const o=r.createProgram();if(r.attachShader(o,t),r.attachShader(o,a),r.linkProgram(o),!r.getProgramParameter(o,r.LINK_STATUS))throw console.error("Shader program error:",r.getProgramInfoLog(o)),console.error("Vertex shader log:",r.getShaderInfoLog(t)),console.error("Fragment shader log:",r.getShaderInfoLog(a)),new Error("Failed to compile shaders");const i=r.createVertexArray();r.bindVertexArray(i);const s=new Float32Array([-1,-1,1,-1,-1,1,1,1]),c=r.createBuffer();return r.bindBuffer(r.ARRAY_BUFFER,c),r.bufferData(r.ARRAY_BUFFER,s,r.STATIC_DRAW),r.enableVertexAttribArray(0),r.vertexAttribPointer(0,2,r.FLOAT,!1,0,0),{program:o,vertexArray:i}}(o),m=o.createFramebuffer();o.bindFramebuffer(o.FRAMEBUFFER,m),o.useProgram(E),o.bindVertexArray(u),o.activeTexture(o.TEXTURE0),o.bindTexture(o.TEXTURE_2D,f),o.uniform1i(o.getUniformLocation(E,"equirectangularMap"),0);const p=a(),g=Math.PI/2,T=1/Math.tan(g/2);p[0]=T/1,p[5]=T,p[10]=10.1/-9.9,p[11]=-1,p[14]=2/-9.9;const A=o.getUniformLocation(E,"projection");o.uniformMatrix4fv(A,!1,p);const _=[],R=e();for(let r=0;r<6;r++){const e=n();let a,o;switch(r){case 0:a=[1,0,0],o=[0,-1,0];break;case 1:a=[-1,0,0],o=[0,-1,0];break;case 2:a=[0,1,0],o=[0,0,1];break;case 3:a=[0,-1,0],o=[0,0,-1];break;case 4:a=[0,0,1],o=[0,-1,0];break;case 5:a=[0,0,-1],o=[0,-1,0]}const i=[R[0]+a[0],R[1]+a[1],R[2]+a[2]];t(e,R,i,o),_.push(e)}for(let r=0;r<6;r++){o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_CUBE_MAP_POSITIVE_X+r,l,0);const e=o.checkFramebufferStatus(o.FRAMEBUFFER);e===o.FRAMEBUFFER_COMPLETE?(o.uniformMatrix4fv(o.getUniformLocation(E,"view"),!1,_[r]),o.viewport(0,0,c,c),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT),o.drawArrays(o.TRIANGLE_STRIP,0,4)):console.error("Framebuffer not complete:",e)}return o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(m),o.deleteTexture(f),o.bindTexture(o.TEXTURE_CUBE_MAP,l),o.generateMipmap(o.TEXTURE_CUBE_MAP),l}function q(r){let e,n,t,a;return t=new c({}),{c(){e=f("canvas"),n=l(),E(t.$$.fragment)},m(o,i){u(o,e,i),r[1](e),u(o,n,i),m(t,o,i),a=!0},p:p,i(r){a||(g(t.$$.fragment,r),a=!0)},o(r){T(t.$$.fragment,r),a=!1},d(a){a&&(A(e),A(n)),r[1](null),_(t,a)}}}function Y(){}function K(r,e,n){let t,o,i,s,c,f,l,E;return R(r,h,(r=>n(3,t=r))),R(r,v,(r=>n(4,o=r))),R(r,x,(r=>n(5,i=r))),R(r,M,(r=>n(6,s=r))),R(r,b,(r=>n(7,c=r))),R(r,w,(r=>n(8,f=r))),d((async()=>{U(h,t={...t,canvas:l,backgroundColor:L,ambientLightColor:[16777215,.1]},t),U(w,f={...f,position:[-4.5,.8,-2.5],target:[0,0,0],fov:75},f),E=await H("christmas_photo_studio_01_4k.hdr");const r=z({exposure:1.5});const e=await S({typedArray:E.data,convertToCube:W,width:E.width,height:E.height,cubeSize:2048,toneMapping:r});U(b,c=[e],c);const n=D(),u=y(F({position:[-2,2,2],color:[1,1,1],intensity:20,cutoffDistance:0,decayExponent:2})),m=P(a()),p=C({diffuse:[1,0,0],metalness:0,program:O()}),g=G({...n,matrix:m,material:p}),T=C({diffuse:[1,.5,.5],metalness:0});U(M,s=[...s,T,p],s),U(x,i=[...i,I({...n,matrix:m,material:T}),I(g)],i),U(v,o=[...o,u],o),U(h,t={...t,loop:Y,enabled:!0},t),X(l,w)})),[l,function(r){B[r?"unshift":"push"]((()=>{l=r,n(0,l)}))}]}class J extends o{constructor(r){super(),i(this,r,K,q,s,{})}}export{J as default};
