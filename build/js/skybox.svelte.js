import{a7 as e,U as r,av as t,W as a,z as n,S as o,i,s,M as c,e as l,a as E,c as f,b as u,m,n as T,t as p,d,f as h,g,h as A,o as R,r as _,l as v,j as b,k as U,q as w,p as M,A as F,B as x,C as y,D as P,y as C,E as L,F as S,G as B,H as X}from"./Menu-D-ion0Ay.js";import{c as I}from"./skybox-De9iqmu0.js";import{c as D}from"./cube-A6RyjrKd.js";import{c as O,a as G}from"./debug-program-CTD-ON07.js";const H=1016,k=1015;async function V(e){const r=await fetch(e);return function(e){const r=H,t=1,a=2,n=3,o=4,i=1,s=2,c=4,l="\n",E=new Uint8Array(e);E.pos=0;const f=A(E),u=f.width,m=f.height,T=R(E.subarray(E.pos),u,m);let p,d;switch(r){case k:d=T.length/4;const e=new Float32Array(4*d);for(let r=0;r<d;r++)_(T,4*r,e,4*r);p=e;break;case H:d=T.length/4;const t=new Uint16Array(4*d);for(let e=0;e<d;e++)v(T,4*e,t,4*e);p=t;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+r)}return{width:u,height:m,data:p,header:f.string,gamma:f.gamma,exposure:f.exposure,type:r};function h(e,r){switch(e){case t:throw new Error("THREE.RGBELoader: Read Error: "+(r||""));case a:throw new Error("THREE.RGBELoader: Write Error: "+(r||""));case n:throw new Error("THREE.RGBELoader: Bad File Format: "+(r||""));default:throw new Error("THREE.RGBELoader: Memory Error: "+(r||""))}}function g(e,r,t){const a=128;r=r||1024;let n=e.pos,o=-1,i=0,s="",c=String.fromCharCode.apply(null,new Uint16Array(e.subarray(n,n+a)));for(;0>(o=c.indexOf(l))&&i<r&&n<e.byteLength;)s+=c,i+=c.length,n+=a,c+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(n,n+a)));return-1<o&&(e.pos+=i+o+1,s+c.slice(0,o))}function A(e){const r=/^#\?(\S+)/,a=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,o=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,l=/^\s*FORMAT=(\S+)\s*$/,E=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,f={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let u,m;for((e.pos>=e.byteLength||!(u=g(e)))&&h(t,"no header found"),(m=u.match(r))||h(n,"bad initial token"),f.valid|=i,f.programtype=m[1],f.string+=u+"\n";u=g(e),!1!==u;)if(f.string+=u+"\n","#"!==u.charAt(0)){if((m=u.match(a))&&(f.gamma=parseFloat(m[1])),(m=u.match(o))&&(f.exposure=parseFloat(m[1])),(m=u.match(l))&&(f.valid|=s,f.format=m[1]),(m=u.match(E))&&(f.valid|=c,f.height=parseInt(m[1],10),f.width=parseInt(m[2],10)),f.valid&s&&f.valid&c)break}else f.comments+=u+"\n";return f.valid&s||h(n,"missing format specifier"),f.valid&c||h(n,"missing image size specifier"),f}function R(e,r,a){const i=r;if(i<8||i>32767||2!==e[0]||2!==e[1]||128&e[2])return new Uint8Array(e);i!==(e[2]<<8|e[3])&&h(n,"wrong scanline width");const s=new Uint8Array(4*r*a);s.length||h(o,"unable to allocate buffer space");let c=0,l=0;const E=4*i,f=new Uint8Array(4),u=new Uint8Array(E);let m=a;for(;m>0&&l<e.byteLength;){l+4>e.byteLength&&h(t),f[0]=e[l++],f[1]=e[l++],f[2]=e[l++],f[3]=e[l++],2==f[0]&&2==f[1]&&(f[2]<<8|f[3])==i||h(n,"bad rgbe scanline format");let r,a=0;for(;a<E&&l<e.byteLength;){r=e[l++];const t=r>128;if(t&&(r-=128),(0===r||a+r>E)&&h(n,"bad scanline data"),t){const t=e[l++];for(let e=0;e<r;e++)u[a++]=t}else u.set(e.subarray(l,l+r),a),a+=r,l+=r}const o=i;for(let e=0;e<o;e++){let r=0;s[c]=u[e+r],r+=i,s[c+1]=u[e+r],r+=i,s[c+2]=u[e+r],r+=i,s[c+3]=u[e+r],c+=4}m--}return s}function _(e,r,t,a){const n=e[r+3],o=Math.pow(2,n-128)/255;t[a+0]=e[r+0]*o,t[a+1]=e[r+1]*o,t[a+2]=e[r+2]*o,t[a+3]=1}function v(e,r,t,a){const n=e[r+3],o=Math.pow(2,n-128)/255;t[a+0]=$(Math.min(e[r+0]*o,65504)),t[a+1]=$(Math.min(e[r+1]*o,65504)),t[a+2]=$(Math.min(e[r+2]*o,65504)),t[a+3]=$(1)}}(await r.arrayBuffer())}function $(e){var r,t,a;Math.abs(e)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),r=e,t=-65504,a=65504,e=Math.max(t,Math.min(a,r)),N.floatView[0]=e;const n=N.uint32View[0],o=n>>23&511;return N.baseTable[o]+((8388607&n)>>N.shiftTable[o])}const N=j();function j(){const e=new ArrayBuffer(4),r=new Float32Array(e),t=new Uint32Array(e),a=new Uint32Array(512),n=new Uint32Array(512);for(let e=0;e<256;++e){const r=e-127;r<-27?(a[e]=0,a[256|e]=32768,n[e]=24,n[256|e]=24):r<-14?(a[e]=1024>>-r-14,a[256|e]=1024>>-r-14|32768,n[e]=-r-1,n[256|e]=-r-1):r<=15?(a[e]=r+15<<10,a[256|e]=r+15<<10|32768,n[e]=13,n[256|e]=13):r<128?(a[e]=31744,a[256|e]=64512,n[e]=24,n[256|e]=24):(a[e]=31744,a[256|e]=64512,n[e]=13,n[256|e]=13)}const o=new Uint32Array(2048),i=new Uint32Array(64),s=new Uint32Array(64);for(let e=1;e<1024;++e){let r=e<<13,t=0;for(;!(8388608&r);)r<<=1,t-=8388608;r&=-8388609,t+=947912704,o[e]=r|t}for(let e=1024;e<2048;++e)o[e]=939524096+(e-1024<<13);for(let e=1;e<31;++e)i[e]=e<<23;i[31]=1199570944,i[32]=2147483648;for(let e=33;e<63;++e)i[e]=2147483648+(e-32<<23);i[63]=3347054592;for(let e=1;e<64;++e)32!==e&&(s[e]=1024);return{floatView:r,uint32View:t,baseTable:a,shiftTable:n,mantissaTable:o,exponentTable:i,offsetTable:s}}const W=r=>({exposure:`${r.exposure.toLocaleString("en",{minimumFractionDigits:1})}f`,shader:e("${declaration?\r\n`\r\n#ifndef saturate\r\n    #define saturate( a ) clamp( a, 0.0, 1.0 )\r\n#endif\r\n\r\nfloat toneMappingExposure = ${exposure};\r\n\r\nvec3 RRTAndODTFit( vec3 v ) {\r\n    vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\r\n    vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\r\n    return a / b;\r\n}\r\nvec3 ACESFilmicToneMapping( vec3 color ) {\r\n    const mat3 ACESInputMat = mat3(\r\n    vec3( 0.59719, 0.07600, 0.02840 ), vec3( 0.35458, 0.90834, 0.13383 ), vec3( 0.04823, 0.01566, 0.83777 )\r\n    );\r\n    const mat3 ACESOutputMat = mat3(\r\n    vec3(  1.60475, -0.10208, -0.00327 ), vec3( -0.53108, 1.10813, -0.07276 ), vec3( -0.07367, -0.00605, 1.07602 )\r\n    );\r\n    color *= toneMappingExposure / 0.6;\r\n    color = ACESInputMat * color;\r\n    color = RRTAndODTFit( color );\r\n    color = ACESOutputMat * color;\r\n    return saturate( color );\r\n}\r\nvec4 sRGBTransferOETF( in vec4 value ) {\r\n    return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\r\n}\r\n` : ''\r\n}\r\n${color?\r\n`\r\n    fragColor = vec4(ACESFilmicToneMapping(fragColor.rgb),1.0f);\r\n    fragColor = sRGBTransferOETF(fragColor);\r\n    \r\n` : ''\r\n}",{declaration:!1,exposure:1,color:!1})});function q(e,o,i,s,c=1024){console.log("hdrToCube");if(!o.getExtension("EXT_color_buffer_float"))throw new Error("EXT_color_buffer_float extension not supported");const l=function(e,r,t,a){const n=e.createTexture();return e.bindTexture(e.TEXTURE_2D,n),e.texImage2D(e.TEXTURE_2D,0,e.RGBA16F,t,a,0,e.RGBA,e.HALF_FLOAT,r),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),n}(o,e,i,s),E=function(e,r){const t=e.createTexture();e.bindTexture(e.TEXTURE_CUBE_MAP,t);for(let t=0;t<6;t++)e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+t,0,e.RGBA16F,r,r,0,e.RGBA,e.HALF_FLOAT,null);return e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_R,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MAG_FILTER,e.LINEAR),t}(o,c),{program:f,vertexArray:u}=function(e){const r="#version 300 es\n\n    #define SHADER_NAME hdrToCubeVertex\n\n    layout(location = 0) in vec2 position;\n    out vec3 localPos;\n    uniform mat4 projection;\n    uniform mat4 view;\n\n    void main() {\n        // Use the quad positions directly for rendering\n        gl_Position = vec4(position, 0.0, 1.0);\n        \n        // Create the ray direction for this fragment\n        // Map from [-1,1] to [-1,1] in view space for proper cubemap sampling\n        vec4 viewPos = inverse(projection * view) * vec4(position, 1.0, 1.0);\n        localPos = viewPos.xyz / viewPos.w;\n    }",t="#version 300 es\n\n    #define SHADER_NAME hdrToCubeFragment\n\n    precision highp float;\n    in vec3 localPos;\n    out vec4 fragColor;\n    uniform sampler2D equirectangularMap;\n\n    vec2 SampleSphericalMap(vec3 v) {\n        // Convert direction vector to spherical coordinates\n        float phi = atan(v.z, v.x);\n        float theta = asin(v.y);\n        \n        // Map from [-π to π] for phi and [-π/2 to π/2] for theta to [0,1] range\n        vec2 uv = vec2(\n            0.5 + 0.5 * phi / 3.1415926535897932,\n            0.5 - theta / 3.1415926535897932\n        );\n        \n        return uv;\n    }\n\n    void main() {\n        vec3 direction = normalize(localPos);\n        vec2 uv = SampleSphericalMap(direction);\n        fragColor = texture(equirectangularMap, uv);\n    }",a=e.createShader(e.VERTEX_SHADER);e.shaderSource(a,r),e.compileShader(a);const n=e.createShader(e.FRAGMENT_SHADER);e.shaderSource(n,t),e.compileShader(n);const o=e.createProgram();if(e.attachShader(o,a),e.attachShader(o,n),e.linkProgram(o),!e.getProgramParameter(o,e.LINK_STATUS))throw console.error("Shader program error:",e.getProgramInfoLog(o)),console.error("Vertex shader log:",e.getShaderInfoLog(a)),console.error("Fragment shader log:",e.getShaderInfoLog(n)),new Error("Failed to compile shaders");const i=e.createVertexArray();e.bindVertexArray(i);const s=new Float32Array([-1,-1,1,-1,-1,1,1,1]),c=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,c),e.bufferData(e.ARRAY_BUFFER,s,e.STATIC_DRAW),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,0,0),{program:o,vertexArray:i}}(o),m=o.createFramebuffer();o.bindFramebuffer(o.FRAMEBUFFER,m),o.useProgram(f),o.bindVertexArray(u),o.activeTexture(o.TEXTURE0),o.bindTexture(o.TEXTURE_2D,l),o.uniform1i(o.getUniformLocation(f,"equirectangularMap"),0);const T=n(),p=Math.PI/2,d=1/Math.tan(p/2);T[0]=d/1,T[5]=d,T[10]=10.1/-9.9,T[11]=-1,T[14]=2/-9.9;const h=o.getUniformLocation(f,"projection");console.log("projectionLocation",h),o.uniformMatrix4fv(h,!1,T);const g=[],A=r();for(let e=0;e<6;e++){const r=t();let n,o;switch(e){case 0:n=[1,0,0],o=[0,-1,0];break;case 1:n=[-1,0,0],o=[0,-1,0];break;case 2:n=[0,1,0],o=[0,0,1];break;case 3:n=[0,-1,0],o=[0,0,-1];break;case 4:n=[0,0,1],o=[0,-1,0];break;case 5:n=[0,0,-1],o=[0,-1,0]}const i=[A[0]+n[0],A[1]+n[1],A[2]+n[2]];a(r,A,i,o),g.push(r)}for(let e=0;e<6;e++){o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_CUBE_MAP_POSITIVE_X+e,E,0);const r=o.checkFramebufferStatus(o.FRAMEBUFFER);if(r!==o.FRAMEBUFFER_COMPLETE){console.error("Framebuffer not complete:",r);continue}const t=o.getUniformLocation(f,"view");console.log("viewLocation",t),o.uniformMatrix4fv(o.getUniformLocation(f,"view"),!1,g[e]),o.viewport(0,0,c,c),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT),o.drawArrays(o.TRIANGLE_STRIP,0,4)}return o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(m),o.deleteTexture(l),o.bindTexture(o.TEXTURE_CUBE_MAP,E),o.generateMipmap(o.TEXTURE_CUBE_MAP),console.log("hdrToCube end"),E}function z(e){let r,t,a,n;return a=new c({}),{c(){r=l("canvas"),t=E(),f(a.$$.fragment)},m(o,i){u(o,r,i),e[1](r),u(o,t,i),m(a,o,i),n=!0},p:T,i(e){n||(p(a.$$.fragment,e),n=!0)},o(e){d(a.$$.fragment,e),n=!1},d(n){n&&(h(r),h(t)),e[1](null),g(a,n)}}}function Y(){}function K(e,r,t){let a,o,i,s,c,l,E,f;return A(e,_,(e=>t(3,a=e))),A(e,v,(e=>t(4,o=e))),A(e,b,(e=>t(5,i=e))),A(e,U,(e=>t(6,s=e))),A(e,w,(e=>t(7,c=e))),A(e,M,(e=>t(8,l=e))),R((async()=>{F(_,a={...a,canvas:E,backgroundColor:x,ambientLightColor:[16777215,.1]},a),F(M,l={...l,position:[0,2,-5],target:[0,0,0],fov:75},l),f=await V("christmas_photo_studio_01_2k.hdr");const e=W({exposure:3});const r=await I({typedArray:f.data,convertToCube:q,width:f.width,height:f.height,cubeSize:2048,toneMapping:e});F(w,c=[r],c);const t=D(),u=y(P({position:[-2,2,-2],color:[1,1,1],intensity:20,cutoffDistance:0,decayExponent:2})),m=C(n()),T=X({diffuse:[1,0,0],metalness:0,program:G()}),p=O({...t,matrix:m,material:T}),d=X({diffuse:[1,.5,.5],metalness:0});F(U,s=[...s,d,T],s),F(b,i=[...i,L({...t,matrix:m,material:d}),L(p)],i),F(v,o=[...o,u],o),F(_,a={...a,loop:Y,enabled:!0},a),S(E,M)})),[E,function(e){B[e?"unshift":"push"]((()=>{E=e,t(0,E)}))}]}class J extends o{constructor(e){super(),i(this,e,K,z,s,{})}}export{J as default};
