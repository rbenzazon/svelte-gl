let e={taskID:0,pending:!1,decode:async function(e,t,r,n){let{taskID:o}=e;e.taskID++;const a={attributeIDs:r,attributeTypes:n,useUniqueIDs:!0,vertexColorSpace:"SRGB"};return await new Promise(((r,n)=>{const{worker:s}=e;s._callbacks[o]={resolve:r,reject:n},s.postMessage({type:"decode",id:o,taskConfig:a,buffer:t},[t])}))}};async function t(t){if(e.pending)return e.promise;let n={};const o=new Promise(((e,t)=>{n.resolve=e,n.reject=t}));e.promise=o,e.pending=!0;const a=fetch(t+"draco_wasm_wrapper.js"),s=fetch(t+"draco_decoder.wasm");await Promise.all([a,s]);const c=await(await a).text(),i=await(await s).arrayBuffer(),d=function(e){const t=r.toString(),n=["/* draco decoder */",e,"","/* worker */",t.substring(t.indexOf("{")+1,t.lastIndexOf("}"))].join("\n");return URL.createObjectURL(new Blob([n]))}(c),u=new Worker(d);return u._callbacks={},u.postMessage({type:"init",decoderConfig:{wasmBinary:i}}),u.onmessage=function(e){const t=e.data;switch(t.type){case"decode":u._callbacks[t.id].resolve(t);break;case"error":u._callbacks[t.id].reject(t);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+t.type+'"')}},e.worker=u,e.taskID=0,n.resolve(),e}function r(){let e,t;function r(e,t,r,n,o,a){const s=a.num_components(),c=r.num_points()*s,i=c*o.BYTES_PER_ELEMENT,d=function(e,t){switch(t){case Float32Array:return e.DT_FLOAT32;case Int8Array:return e.DT_INT8;case Int16Array:return e.DT_INT16;case Int32Array:return e.DT_INT32;case Uint8Array:return e.DT_UINT8;case Uint16Array:return e.DT_UINT16;case Uint32Array:return e.DT_UINT32}}(e,o),u=e._malloc(i);t.GetAttributeDataArrayForAllPoints(r,a,d,i,u);const l=new o(e.HEAPF32.buffer,u,c).slice();return e._free(u),{name:n,array:l,itemSize:s}}onmessage=function(n){const o=n.data;switch(o.type){case"init":e=o.decoderConfig,t=new Promise((function(t){e.onModuleLoaded=function(e){t({draco:e})},DracoDecoderModule(e)}));break;case"decode":const n=o.buffer,a=o.taskConfig;t.then((e=>{const t=e.draco,s=new t.Decoder;try{const e=function(e,t,n,o){const a=o.attributeIDs,s=o.attributeTypes;let c,i;const d=t.GetEncodedGeometryType(n);if(d===e.TRIANGULAR_MESH)c=new e.Mesh,i=t.DecodeArrayToMesh(n,n.byteLength,c);else{if(d!==e.POINT_CLOUD)throw new Error("THREE.DRACOLoader: Unexpected geometry type.");c=new e.PointCloud,i=t.DecodeArrayToPointCloud(n,n.byteLength,c)}if(!i.ok()||0===c.ptr)throw new Error("THREE.DRACOLoader: Decoding failed: "+i.error_msg());const u={index:null,attributes:[]};for(const l in a){const n=self[s[l]];let i,d;if(o.useUniqueIDs)d=a[l],i=t.GetAttributeByUniqueId(c,d);else{if(d=t.GetAttributeId(c,e[a[l]]),-1===d)continue;i=t.GetAttribute(c,d)}const f=r(e,t,c,l,n,i);"color"===l&&(f.vertexColorSpace=o.vertexColorSpace),u.attributes.push(f)}d===e.TRIANGULAR_MESH&&(u.index=function(e,t,r){const n=r.num_faces(),o=3*n,a=4*o,s=e._malloc(a);t.GetTrianglesUInt32Array(r,a,s);const c=new Uint32Array(e.HEAPF32.buffer,s,o).slice();return e._free(s),{array:c,itemSize:1}}(e,t,c));return e.destroy(c),u}(t,s,new Int8Array(n),a),c=e.attributes.map((e=>e.array.buffer));e.index&&c.push(e.index.array.buffer),self.postMessage({type:"decode",id:o.id,geometry:e},c)}catch(c){console.error(c),self.postMessage({type:"error",id:o.id,error:c.message})}finally{t.destroy(s)}}))}}}export{t as i};
