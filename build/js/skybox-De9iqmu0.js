import{aw as e,r,a7 as n,X as t,Y as o,Z as a,_ as i,R as s,L as c,ax as E,ay as u,z as _,$ as T,K as g,J as p,U as l,I as P}from"./Menu-D-ion0Ay.js";var m="#version 300 es\r\n\r\n#define SHADER_NAME skyboxVertex\r\n\r\nin vec4 position;\r\nout vec4 v_position;\r\nvoid main() {\r\n    v_position = position;\r\n    gl_Position = position;\r\n    gl_Position.z = 1.0;\r\n}",d="#version 300 es\r\nprecision highp float;\r\n\r\n#define SHADER_NAME skyboxFragment\r\n\r\nuniform samplerCube skybox;\r\nuniform mat4 viewDirectionProjectionInverse;\r\n\r\n${declarations}\r\n  \r\nin vec4 v_position;\r\n  \r\n// we need to declare an output for the fragment shader\r\nout vec4 fragColor;\r\n  \r\nvoid main() {\r\n  vec4 t = viewDirectionProjectionInverse * v_position;\r\n  fragColor = texture(skybox, normalize(t.xyz / t.w));\r\n  ${toneMappings}\r\n}";async function f(n){let E,u;function _(e){E=e}function T(){return E}const g={createProgram:e,setupProgram:[t,o],setupMaterial:[],bindTextures:[M(T)],setupCamera:U,useProgram:a,selectProgram:i,updateProgram:[h((function(e){u=e}))],meshes:[{attributes:{positionsSize:2,positions:new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1])},drawMode:c[4]}],postDraw:x((function(){return u}))};let p,l,P;return!function(e){return"url"in e&&"string"==typeof e.url}(n)?function(e){return"typedArray"in e&&e.typedArray instanceof Uint16Array}(n)&&(l=n.typedArray,g.createProgram=function(r){return function(n){return function(){null!=r&&r(),e(n)()}}}(function(e,n,t,o,a,i){return function(){const{gl:c}=s,E=t(e,c,o,a,i);n(E),console.log("setupHDRTexture"),r.update((e=>e))}}(l,_,n.convertToCube,n.width,n.height,n.cubeSize)),P=n.toneMapping,g.setupProgram=[A(P),...g.setupProgram],g.setupMaterial=[M(T)],p={}):(g.setupMaterial=[await n.convertToCube(n.url,_)],g.setupProgram=[A(),...g.setupProgram],p={url:n.url}),{...p,order:1,programs:[g]}}function A(e){return function(){const{gl:r,program:t}=s,o=r.createShader(r.VERTEX_SHADER);r.shaderSource(o,m),r.compileShader(o),r.getShaderParameter(o,r.COMPILE_STATUS)||console.error(r.getShaderInfoLog(o)),r.attachShader(t,o);const a=r.createShader(r.FRAGMENT_SHADER);let i="",c="";null!=e&&(i=e.shader({declaration:!0,exposure:e.exposure}),c=e.shader({color:!0}));const E=n(d,{declarations:"",toneMappings:""})({declarations:i,toneMappings:c});r.shaderSource(a,E),r.compileShader(a),r.getShaderParameter(a,r.COMPILE_STATUS)||console.error(r.getShaderInfoLog(a)),r.attachShader(t,a)}}function U(e){return function(){const{gl:r,program:n,canvas:t}=s,{projection:o}=E(e,t.width,t.height);console.log("camera",e);const a=(i=e.position,c=e.target,m=e.up,d=_(),f=g(l(),p(l(),i,c)),A=g(l(),P(l(),m,f)),U=g(l(),P(l(),f,A)),d[0]=A[0],d[1]=A[1],d[2]=A[2],d[3]=0,d[4]=U[0],d[5]=U[1],d[6]=U[2],d[7]=0,d[8]=f[0],d[9]=f[1],d[10]=f[2],d[11]=0,d[12]=i[0],d[13]=i[1],d[14]=i[2],d[15]=1,d);var i,c,m,d,f,A,U;const R=u(_(),a);R[12]=0,R[13]=0,R[14]=0;const M=T(_(),o,R),h=u(_(),M),x=r.getUniformLocation(n,"viewDirectionProjectionInverse");console.log("viewDirectionProjectionInverseMatrix",h),r.uniformMatrix4fv(x,!1,h),console.log("after")}}async function R(e,n){const t=new Image;return await new Promise(((r,n)=>{t.src=e,t.onload=function(){r(t)},t.onerror=n})),function(){const{gl:t}=s,o=t.createTexture();n(o),t.bindTexture(t.TEXTURE_CUBE_MAP,o);const a=new Image;a.src=e,t.bindTexture(t.TEXTURE_CUBE_MAP,o),function(e,r){const n=document.createElement("canvas"),t=n.getContext("2d"),o=e.width/4,a=e.height/3;n.width=o,n.height=a;const i=[[2,1,r.TEXTURE_CUBE_MAP_POSITIVE_X],[0,1,r.TEXTURE_CUBE_MAP_NEGATIVE_X],[1,0,r.TEXTURE_CUBE_MAP_POSITIVE_Y],[1,2,r.TEXTURE_CUBE_MAP_NEGATIVE_Y],[1,1,r.TEXTURE_CUBE_MAP_POSITIVE_Z],[3,1,r.TEXTURE_CUBE_MAP_NEGATIVE_Z]];i.forEach((([i,s,c])=>{t.clearRect(0,0,o,a),t.drawImage(e,i*o,s*a,o,a,0,0,o,a),r.texImage2D(c,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,n)}))}(a,t),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MIN_FILTER,t.LINEAR_MIPMAP_LINEAR),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_R,t.CLAMP_TO_EDGE),t.generateMipmap(t.TEXTURE_CUBE_MAP),r.update((e=>e))}}function M(e){return function(){console.log("bindSkyBoxTexture");const{gl:r,program:n}=s,t=r.getUniformLocation(n,"skybox");r.uniform1i(t,0),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_CUBE_MAP,e())}}function h(e){return function(){const{gl:r}=s;e(r.getParameter(r.DEPTH_FUNC)),r.depthFunc(r.LEQUAL)}}function x(e){return function(){const{gl:r}=s;r.depthFunc(e())}}export{f as c,R as s};
