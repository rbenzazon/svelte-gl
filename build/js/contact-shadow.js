import{T as n,U as r,R as t,V as o,W as e,X as i,Y as a,z as s,Z as u,_ as f,$ as c,a0 as m,a1 as l,a2 as g}from"./engine.js";function p(r=!1){return function(t){return function(){const{gl:o,programMap:e,vaoMap:i}=n;if(e.has(t)||r)r?(e.set(t,n.program),i.set(t,new Map)):n.program=n.programMap.get(t);else{const r=o.createProgram();e.set(t,r),i.set(t,new Map),n.program=r}}}}function v(){const{gl:t,program:o}=n;r(t,o,"#version 300 es\n\nin vec4 position;\r\nin vec2 uv;\n\nout vec2 vTexCoord;\n\nvoid main()\r\n{\r\n    gl_Position = position;\r\n    vTexCoord = uv;\r\n}","#version 300 es\n\nprecision mediump float;\n\nuniform sampler2D sampler;\r\nuniform vec2 uvStride;\r\nuniform vec2[128] offsetAndScale; \nuniform int kernelWidth;\n\nin vec2 vTexCoord;\n\nout vec4 fragColor;\n\nvoid main()\r\n{\r\n\t\n\t\n\tfor (int i = 0; i < kernelWidth; i++) {\n\n\t\tfragColor += texture(\r\n\t\t\tsampler,\r\n\t\t\tvTexCoord + offsetAndScale[i].x * uvStride\r\n\t\t    \n\t\t    \n\t\t    \n\t\t    \n\t\t) * offsetAndScale[i].y;\n\n\t\t\n\t}\r\n\t\n\t\n\t\n}")}function d(r){const{gl:t,program:o}=n,e=0===r?[1/n.frameBufferWidth,0]:[0,1/n.frameBufferHeight],i=t.getUniformLocation(o,"uvStride");t.uniform2fv(i,e)}function h(n){const r=(n=>{if(1&~n)throw new Error("Only odd guassian kernel sizes are accepted");if(n<9)throw new Error("Blur must be at least 9 pixels wide");const r=[],t=n/6,o=(n-1)/2;let e=0;for(let i=0;i<n;i++){const n=i-o,a=-n*n/(t*t*2),s=1/(t*Math.sqrt(2*Math.PI))*Math.exp(a);e+=s,r.push(s)}for(let i=0;i<n;i++)r[i]/=e;return r})(n);return(n=>{if(!(1&n.length))throw new Error("Only odd kernel sizes can be lerped");const r=Math.ceil(n.length/2),t=[];let o=1-r,e=n[0];t.push(o,e);const i=n.reduce(((n,r)=>n+r));for(let a=1;a<n.length;a+=2){const s=n[a],u=n[a+1];o=1-r+a+u/(s+u),e=(s+u)/i,t.push(o,e)}return t})(r)}function M(r,M,T,U,W=1024,E=128,_=1){const b=o(e(),r),k=T/U,H=W*k,S=W/k,Z=i(s(),-T/2,T/2,-U/2,U/2,0,M),z=a(s(),b,[b[0],b[1]+1,b[2]],[0,0,1]);let A,L,R,y,D,j;function O(){return L}function I(){return j}const X={attributes:{positionsSize:2,positions:new Float32Array([-1,1,-1,-1,1,1,1,-1]),uvs:new Float32Array([0,1,0,0,1,1,1,0])},drawMode:t[5]};return{programs:[{createProgram:function(r){return function(){const{gl:t,programMap:o,vaoMap:e}=n,i=t.createProgram();o.set(r,i),e.set(r,new Map),n.program=i}},setupProgram:[F,u,f,c(H,S,(function(n){D=n}),(function(n){j=n}))],setupMaterial:[P(_)],useProgram:m,selectProgram:l,setupCamera:B(Z,z),setFrameBuffer:C((function(){return D}),H,S),allMeshes:!0},{createProgram:p(),setupProgram:[v,u,f,c(H,S,(function(n){A=n}),(function(n){L=n}))],setupMaterial:[(q=E,function(){const r={size:q},t=h(r.size-1);return function(r){const{gl:t,program:o}=n,e=t.getUniformLocation(o,"offsetAndScale");t.uniform2fv(e,r);const i=t.getUniformLocation(o,"kernelWidth");t.uniform1i(i,r.length/2)}(t),r}),()=>d(0),()=>x(I)],useProgram:m,selectProgram:w(0,I),setupCamera:()=>()=>{},setFrameBuffer:C((function(){return A}),H,S),meshes:[X],postDraw:g},{createProgram:p(!0),setupProgram:[c(H,S,(function(n){R=n}),(function(n){y=n}))],setupMaterial:[()=>d(1),()=>x(O)],useProgram:m,selectProgram:w(1,O),setupCamera:()=>()=>{},setFrameBuffer:C((function(){return R}),H,S),meshes:[X],postDraw:g}],getTexture:function(){return y},order:-1};var q}function P(r){return function(){const{gl:t,program:o}=n,e=t.getUniformLocation(o,"darkness");t.uniform1f(e,r)}}function w(n,r){return function(t){return function(){l(t)(),m(),x(r),d(n)}}}function x(r){const{gl:t}=n,o=r();t.bindTexture(t.TEXTURE_2D,o)}function C(r=null,t,o){return function(){const{gl:e}=n,i=r?r():null;e.bindFramebuffer(e.FRAMEBUFFER,i),n.fbo!==i&&null!=i&&(e.viewport(0,0,t,o),n.frameBufferWidth=t,n.frameBufferHeight=o,e.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT)),n.fbo=i}}function B(r,t){return function(){return function(){const{gl:o,program:e}=n,i=o.getUniformLocation(e,"projectionMatrix");o.uniformMatrix4fv(i,!1,r);const a=o.getUniformLocation(e,"view");o.uniformMatrix4fv(a,!1,t)}}}function F(){const{gl:t,program:o}=n;r(t,o,"#version 300 es\n\nprecision highp float;\n\nuniform mat4 view;\r\nuniform mat4 projectionMatrix;\r\nuniform mat4 modelMatrix;\n\nin vec3 position;\n\nout vec2 vHighPrecisionZW;\n\nvoid main() {\r\n\tgl_Position = projectionMatrix * view * modelMatrix * vec4( position, 1.0 );\r\n\tvHighPrecisionZW = gl_Position.zw;\r\n}","#version 300 es\n\nout highp vec4 fragColor;\n\nprecision highp float;\r\nprecision highp int;\n\nuniform float darkness;\r\nin vec2 vHighPrecisionZW;\n\nvoid main() {\r\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\r\n\tfragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );\r\n\t\n\t\n}")}export{M as c};
