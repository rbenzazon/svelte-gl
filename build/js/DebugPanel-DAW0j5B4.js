import { S as SvelteComponent, i as init, s as safe_not_equal, a9 as append_styles, ad as create_slot, e as element, a as space, aa as attr, b as insert, ae as append, af as update_slot_base, ag as get_all_dirty_from_scope, ah as get_slot_changes, t as transition_in, d as transition_out, f as detach, ai as text, ab as listen, aj as set_data, n as noop, ak as createEventDispatcher, c as create_component, m as mount_component, g as destroy_component, ac as run_all, al as null_to_empty, h as component_subscribe, p as camera, z as set_store_value, am as hexNumToCSSStringColor, an as linearArrayToCSSHashColor, r as renderer, ao as cssStringColorToHexNum, l as lights, ap as ensure_array_like, aq as empty, ar as group_outros, as as check_outros, at as destroy_each, N as get_store_value, au as cssStringColorToLinearArray, av as colorProps, aw as meshes, ax as toggle_class } from './Menu-BqnWciH7.js';

/* src\components\DebugPanel\DebugBlock.svelte generated by Svelte v4.2.18 */

function add_css$b(target) {
	append_styles(target, "svelte-12snxhu", "div.content.svelte-12snxhu{width:100%;height:100%;display:flex;justify-content:center;align-items:stretch;flex-direction:column;gap:var(--panel-vertical-padding);padding:var(--panel-vertical-padding) var(--panel-horizontal-padding);font-size:0.9rem}div.block.level1.svelte-12snxhu{border-top:2px solid var(--panel-dark-color);padding:var(--panel-vertical-padding) var(--panel-horizontal-padding)}div.block.level2.svelte-12snxhu,div.block.level3.svelte-12snxhu,div.block.level4.svelte-12snxhu{border-top:1px solid var(--panel-dark-color)}");
}

const get_title_slot_changes = dirty => ({});
const get_title_slot_context = ctx => ({});

function create_fragment$f(ctx) {
	let div1;
	let t;
	let div0;
	let div1_class_value;
	let current;
	const title_slot_template = /*#slots*/ ctx[2].title;
	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[1], get_title_slot_context);
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			div1 = element("div");
			if (title_slot) title_slot.c();
			t = space();
			div0 = element("div");
			if (default_slot) default_slot.c();
			attr(div0, "class", "content svelte-12snxhu");
			attr(div1, "class", div1_class_value = "block level" + /*level*/ ctx[0] + " svelte-12snxhu");
		},
		m(target, anchor) {
			insert(target, div1, anchor);

			if (title_slot) {
				title_slot.m(div1, null);
			}

			append(div1, t);
			append(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (title_slot) {
				if (title_slot.p && (!current || dirty & /*$$scope*/ 2)) {
					update_slot_base(
						title_slot,
						title_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
						: get_slot_changes(title_slot_template, /*$$scope*/ ctx[1], dirty, get_title_slot_changes),
						get_title_slot_context
					);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*level*/ 1 && div1_class_value !== (div1_class_value = "block level" + /*level*/ ctx[0] + " svelte-12snxhu")) {
				attr(div1, "class", div1_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(title_slot, local);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(title_slot, local);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div1);
			}

			if (title_slot) title_slot.d(detaching);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { level = 1 } = $$props;

	$$self.$$set = $$props => {
		if ('level' in $$props) $$invalidate(0, level = $$props.level);
		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [level, $$scope, slots];
}

class DebugBlock extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$f, create_fragment$f, safe_not_equal, { level: 0 }, add_css$b);
	}
}

/* src\components\DebugPanel\DebugH2.svelte generated by Svelte v4.2.18 */

function add_css$a(target) {
	append_styles(target, "svelte-cut9yg", "h2.svelte-cut9yg{text-transform:uppercase;font-weight:bold;font-size:0.9rem;color:var(--panel-light-color);padding:var(--panel-vertical-padding) var(--panel-horizontal-padding)}");
}

function create_fragment$e(ctx) {
	let h2;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			h2 = element("h2");
			if (default_slot) default_slot.c();
			attr(h2, "class", "svelte-cut9yg");
		},
		m(target, anchor) {
			insert(target, h2, anchor);

			if (default_slot) {
				default_slot.m(h2, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(h2);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class DebugH2 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$e, create_fragment$e, safe_not_equal, {}, add_css$a);
	}
}

/* src\components\DebugPanel\DebugH3.svelte generated by Svelte v4.2.18 */

function add_css$9(target) {
	append_styles(target, "svelte-3ayulq", "h3.svelte-3ayulq{text-transform:uppercase;font-size:0.8rem;color:var(--panel-medium-color);padding:var(--panel-vertical-padding) var(--panel-horizontal-padding)}h3.svelte-3ayulq:first-child{border-top:none}");
}

function create_fragment$d(ctx) {
	let h3;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			h3 = element("h3");
			if (default_slot) default_slot.c();
			attr(h3, "class", "svelte-3ayulq");
		},
		m(target, anchor) {
			insert(target, h3, anchor);

			if (default_slot) {
				default_slot.m(h3, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(h3);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class DebugH3 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$d, create_fragment$d, safe_not_equal, {}, add_css$9);
	}
}

/* src\components\DebugPanel\DebugNumber.svelte generated by Svelte v4.2.18 */

function add_css$8(target) {
	append_styles(target, "svelte-n3cejh", "div.svelte-n3cejh{flex:1;display:flex;justify-content:center;align-items:center;gap:2px;border-radius:0.3125rem;background-color:var(--panel-dark-color);overflow:hidden;padding:var(--panel-horizontal-padding) var(--panel-vertical-padding)}input[type=\"number\"].svelte-n3cejh{flex:1;color:var(--panel-light-color);background-color:var(--panel-dark-color);font-size:0.8rem;border:none;width:0}span.svelte-n3cejh{flex:0.2;text-transform:capitalize;font-size:0.7rem;color:var(--panel-medium-light-color)}");
}

function create_fragment$c(ctx) {
	let div;
	let span;
	let t0;
	let t1;
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			div = element("div");
			span = element("span");
			t0 = text(/*label*/ ctx[0]);
			t1 = space();
			input = element("input");
			attr(span, "class", "svelte-n3cejh");
			attr(input, "type", "number");
			attr(input, "min", /*min*/ ctx[2]);
			attr(input, "max", /*max*/ ctx[3]);
			attr(input, "step", /*step*/ ctx[4]);
			input.value = /*value*/ ctx[1];
			attr(input, "class", "svelte-n3cejh");
			attr(div, "class", "svelte-n3cejh");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, span);
			append(span, t0);
			append(div, t1);
			append(div, input);

			if (!mounted) {
				dispose = listen(input, "change", /*onChange*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*label*/ 1) set_data(t0, /*label*/ ctx[0]);

			if (dirty & /*min*/ 4) {
				attr(input, "min", /*min*/ ctx[2]);
			}

			if (dirty & /*max*/ 8) {
				attr(input, "max", /*max*/ ctx[3]);
			}

			if (dirty & /*step*/ 16) {
				attr(input, "step", /*step*/ ctx[4]);
			}

			if (dirty & /*value*/ 2 && input.value !== /*value*/ ctx[1]) {
				input.value = /*value*/ ctx[1];
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			mounted = false;
			dispose();
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	let { label } = $$props;
	let { value } = $$props;
	let { min } = $$props;
	let { max } = $$props;
	let { step } = $$props;
	const dispatch = createEventDispatcher();

	function onChange(event) {
		dispatch("change", { number: parseFloat(event.target.value) });
	}

	$$self.$$set = $$props => {
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('value' in $$props) $$invalidate(1, value = $$props.value);
		if ('min' in $$props) $$invalidate(2, min = $$props.min);
		if ('max' in $$props) $$invalidate(3, max = $$props.max);
		if ('step' in $$props) $$invalidate(4, step = $$props.step);
	};

	return [label, value, min, max, step, onChange];
}

class DebugNumber extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$c,
			create_fragment$c,
			safe_not_equal,
			{
				label: 0,
				value: 1,
				min: 2,
				max: 3,
				step: 4
			},
			add_css$8
		);
	}
}

/* src\components\DebugPanel\DebugRow.svelte generated by Svelte v4.2.18 */

function add_css$7(target) {
	append_styles(target, "svelte-1mm3m2h", ".row.svelte-1mm3m2h{width:100%;display:flex;justify-content:center;align-items:center;padding:0px 7px;gap:10px}");
}

function create_fragment$b(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "row svelte-1mm3m2h");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	return [$$scope, slots];
}

class DebugRow extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$b, create_fragment$b, safe_not_equal, {}, add_css$7);
	}
}

/* src\components\DebugPanel\DebugSliderNumber.svelte generated by Svelte v4.2.18 */

function add_css$6(target) {
	append_styles(target, "svelte-16xg45f", "input[type=\"range\"].svelte-16xg45f:focus{outline:none}input[type=\"range\"].svelte-16xg45f{border-radius:5px;height:5px;outline:none;-webkit-appearance:none;appearance:none;flex:1}input[type=\"range\"].svelte-16xg45f::-webkit-slider-runnable-track{height:var(--input-track-size);background-color:var(--panel-dark-color);border-radius:calc(var(--input-track-size) / 2)}input[type=\"range\"].svelte-16xg45f:focus::-webkit-slider-runnable-track{background-color:var(--panel-dark-color)}input[type=\"range\"].svelte-16xg45f::-moz-range-track{height:var(--input-track-size);background-color:var(--panel-dark-color);border-radius:calc(var(--input-track-size) / 2)}input[type=\"range\"].svelte-16xg45f::-webkit-slider-thumb{border-radius:calc(var(--input-thumb-size) / 2);height:var(--input-thumb-size);width:var(--input-thumb-size);background:var(--panel-light-color);cursor:pointer;-webkit-appearance:none;margin-top:calc((var(--input-track-size) - var(--input-thumb-size)) / 2)}input[type=\"range\"].svelte-16xg45f::-moz-range-thumb{border:none;height:var(--input-thumb-size);width:var(--input-thumb-size);border-radius:calc(var(--input-thumb-size) / 2);background:var(--panel-light-color);cursor:pointer}input[type=\"number\"].svelte-16xg45f{flex:0.3;padding:3px 5px;color:var(--panel-light-color);background-color:var(--panel-dark-color);border:none;border-radius:0.3125rem;width:0}");
}

// (16:0) <DebugRow>
function create_default_slot$6(ctx) {
	let input0;
	let t;
	let input1;
	let mounted;
	let dispose;

	return {
		c() {
			input0 = element("input");
			t = space();
			input1 = element("input");
			attr(input0, "type", "range");
			attr(input0, "min", /*min*/ ctx[1]);
			attr(input0, "max", /*max*/ ctx[2]);
			attr(input0, "step", /*step*/ ctx[3]);
			input0.value = /*value*/ ctx[0];
			attr(input0, "class", "svelte-16xg45f");
			attr(input1, "type", "number");
			attr(input1, "min", /*min*/ ctx[1]);
			attr(input1, "max", /*max*/ ctx[2]);
			attr(input1, "step", /*step*/ ctx[3]);
			input1.value = /*value*/ ctx[0];
			attr(input1, "class", "svelte-16xg45f");
		},
		m(target, anchor) {
			insert(target, input0, anchor);
			insert(target, t, anchor);
			insert(target, input1, anchor);

			if (!mounted) {
				dispose = [
					listen(input0, "change", /*onChange*/ ctx[4]),
					listen(input1, "change", /*onChange*/ ctx[4])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*min*/ 2) {
				attr(input0, "min", /*min*/ ctx[1]);
			}

			if (dirty & /*max*/ 4) {
				attr(input0, "max", /*max*/ ctx[2]);
			}

			if (dirty & /*step*/ 8) {
				attr(input0, "step", /*step*/ ctx[3]);
			}

			if (dirty & /*value*/ 1) {
				input0.value = /*value*/ ctx[0];
			}

			if (dirty & /*min*/ 2) {
				attr(input1, "min", /*min*/ ctx[1]);
			}

			if (dirty & /*max*/ 4) {
				attr(input1, "max", /*max*/ ctx[2]);
			}

			if (dirty & /*step*/ 8) {
				attr(input1, "step", /*step*/ ctx[3]);
			}

			if (dirty & /*value*/ 1 && input1.value !== /*value*/ ctx[0]) {
				input1.value = /*value*/ ctx[0];
			}
		},
		d(detaching) {
			if (detaching) {
				detach(input0);
				detach(t);
				detach(input1);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$a(ctx) {
	let debugrow;
	let current;

	debugrow = new DebugRow({
			props: {
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugrow.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugrow, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const debugrow_changes = {};

			if (dirty & /*$$scope, min, max, step, value*/ 79) {
				debugrow_changes.$$scope = { dirty, ctx };
			}

			debugrow.$set(debugrow_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugrow.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugrow.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugrow, detaching);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let { value } = $$props;
	let { min } = $$props;
	let { max } = $$props;
	let { step } = $$props;
	const dispatch = createEventDispatcher();

	function onChange(event) {
		dispatch("change", { number: parseFloat(event.target.value) });
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('min' in $$props) $$invalidate(1, min = $$props.min);
		if ('max' in $$props) $$invalidate(2, max = $$props.max);
		if ('step' in $$props) $$invalidate(3, step = $$props.step);
	};

	return [value, min, max, step, onChange];
}

class DebugSliderNumber extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$a, create_fragment$a, safe_not_equal, { value: 0, min: 1, max: 2, step: 3 }, add_css$6);
	}
}

/* src\components\DebugPanel\DebugH4.svelte generated by Svelte v4.2.18 */

function add_css$5(target) {
	append_styles(target, "svelte-13qcadj", "h4.svelte-13qcadj{text-transform:uppercase;font-size:0.7rem;color:var(--panel-medium-color);padding:calc(var(--panel-horizontal-padding) / 2) 0px calc(var(--panel-horizontal-padding) / 2) 0px;flex:1}.padding0.svelte-13qcadj{padding-left:0px}.padding1.svelte-13qcadj{padding-left:7px}.padding2.svelte-13qcadj{padding-left:14px}.padding3.svelte-13qcadj{padding-left:21px}");
}

function create_fragment$9(ctx) {
	let h4;
	let h4_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	return {
		c() {
			h4 = element("h4");
			if (default_slot) default_slot.c();
			attr(h4, "class", h4_class_value = "" + (null_to_empty("padding" + /*padding*/ ctx[0]) + " svelte-13qcadj"));
		},
		m(target, anchor) {
			insert(target, h4, anchor);

			if (default_slot) {
				default_slot.m(h4, null);
			}

			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*padding*/ 1 && h4_class_value !== (h4_class_value = "" + (null_to_empty("padding" + /*padding*/ ctx[0]) + " svelte-13qcadj"))) {
				attr(h4, "class", h4_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(h4);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { padding = 0 } = $$props;

	$$self.$$set = $$props => {
		if ('padding' in $$props) $$invalidate(0, padding = $$props.padding);
		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	return [padding, $$scope, slots];
}

class DebugH4 extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$9, create_fragment$9, safe_not_equal, { padding: 0 }, add_css$5);
	}
}

/* src\components\DebugPanel\DebugCamera.svelte generated by Svelte v4.2.18 */

function create_default_slot_6$3(ctx) {
	let t;

	return {
		c() {
			t = text("Position");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (56:2) <DebugRow>
function create_default_slot_5$3(ctx) {
	let debugnumber0;
	let t0;
	let debugnumber1;
	let t1;
	let debugnumber2;
	let current;

	debugnumber0 = new DebugNumber({
			props: {
				label: "x",
				value: /*$camera*/ ctx[0].position[0]
			}
		});

	debugnumber0.$on("change", /*onCameraXPositionChange*/ ctx[1]);

	debugnumber1 = new DebugNumber({
			props: {
				label: "y",
				value: /*$camera*/ ctx[0].position[1]
			}
		});

	debugnumber1.$on("change", /*onCameraYPositionChange*/ ctx[2]);

	debugnumber2 = new DebugNumber({
			props: {
				label: "z",
				value: /*$camera*/ ctx[0].position[2]
			}
		});

	debugnumber2.$on("change", /*onCameraZPositionChange*/ ctx[3]);

	return {
		c() {
			create_component(debugnumber0.$$.fragment);
			t0 = space();
			create_component(debugnumber1.$$.fragment);
			t1 = space();
			create_component(debugnumber2.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugnumber0, target, anchor);
			insert(target, t0, anchor);
			mount_component(debugnumber1, target, anchor);
			insert(target, t1, anchor);
			mount_component(debugnumber2, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugnumber0_changes = {};
			if (dirty & /*$camera*/ 1) debugnumber0_changes.value = /*$camera*/ ctx[0].position[0];
			debugnumber0.$set(debugnumber0_changes);
			const debugnumber1_changes = {};
			if (dirty & /*$camera*/ 1) debugnumber1_changes.value = /*$camera*/ ctx[0].position[1];
			debugnumber1.$set(debugnumber1_changes);
			const debugnumber2_changes = {};
			if (dirty & /*$camera*/ 1) debugnumber2_changes.value = /*$camera*/ ctx[0].position[2];
			debugnumber2.$set(debugnumber2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugnumber0.$$.fragment, local);
			transition_in(debugnumber1.$$.fragment, local);
			transition_in(debugnumber2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugnumber0.$$.fragment, local);
			transition_out(debugnumber1.$$.fragment, local);
			transition_out(debugnumber2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
			}

			destroy_component(debugnumber0, detaching);
			destroy_component(debugnumber1, detaching);
			destroy_component(debugnumber2, detaching);
		}
	};
}

// (73:2) <DebugH4 padding="1">
function create_default_slot_4$3(ctx) {
	let t;

	return {
		c() {
			t = text("Target");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (74:2) <DebugRow>
function create_default_slot_3$3(ctx) {
	let debugnumber0;
	let t0;
	let debugnumber1;
	let t1;
	let debugnumber2;
	let current;

	debugnumber0 = new DebugNumber({
			props: {
				label: "x",
				value: /*$camera*/ ctx[0].target[0]
			}
		});

	debugnumber0.$on("change", /*onCameraXTargetChange*/ ctx[4]);

	debugnumber1 = new DebugNumber({
			props: {
				label: "y",
				value: /*$camera*/ ctx[0].target[1]
			}
		});

	debugnumber1.$on("change", /*onCameraYTargetChange*/ ctx[5]);

	debugnumber2 = new DebugNumber({
			props: {
				label: "z",
				value: /*$camera*/ ctx[0].target[2]
			}
		});

	debugnumber2.$on("change", /*onCameraZTargetChange*/ ctx[6]);

	return {
		c() {
			create_component(debugnumber0.$$.fragment);
			t0 = space();
			create_component(debugnumber1.$$.fragment);
			t1 = space();
			create_component(debugnumber2.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugnumber0, target, anchor);
			insert(target, t0, anchor);
			mount_component(debugnumber1, target, anchor);
			insert(target, t1, anchor);
			mount_component(debugnumber2, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugnumber0_changes = {};
			if (dirty & /*$camera*/ 1) debugnumber0_changes.value = /*$camera*/ ctx[0].target[0];
			debugnumber0.$set(debugnumber0_changes);
			const debugnumber1_changes = {};
			if (dirty & /*$camera*/ 1) debugnumber1_changes.value = /*$camera*/ ctx[0].target[1];
			debugnumber1.$set(debugnumber1_changes);
			const debugnumber2_changes = {};
			if (dirty & /*$camera*/ 1) debugnumber2_changes.value = /*$camera*/ ctx[0].target[2];
			debugnumber2.$set(debugnumber2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugnumber0.$$.fragment, local);
			transition_in(debugnumber1.$$.fragment, local);
			transition_in(debugnumber2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugnumber0.$$.fragment, local);
			transition_out(debugnumber1.$$.fragment, local);
			transition_out(debugnumber2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
			}

			destroy_component(debugnumber0, detaching);
			destroy_component(debugnumber1, detaching);
			destroy_component(debugnumber2, detaching);
		}
	};
}

// (91:2) <DebugH4 padding="1">
function create_default_slot_2$4(ctx) {
	let t;

	return {
		c() {
			t = text("FOV");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (53:0) <DebugBlock>
function create_default_slot_1$5(ctx) {
	let debugh40;
	let t0;
	let debugrow0;
	let t1;
	let debugh41;
	let t2;
	let debugrow1;
	let t3;
	let debugh42;
	let t4;
	let debugslidernumber;
	let current;

	debugh40 = new DebugH4({
			props: {
				padding: "1",
				$$slots: { default: [create_default_slot_6$3] },
				$$scope: { ctx }
			}
		});

	debugrow0 = new DebugRow({
			props: {
				$$slots: { default: [create_default_slot_5$3] },
				$$scope: { ctx }
			}
		});

	debugh41 = new DebugH4({
			props: {
				padding: "1",
				$$slots: { default: [create_default_slot_4$3] },
				$$scope: { ctx }
			}
		});

	debugrow1 = new DebugRow({
			props: {
				$$slots: { default: [create_default_slot_3$3] },
				$$scope: { ctx }
			}
		});

	debugh42 = new DebugH4({
			props: {
				padding: "1",
				$$slots: { default: [create_default_slot_2$4] },
				$$scope: { ctx }
			}
		});

	debugslidernumber = new DebugSliderNumber({
			props: {
				min: "0",
				max: "180",
				step: "1",
				value: /*$camera*/ ctx[0].fov
			}
		});

	debugslidernumber.$on("change", /*onCameraFOVChange*/ ctx[7]);

	return {
		c() {
			create_component(debugh40.$$.fragment);
			t0 = space();
			create_component(debugrow0.$$.fragment);
			t1 = space();
			create_component(debugh41.$$.fragment);
			t2 = space();
			create_component(debugrow1.$$.fragment);
			t3 = space();
			create_component(debugh42.$$.fragment);
			t4 = space();
			create_component(debugslidernumber.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh40, target, anchor);
			insert(target, t0, anchor);
			mount_component(debugrow0, target, anchor);
			insert(target, t1, anchor);
			mount_component(debugh41, target, anchor);
			insert(target, t2, anchor);
			mount_component(debugrow1, target, anchor);
			insert(target, t3, anchor);
			mount_component(debugh42, target, anchor);
			insert(target, t4, anchor);
			mount_component(debugslidernumber, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh40_changes = {};

			if (dirty & /*$$scope*/ 256) {
				debugh40_changes.$$scope = { dirty, ctx };
			}

			debugh40.$set(debugh40_changes);
			const debugrow0_changes = {};

			if (dirty & /*$$scope, $camera*/ 257) {
				debugrow0_changes.$$scope = { dirty, ctx };
			}

			debugrow0.$set(debugrow0_changes);
			const debugh41_changes = {};

			if (dirty & /*$$scope*/ 256) {
				debugh41_changes.$$scope = { dirty, ctx };
			}

			debugh41.$set(debugh41_changes);
			const debugrow1_changes = {};

			if (dirty & /*$$scope, $camera*/ 257) {
				debugrow1_changes.$$scope = { dirty, ctx };
			}

			debugrow1.$set(debugrow1_changes);
			const debugh42_changes = {};

			if (dirty & /*$$scope*/ 256) {
				debugh42_changes.$$scope = { dirty, ctx };
			}

			debugh42.$set(debugh42_changes);
			const debugslidernumber_changes = {};
			if (dirty & /*$camera*/ 1) debugslidernumber_changes.value = /*$camera*/ ctx[0].fov;
			debugslidernumber.$set(debugslidernumber_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh40.$$.fragment, local);
			transition_in(debugrow0.$$.fragment, local);
			transition_in(debugh41.$$.fragment, local);
			transition_in(debugrow1.$$.fragment, local);
			transition_in(debugh42.$$.fragment, local);
			transition_in(debugslidernumber.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh40.$$.fragment, local);
			transition_out(debugrow0.$$.fragment, local);
			transition_out(debugh41.$$.fragment, local);
			transition_out(debugrow1.$$.fragment, local);
			transition_out(debugh42.$$.fragment, local);
			transition_out(debugslidernumber.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
				detach(t2);
				detach(t3);
				detach(t4);
			}

			destroy_component(debugh40, detaching);
			destroy_component(debugrow0, detaching);
			destroy_component(debugh41, detaching);
			destroy_component(debugrow1, detaching);
			destroy_component(debugh42, detaching);
			destroy_component(debugslidernumber, detaching);
		}
	};
}

// (54:2) <DebugH2 slot="title">
function create_default_slot$5(ctx) {
	let t;

	return {
		c() {
			t = text("Camera");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (54:2) 
function create_title_slot$4(ctx) {
	let debugh2;
	let current;

	debugh2 = new DebugH2({
			props: {
				slot: "title",
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugh2.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh2, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh2_changes = {};

			if (dirty & /*$$scope*/ 256) {
				debugh2_changes.$$scope = { dirty, ctx };
			}

			debugh2.$set(debugh2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugh2, detaching);
		}
	};
}

function create_fragment$8(ctx) {
	let debugblock;
	let current;

	debugblock = new DebugBlock({
			props: {
				$$slots: {
					title: [create_title_slot$4],
					default: [create_default_slot_1$5]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugblock.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugblock, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const debugblock_changes = {};

			if (dirty & /*$$scope, $camera*/ 257) {
				debugblock_changes.$$scope = { dirty, ctx };
			}

			debugblock.$set(debugblock_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugblock.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugblock.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugblock, detaching);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let $camera;
	component_subscribe($$self, camera, $$value => $$invalidate(0, $camera = $$value));

	function onCameraXPositionChange(e) {
		set_store_value(
			camera,
			$camera = {
				...$camera,
				position: [e.detail.number, $camera.position[1], $camera.position[2]]
			},
			$camera
		);
	}

	function onCameraYPositionChange(e) {
		set_store_value(
			camera,
			$camera = {
				...$camera,
				position: [$camera.position[0], e.detail.number, $camera.position[2]]
			},
			$camera
		);
	}

	function onCameraZPositionChange(e) {
		set_store_value(
			camera,
			$camera = {
				...$camera,
				position: [$camera.position[0], $camera.position[1], e.detail.number]
			},
			$camera
		);
	}

	function onCameraXTargetChange(e) {
		set_store_value(
			camera,
			$camera = {
				...$camera,
				target: [e.detail.number, $camera.target[1], $camera.target[2]]
			},
			$camera
		);
	}

	function onCameraYTargetChange(e) {
		set_store_value(
			camera,
			$camera = {
				...$camera,
				target: [$camera.target[0], e.detail.number, $camera.target[2]]
			},
			$camera
		);
	}

	function onCameraZTargetChange(e) {
		set_store_value(
			camera,
			$camera = {
				...$camera,
				target: [$camera.target[0], $camera.target[1], e.detail.number]
			},
			$camera
		);
	}

	function onCameraFOVChange(e) {
		set_store_value(camera, $camera = { ...$camera, fov: e.detail.number }, $camera);
	}

	return [
		$camera,
		onCameraXPositionChange,
		onCameraYPositionChange,
		onCameraZPositionChange,
		onCameraXTargetChange,
		onCameraYTargetChange,
		onCameraZTargetChange,
		onCameraFOVChange
	];
}

class DebugCamera extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});
	}
}

/* src\components\DebugPanel\DebugColor.svelte generated by Svelte v4.2.18 */

function create_default_slot_1$4(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 1) set_data(t, /*label*/ ctx[0]);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (25:0) <DebugRow>
function create_default_slot$4(ctx) {
	let debugh4;
	let t;
	let input;
	let input_value_value;
	let current;
	let mounted;
	let dispose;

	debugh4 = new DebugH4({
			props: {
				$$slots: { default: [create_default_slot_1$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugh4.$$.fragment);
			t = space();
			input = element("input");
			attr(input, "type", "color");
			input.value = input_value_value = /*convertColor*/ ctx[2](/*color*/ ctx[1]);
		},
		m(target, anchor) {
			mount_component(debugh4, target, anchor);
			insert(target, t, anchor);
			insert(target, input, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(input, "change", /*onChange*/ ctx[3]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			const debugh4_changes = {};

			if (dirty & /*$$scope, label*/ 33) {
				debugh4_changes.$$scope = { dirty, ctx };
			}

			debugh4.$set(debugh4_changes);

			if (!current || dirty & /*color*/ 2 && input_value_value !== (input_value_value = /*convertColor*/ ctx[2](/*color*/ ctx[1]))) {
				input.value = input_value_value;
			}
		},
		i(local) {
			if (current) return;
			transition_in(debugh4.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh4.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
				detach(input);
			}

			destroy_component(debugh4, detaching);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$7(ctx) {
	let debugrow;
	let current;

	debugrow = new DebugRow({
			props: {
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugrow.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugrow, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const debugrow_changes = {};

			if (dirty & /*$$scope, color, label*/ 35) {
				debugrow_changes.$$scope = { dirty, ctx };
			}

			debugrow.$set(debugrow_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugrow.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugrow.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugrow, detaching);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let { label } = $$props;
	let { color } = $$props;

	function convertColor(color) {
		if (typeof color === "number") {
			return hexNumToCSSStringColor(color);
		} else if (Array.isArray(color)) {
			return linearArrayToCSSHashColor(color.slice(0, 3));
		}

		return color;
	}

	const dispatch = createEventDispatcher();

	function onChange(event) {
		dispatch("change", { color: event.target.value });
	}

	$$self.$$set = $$props => {
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('color' in $$props) $$invalidate(1, color = $$props.color);
	};

	return [label, color, convertColor, onChange];
}

class DebugColor extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$7, create_fragment$7, safe_not_equal, { label: 0, color: 1 });
	}
}

/* src\components\DebugPanel\DebugRenderer.svelte generated by Svelte v4.2.18 */

function create_default_slot_2$3(ctx) {
	let t;

	return {
		c() {
			t = text("Ambient Light Intensity");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (46:0) <DebugBlock>
function create_default_slot_1$3(ctx) {
	let debugcolor0;
	let t0;
	let debugcolor1;
	let t1;
	let debugh4;
	let t2;
	let debugslidernumber;
	let current;

	debugcolor0 = new DebugColor({
			props: {
				label: "Background Color",
				color: /*$renderer*/ ctx[0].backgroundColor
			}
		});

	debugcolor0.$on("change", /*onBGColorChange*/ ctx[5]);

	debugcolor1 = new DebugColor({
			props: {
				label: "Ambient Light Color",
				color: /*$renderer*/ ctx[0].ambientLightColor[0]
			}
		});

	debugcolor1.$on("change", /*onAColorChange*/ ctx[6]);

	debugh4 = new DebugH4({
			props: {
				padding: "1",
				$$slots: { default: [create_default_slot_2$3] },
				$$scope: { ctx }
			}
		});

	debugslidernumber = new DebugSliderNumber({
			props: {
				min: /*getRangeMin*/ ctx[1]("ambientIntensity"),
				max: /*getRangeMax*/ ctx[2]("ambientIntensity"),
				step: /*getRangeStep*/ ctx[3]("ambientIntensity"),
				value: /*$renderer*/ ctx[0].ambientLightColor[1]
			}
		});

	debugslidernumber.$on("change", /*onAIntensityChange*/ ctx[4]);

	return {
		c() {
			create_component(debugcolor0.$$.fragment);
			t0 = space();
			create_component(debugcolor1.$$.fragment);
			t1 = space();
			create_component(debugh4.$$.fragment);
			t2 = space();
			create_component(debugslidernumber.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugcolor0, target, anchor);
			insert(target, t0, anchor);
			mount_component(debugcolor1, target, anchor);
			insert(target, t1, anchor);
			mount_component(debugh4, target, anchor);
			insert(target, t2, anchor);
			mount_component(debugslidernumber, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugcolor0_changes = {};
			if (dirty & /*$renderer*/ 1) debugcolor0_changes.color = /*$renderer*/ ctx[0].backgroundColor;
			debugcolor0.$set(debugcolor0_changes);
			const debugcolor1_changes = {};
			if (dirty & /*$renderer*/ 1) debugcolor1_changes.color = /*$renderer*/ ctx[0].ambientLightColor[0];
			debugcolor1.$set(debugcolor1_changes);
			const debugh4_changes = {};

			if (dirty & /*$$scope*/ 256) {
				debugh4_changes.$$scope = { dirty, ctx };
			}

			debugh4.$set(debugh4_changes);
			const debugslidernumber_changes = {};
			if (dirty & /*$renderer*/ 1) debugslidernumber_changes.value = /*$renderer*/ ctx[0].ambientLightColor[1];
			debugslidernumber.$set(debugslidernumber_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugcolor0.$$.fragment, local);
			transition_in(debugcolor1.$$.fragment, local);
			transition_in(debugh4.$$.fragment, local);
			transition_in(debugslidernumber.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugcolor0.$$.fragment, local);
			transition_out(debugcolor1.$$.fragment, local);
			transition_out(debugh4.$$.fragment, local);
			transition_out(debugslidernumber.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
				detach(t2);
			}

			destroy_component(debugcolor0, detaching);
			destroy_component(debugcolor1, detaching);
			destroy_component(debugh4, detaching);
			destroy_component(debugslidernumber, detaching);
		}
	};
}

// (47:2) <DebugH2 slot="title">
function create_default_slot$3(ctx) {
	let t;

	return {
		c() {
			t = text("Renderer");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (47:2) 
function create_title_slot$3(ctx) {
	let debugh2;
	let current;

	debugh2 = new DebugH2({
			props: {
				slot: "title",
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugh2.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh2, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh2_changes = {};

			if (dirty & /*$$scope*/ 256) {
				debugh2_changes.$$scope = { dirty, ctx };
			}

			debugh2.$set(debugh2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugh2, detaching);
		}
	};
}

function create_fragment$6(ctx) {
	let debugblock;
	let current;

	debugblock = new DebugBlock({
			props: {
				$$slots: {
					title: [create_title_slot$3],
					default: [create_default_slot_1$3]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugblock.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugblock, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const debugblock_changes = {};

			if (dirty & /*$$scope, $renderer*/ 257) {
				debugblock_changes.$$scope = { dirty, ctx };
			}

			debugblock.$set(debugblock_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugblock.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugblock.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugblock, detaching);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let $renderer;
	component_subscribe($$self, renderer, $$value => $$invalidate(0, $renderer = $$value));

	const lightPropsRange = {
		intensity: [0, 30],
		ambientIntensity: [0, 1],
		cutoffDistance: [0, 30],
		decayExponent: [0, 5]
	};

	function getRangeMin(key) {
		return lightPropsRange[key][0];
	}

	function getRangeMax(key) {
		return lightPropsRange[key][1];
	}

	function getRangeStep(key) {
		return (lightPropsRange[key][1] - lightPropsRange[key][0]) / 20;
	}

	function onAIntensityChange(e) {
		set_store_value(
			renderer,
			$renderer = {
				...$renderer,
				ambientLightColor: [$renderer.ambientLightColor[0], e.detail.number]
			},
			$renderer
		);
	}

	function onBGColorChange(e) {
		set_store_value(
			renderer,
			$renderer = {
				...$renderer,
				backgroundColor: cssStringColorToHexNum(e.detail.color)
			},
			$renderer
		);
	}

	function onAColorChange(e) {
		set_store_value(
			renderer,
			$renderer = {
				...$renderer,
				ambientLightColor: [cssStringColorToHexNum(e.detail.color), $renderer.ambientLightColor[1]]
			},
			$renderer
		);
	}

	return [
		$renderer,
		getRangeMin,
		getRangeMax,
		getRangeStep,
		onAIntensityChange,
		onBGColorChange,
		onAColorChange
	];
}

class DebugRenderer extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});
	}
}

/* src\components\DebugPanel\DebugCopy.svelte generated by Svelte v4.2.18 */

function add_css$4(target) {
	append_styles(target, "svelte-1hdflge", ".container.svelte-1hdflge{position:relative;width:0.7rem;height:1rem}div.svelte-1hdflge:not(.container){position:absolute;width:0.5rem;height:0.8rem;border-radius:0.1rem}.top.svelte-1hdflge{left:0.2rem;border-top:0.1rem solid var(--panel-medium-light-color);border-right:0.1rem solid var(--panel-medium-light-color)}.bottom.svelte-1hdflge{top:0.2rem;border:0.1rem solid var(--panel-medium-light-color)}");
}

function create_fragment$5(ctx) {
	let div2;
	let mounted;
	let dispose;

	return {
		c() {
			div2 = element("div");
			div2.innerHTML = `<div class="top svelte-1hdflge"></div> <div class="bottom svelte-1hdflge"></div>`;
			attr(div2, "class", "container svelte-1hdflge");
		},
		m(target, anchor) {
			insert(target, div2, anchor);

			if (!mounted) {
				dispose = listen(div2, "click", /*onCopy*/ ctx[0]);
				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(div2);
			}

			mounted = false;
			dispose();
		}
	};
}

function instance$5($$self) {
	const dispatch = createEventDispatcher();

	function onCopy() {
		dispatch("click");
	}

	return [onCopy];
}

class DebugCopy extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$5, create_fragment$5, safe_not_equal, {}, add_css$4);
	}
}

/* src\components\DebugPanel\DebugLights.svelte generated by Svelte v4.2.18 */

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[21] = list[i];
	child_ctx[23] = i;
	return child_ctx;
}

// (95:6) <DebugH4 padding="1">
function create_default_slot_9$1(ctx) {
	let t;

	return {
		c() {
			t = text("Intensity");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (103:6) <DebugH4 padding="1">
function create_default_slot_8$1(ctx) {
	let t;

	return {
		c() {
			t = text("Position");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (104:6) <DebugRow>
function create_default_slot_7$1(ctx) {
	let debugnumber0;
	let t0;
	let debugnumber1;
	let t1;
	let debugnumber2;
	let current;

	function change_handler_2(...args) {
		return /*change_handler_2*/ ctx[15](/*light*/ ctx[21], ...args);
	}

	debugnumber0 = new DebugNumber({
			props: {
				label: "x",
				value: get_store_value(/*light*/ ctx[21]).position[0]
			}
		});

	debugnumber0.$on("change", change_handler_2);

	function change_handler_3(...args) {
		return /*change_handler_3*/ ctx[16](/*light*/ ctx[21], ...args);
	}

	debugnumber1 = new DebugNumber({
			props: {
				label: "y",
				value: get_store_value(/*light*/ ctx[21]).position[1]
			}
		});

	debugnumber1.$on("change", change_handler_3);

	function change_handler_4(...args) {
		return /*change_handler_4*/ ctx[17](/*light*/ ctx[21], ...args);
	}

	debugnumber2 = new DebugNumber({
			props: {
				label: "z",
				value: get_store_value(/*light*/ ctx[21]).position[2]
			}
		});

	debugnumber2.$on("change", change_handler_4);

	return {
		c() {
			create_component(debugnumber0.$$.fragment);
			t0 = space();
			create_component(debugnumber1.$$.fragment);
			t1 = space();
			create_component(debugnumber2.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugnumber0, target, anchor);
			insert(target, t0, anchor);
			mount_component(debugnumber1, target, anchor);
			insert(target, t1, anchor);
			mount_component(debugnumber2, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const debugnumber0_changes = {};
			if (dirty & /*$lights*/ 1) debugnumber0_changes.value = get_store_value(/*light*/ ctx[21]).position[0];
			debugnumber0.$set(debugnumber0_changes);
			const debugnumber1_changes = {};
			if (dirty & /*$lights*/ 1) debugnumber1_changes.value = get_store_value(/*light*/ ctx[21]).position[1];
			debugnumber1.$set(debugnumber1_changes);
			const debugnumber2_changes = {};
			if (dirty & /*$lights*/ 1) debugnumber2_changes.value = get_store_value(/*light*/ ctx[21]).position[2];
			debugnumber2.$set(debugnumber2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugnumber0.$$.fragment, local);
			transition_in(debugnumber1.$$.fragment, local);
			transition_in(debugnumber2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugnumber0.$$.fragment, local);
			transition_out(debugnumber1.$$.fragment, local);
			transition_out(debugnumber2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
			}

			destroy_component(debugnumber0, detaching);
			destroy_component(debugnumber1, detaching);
			destroy_component(debugnumber2, detaching);
		}
	};
}

// (121:6) <DebugH4 padding="1">
function create_default_slot_6$2(ctx) {
	let t;

	return {
		c() {
			t = text("Cutoff Distance");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (129:6) <DebugH4 padding="1">
function create_default_slot_5$2(ctx) {
	let t;

	return {
		c() {
			t = text("Decay Exponent");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (88:4) <DebugBlock level={2}>
function create_default_slot_4$2(ctx) {
	let debugcolor;
	let t0;
	let debugh40;
	let t1;
	let debugslidernumber0;
	let t2;
	let debugh41;
	let t3;
	let debugrow;
	let t4;
	let debugh42;
	let t5;
	let debugslidernumber1;
	let t6;
	let debugh43;
	let t7;
	let debugslidernumber2;
	let t8;
	let current;

	function change_handler(...args) {
		return /*change_handler*/ ctx[13](/*light*/ ctx[21], ...args);
	}

	debugcolor = new DebugColor({
			props: {
				label: "Color",
				color: get_store_value(/*light*/ ctx[21]).color
			}
		});

	debugcolor.$on("change", change_handler);

	debugh40 = new DebugH4({
			props: {
				padding: "1",
				$$slots: { default: [create_default_slot_9$1] },
				$$scope: { ctx }
			}
		});

	function change_handler_1(...args) {
		return /*change_handler_1*/ ctx[14](/*light*/ ctx[21], ...args);
	}

	debugslidernumber0 = new DebugSliderNumber({
			props: {
				min: /*getRangeMin*/ ctx[1]("intensity"),
				max: /*getRangeMax*/ ctx[2]("intensity"),
				step: /*getRangeStep*/ ctx[3]("intensity"),
				value: get_store_value(/*light*/ ctx[21]).intensity
			}
		});

	debugslidernumber0.$on("change", change_handler_1);

	debugh41 = new DebugH4({
			props: {
				padding: "1",
				$$slots: { default: [create_default_slot_8$1] },
				$$scope: { ctx }
			}
		});

	debugrow = new DebugRow({
			props: {
				$$slots: { default: [create_default_slot_7$1] },
				$$scope: { ctx }
			}
		});

	debugh42 = new DebugH4({
			props: {
				padding: "1",
				$$slots: { default: [create_default_slot_6$2] },
				$$scope: { ctx }
			}
		});

	function change_handler_5(...args) {
		return /*change_handler_5*/ ctx[18](/*light*/ ctx[21], ...args);
	}

	debugslidernumber1 = new DebugSliderNumber({
			props: {
				min: /*getRangeMin*/ ctx[1]("cutoffDistance"),
				max: /*getRangeMax*/ ctx[2]("cutoffDistance"),
				step: /*getRangeStep*/ ctx[3]("cutoffDistance"),
				value: get_store_value(/*light*/ ctx[21]).cutoffDistance
			}
		});

	debugslidernumber1.$on("change", change_handler_5);

	debugh43 = new DebugH4({
			props: {
				padding: "1",
				$$slots: { default: [create_default_slot_5$2] },
				$$scope: { ctx }
			}
		});

	function change_handler_6(...args) {
		return /*change_handler_6*/ ctx[19](/*light*/ ctx[21], ...args);
	}

	debugslidernumber2 = new DebugSliderNumber({
			props: {
				min: /*getRangeMin*/ ctx[1]("decayExponent"),
				max: /*getRangeMax*/ ctx[2]("decayExponent"),
				step: /*getRangeStep*/ ctx[3]("decayExponent"),
				value: get_store_value(/*light*/ ctx[21]).decayExponent
			}
		});

	debugslidernumber2.$on("change", change_handler_6);

	return {
		c() {
			create_component(debugcolor.$$.fragment);
			t0 = space();
			create_component(debugh40.$$.fragment);
			t1 = space();
			create_component(debugslidernumber0.$$.fragment);
			t2 = space();
			create_component(debugh41.$$.fragment);
			t3 = space();
			create_component(debugrow.$$.fragment);
			t4 = space();
			create_component(debugh42.$$.fragment);
			t5 = space();
			create_component(debugslidernumber1.$$.fragment);
			t6 = space();
			create_component(debugh43.$$.fragment);
			t7 = space();
			create_component(debugslidernumber2.$$.fragment);
			t8 = space();
		},
		m(target, anchor) {
			mount_component(debugcolor, target, anchor);
			insert(target, t0, anchor);
			mount_component(debugh40, target, anchor);
			insert(target, t1, anchor);
			mount_component(debugslidernumber0, target, anchor);
			insert(target, t2, anchor);
			mount_component(debugh41, target, anchor);
			insert(target, t3, anchor);
			mount_component(debugrow, target, anchor);
			insert(target, t4, anchor);
			mount_component(debugh42, target, anchor);
			insert(target, t5, anchor);
			mount_component(debugslidernumber1, target, anchor);
			insert(target, t6, anchor);
			mount_component(debugh43, target, anchor);
			insert(target, t7, anchor);
			mount_component(debugslidernumber2, target, anchor);
			insert(target, t8, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const debugcolor_changes = {};
			if (dirty & /*$lights*/ 1) debugcolor_changes.color = get_store_value(/*light*/ ctx[21]).color;
			debugcolor.$set(debugcolor_changes);
			const debugh40_changes = {};

			if (dirty & /*$$scope*/ 16777216) {
				debugh40_changes.$$scope = { dirty, ctx };
			}

			debugh40.$set(debugh40_changes);
			const debugslidernumber0_changes = {};
			if (dirty & /*$lights*/ 1) debugslidernumber0_changes.value = get_store_value(/*light*/ ctx[21]).intensity;
			debugslidernumber0.$set(debugslidernumber0_changes);
			const debugh41_changes = {};

			if (dirty & /*$$scope*/ 16777216) {
				debugh41_changes.$$scope = { dirty, ctx };
			}

			debugh41.$set(debugh41_changes);
			const debugrow_changes = {};

			if (dirty & /*$$scope, $lights*/ 16777217) {
				debugrow_changes.$$scope = { dirty, ctx };
			}

			debugrow.$set(debugrow_changes);
			const debugh42_changes = {};

			if (dirty & /*$$scope*/ 16777216) {
				debugh42_changes.$$scope = { dirty, ctx };
			}

			debugh42.$set(debugh42_changes);
			const debugslidernumber1_changes = {};
			if (dirty & /*$lights*/ 1) debugslidernumber1_changes.value = get_store_value(/*light*/ ctx[21]).cutoffDistance;
			debugslidernumber1.$set(debugslidernumber1_changes);
			const debugh43_changes = {};

			if (dirty & /*$$scope*/ 16777216) {
				debugh43_changes.$$scope = { dirty, ctx };
			}

			debugh43.$set(debugh43_changes);
			const debugslidernumber2_changes = {};
			if (dirty & /*$lights*/ 1) debugslidernumber2_changes.value = get_store_value(/*light*/ ctx[21]).decayExponent;
			debugslidernumber2.$set(debugslidernumber2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugcolor.$$.fragment, local);
			transition_in(debugh40.$$.fragment, local);
			transition_in(debugslidernumber0.$$.fragment, local);
			transition_in(debugh41.$$.fragment, local);
			transition_in(debugrow.$$.fragment, local);
			transition_in(debugh42.$$.fragment, local);
			transition_in(debugslidernumber1.$$.fragment, local);
			transition_in(debugh43.$$.fragment, local);
			transition_in(debugslidernumber2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugcolor.$$.fragment, local);
			transition_out(debugh40.$$.fragment, local);
			transition_out(debugslidernumber0.$$.fragment, local);
			transition_out(debugh41.$$.fragment, local);
			transition_out(debugrow.$$.fragment, local);
			transition_out(debugh42.$$.fragment, local);
			transition_out(debugslidernumber1.$$.fragment, local);
			transition_out(debugh43.$$.fragment, local);
			transition_out(debugslidernumber2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
				detach(t2);
				detach(t3);
				detach(t4);
				detach(t5);
				detach(t6);
				detach(t7);
				detach(t8);
			}

			destroy_component(debugcolor, detaching);
			destroy_component(debugh40, detaching);
			destroy_component(debugslidernumber0, detaching);
			destroy_component(debugh41, detaching);
			destroy_component(debugrow, detaching);
			destroy_component(debugh42, detaching);
			destroy_component(debugslidernumber1, detaching);
			destroy_component(debugh43, detaching);
			destroy_component(debugslidernumber2, detaching);
		}
	};
}

// (89:29) <DebugH3 >
function create_default_slot_3$2(ctx) {
	let t0;
	let t1;

	return {
		c() {
			t0 = text("Light ");
			t1 = text(/*i*/ ctx[23]);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
			}
		}
	};
}

// (89:6) <DebugRow slot="title">
function create_default_slot_2$2(ctx) {
	let debugh3;
	let debugcopy;
	let current;

	debugh3 = new DebugH3({
			props: {
				$$slots: { default: [create_default_slot_3$2] },
				$$scope: { ctx }
			}
		});

	function click_handler() {
		return /*click_handler*/ ctx[12](/*light*/ ctx[21]);
	}

	debugcopy = new DebugCopy({});
	debugcopy.$on("click", click_handler);

	return {
		c() {
			create_component(debugh3.$$.fragment);
			create_component(debugcopy.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh3, target, anchor);
			mount_component(debugcopy, target, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			const debugh3_changes = {};

			if (dirty & /*$$scope*/ 16777216) {
				debugh3_changes.$$scope = { dirty, ctx };
			}

			debugh3.$set(debugh3_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh3.$$.fragment, local);
			transition_in(debugcopy.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh3.$$.fragment, local);
			transition_out(debugcopy.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugh3, detaching);
			destroy_component(debugcopy, detaching);
		}
	};
}

// (89:6) 
function create_title_slot_1$2(ctx) {
	let debugrow;
	let current;

	debugrow = new DebugRow({
			props: {
				slot: "title",
				$$slots: { default: [create_default_slot_2$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugrow.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugrow, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugrow_changes = {};

			if (dirty & /*$$scope, $lights*/ 16777217) {
				debugrow_changes.$$scope = { dirty, ctx };
			}

			debugrow.$set(debugrow_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugrow.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugrow.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugrow, detaching);
		}
	};
}

// (87:2) {#each $lights as light, i}
function create_each_block$3(ctx) {
	let debugblock;
	let current;

	debugblock = new DebugBlock({
			props: {
				level: 2,
				$$slots: {
					title: [create_title_slot_1$2],
					default: [create_default_slot_4$2]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugblock.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugblock, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugblock_changes = {};

			if (dirty & /*$$scope, $lights*/ 16777217) {
				debugblock_changes.$$scope = { dirty, ctx };
			}

			debugblock.$set(debugblock_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugblock.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugblock.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugblock, detaching);
		}
	};
}

// (85:0) <DebugBlock>
function create_default_slot_1$2(ctx) {
	let each_1_anchor;
	let current;
	let each_value = ensure_array_like(/*$lights*/ ctx[0]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*onCopy, $lights, getRangeMin, getRangeMax, getRangeStep, onLightDecayExponentChange, onLightCutoffDistanceChange, onLightZChange, onLightYChange, onLightXChange, onLightIntensityChange, onLightColorChange*/ 4095) {
				each_value = ensure_array_like(/*$lights*/ ctx[0]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (86:2) <DebugH2 slot="title">
function create_default_slot$2(ctx) {
	let t;

	return {
		c() {
			t = text("Lights");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (86:2) 
function create_title_slot$2(ctx) {
	let debugh2;
	let current;

	debugh2 = new DebugH2({
			props: {
				slot: "title",
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugh2.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh2, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh2_changes = {};

			if (dirty & /*$$scope*/ 16777216) {
				debugh2_changes.$$scope = { dirty, ctx };
			}

			debugh2.$set(debugh2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugh2, detaching);
		}
	};
}

function create_fragment$4(ctx) {
	let debugblock;
	let current;

	debugblock = new DebugBlock({
			props: {
				$$slots: {
					title: [create_title_slot$2],
					default: [create_default_slot_1$2]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugblock.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugblock, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const debugblock_changes = {};

			if (dirty & /*$$scope, $lights*/ 16777217) {
				debugblock_changes.$$scope = { dirty, ctx };
			}

			debugblock.$set(debugblock_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugblock.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugblock.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugblock, detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let $lights;
	component_subscribe($$self, lights, $$value => $$invalidate(0, $lights = $$value));

	const lightPropsRange = {
		intensity: [0, 30],
		ambientIntensity: [0, 1],
		cutoffDistance: [0, 30],
		decayExponent: [0, 5]
	};

	function getRangeMin(key) {
		return lightPropsRange[key][0];
	}

	function getRangeMax(key) {
		return lightPropsRange[key][1];
	}

	function getRangeStep(key) {
		return (lightPropsRange[key][1] - lightPropsRange[key][0]) / 20;
	}

	function onLightColorChange(e, light) {
		light.set({
			...get_store_value(light),
			color: cssStringColorToLinearArray(e.detail.color)
		});
	}

	function onLightIntensityChange(e, light) {
		light.set({
			...get_store_value(light),
			intensity: e.detail.number
		});
	}

	function onLightXChange(e, light) {
		const lightValue = get_store_value(light);

		light.set({
			...lightValue,
			position: [e.detail.number, lightValue.position[1], lightValue.position[2]]
		});
	}

	function onLightYChange(e, light) {
		const lightValue = get_store_value(light);

		light.set({
			...lightValue,
			position: [lightValue.position[0], e.detail.number, lightValue.position[2]]
		});
	}

	function onLightZChange(e, light) {
		const lightValue = get_store_value(light);

		light.set({
			...lightValue,
			position: [lightValue.position[0], lightValue.position[1], e.detail.number]
		});
	}

	function onLightCutoffDistanceChange(e, light) {
		light.set({
			...get_store_value(light),
			cutoffDistance: e.detail.number
		});
	}

	function onLightDecayExponentChange(e, light) {
		light.set({
			...get_store_value(light),
			decayExponent: e.detail.number
		});
	}

	function onCopy(light) {
		const { color, intensity, position, cutoffDistance, decayExponent } = get_store_value(light);

		const lightData = {
			color,
			intensity,
			position,
			cutoffDistance,
			decayExponent
		};

		navigator.clipboard.writeText(JSON.stringify(lightData, null, 2));
	}

	const click_handler = light => onCopy(light);
	const change_handler = (light, e) => onLightColorChange(e, light);
	const change_handler_1 = (light, e) => onLightIntensityChange(e, light);
	const change_handler_2 = (light, e) => onLightXChange(e, light);
	const change_handler_3 = (light, e) => onLightYChange(e, light);
	const change_handler_4 = (light, e) => onLightZChange(e, light);
	const change_handler_5 = (light, e) => onLightCutoffDistanceChange(e, light);
	const change_handler_6 = (light, e) => onLightDecayExponentChange(e, light);

	return [
		$lights,
		getRangeMin,
		getRangeMax,
		getRangeStep,
		onLightColorChange,
		onLightIntensityChange,
		onLightXChange,
		onLightYChange,
		onLightZChange,
		onLightCutoffDistanceChange,
		onLightDecayExponentChange,
		onCopy,
		click_handler,
		change_handler,
		change_handler_1,
		change_handler_2,
		change_handler_3,
		change_handler_4,
		change_handler_5,
		change_handler_6
	];
}

class DebugLights extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});
	}
}

/* src\components\DebugPanel\DebugMaterial.svelte generated by Svelte v4.2.18 */

function add_css$3(target) {
	append_styles(target, "svelte-138lyw9", "a.svelte-138lyw9{color:var(--panel-light-color);padding:0px 7px}");
}

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i][0];
	child_ctx[7] = list[i][1];
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i][0];
	child_ctx[11] = list[i][1];
	return child_ctx;
}

// (49:44) 
function create_if_block_3(ctx) {
	let debugblock;
	let current;

	debugblock = new DebugBlock({
			props: {
				level: 4,
				$$slots: {
					title: [create_title_slot_1$1],
					default: [create_default_slot_5$1]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugblock.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugblock, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugblock_changes = {};

			if (dirty & /*$$scope, material*/ 16385) {
				debugblock_changes.$$scope = { dirty, ctx };
			}

			debugblock.$set(debugblock_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugblock.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugblock.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugblock, detaching);
		}
	};
}

// (41:40) 
function create_if_block_2$1(ctx) {
	let debugh4;
	let t;
	let debugslidernumber;
	let current;

	debugh4 = new DebugH4({
			props: {
				padding: "1",
				$$slots: { default: [create_default_slot_3$1] },
				$$scope: { ctx }
			}
		});

	debugslidernumber = new DebugSliderNumber({
			props: {
				min: /*getRangeMin*/ ctx[2](/*key*/ ctx[6]),
				max: /*getRangeMax*/ ctx[3](/*key*/ ctx[6]),
				step: /*getRangeStep*/ ctx[4](/*key*/ ctx[6]),
				value: /*value*/ ctx[7]
			}
		});

	return {
		c() {
			create_component(debugh4.$$.fragment);
			t = space();
			create_component(debugslidernumber.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh4, target, anchor);
			insert(target, t, anchor);
			mount_component(debugslidernumber, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh4_changes = {};

			if (dirty & /*$$scope, material*/ 16385) {
				debugh4_changes.$$scope = { dirty, ctx };
			}

			debugh4.$set(debugh4_changes);
			const debugslidernumber_changes = {};
			if (dirty & /*material*/ 1) debugslidernumber_changes.min = /*getRangeMin*/ ctx[2](/*key*/ ctx[6]);
			if (dirty & /*material*/ 1) debugslidernumber_changes.max = /*getRangeMax*/ ctx[3](/*key*/ ctx[6]);
			if (dirty & /*material*/ 1) debugslidernumber_changes.step = /*getRangeStep*/ ctx[4](/*key*/ ctx[6]);
			if (dirty & /*material*/ 1) debugslidernumber_changes.value = /*value*/ ctx[7];
			debugslidernumber.$set(debugslidernumber_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh4.$$.fragment, local);
			transition_in(debugslidernumber.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh4.$$.fragment, local);
			transition_out(debugslidernumber.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}

			destroy_component(debugh4, detaching);
			destroy_component(debugslidernumber, detaching);
		}
	};
}

// (39:48) 
function create_if_block_1$1(ctx) {
	let debugcolor;
	let current;

	debugcolor = new DebugColor({
			props: {
				label: /*key*/ ctx[6],
				color: /*value*/ ctx[7]
			}
		});

	return {
		c() {
			create_component(debugcolor.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugcolor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugcolor_changes = {};
			if (dirty & /*material*/ 1) debugcolor_changes.label = /*key*/ ctx[6];
			if (dirty & /*material*/ 1) debugcolor_changes.color = /*value*/ ctx[7];
			debugcolor.$set(debugcolor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugcolor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugcolor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugcolor, detaching);
		}
	};
}

// (36:4) {#if key.includes("Map")}
function create_if_block$1(ctx) {
	let debugh4;
	let t0;
	let a;
	let t1_value = getFileName(/*value*/ ctx[7].url) + "";
	let t1;
	let a_href_value;
	let current;

	debugh4 = new DebugH4({
			props: {
				padding: "1",
				$$slots: { default: [create_default_slot_2$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugh4.$$.fragment);
			t0 = space();
			a = element("a");
			t1 = text(t1_value);
			attr(a, "href", a_href_value = "./" + /*value*/ ctx[7].url);
			attr(a, "class", "svelte-138lyw9");
		},
		m(target, anchor) {
			mount_component(debugh4, target, anchor);
			insert(target, t0, anchor);
			insert(target, a, anchor);
			append(a, t1);
			current = true;
		},
		p(ctx, dirty) {
			const debugh4_changes = {};

			if (dirty & /*$$scope, material*/ 16385) {
				debugh4_changes.$$scope = { dirty, ctx };
			}

			debugh4.$set(debugh4_changes);
			if ((!current || dirty & /*material*/ 1) && t1_value !== (t1_value = getFileName(/*value*/ ctx[7].url) + "")) set_data(t1, t1_value);

			if (!current || dirty & /*material*/ 1 && a_href_value !== (a_href_value = "./" + /*value*/ ctx[7].url)) {
				attr(a, "href", a_href_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(debugh4.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh4.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(a);
			}

			destroy_component(debugh4, detaching);
		}
	};
}

// (61:55) 
function create_if_block_5(ctx) {
	let debugcolor;
	let current;

	debugcolor = new DebugColor({
			props: {
				label: /*k*/ ctx[10],
				color: /*v*/ ctx[11]
			}
		});

	return {
		c() {
			create_component(debugcolor.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugcolor, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugcolor_changes = {};
			if (dirty & /*material*/ 1) debugcolor_changes.label = /*k*/ ctx[10];
			if (dirty & /*material*/ 1) debugcolor_changes.color = /*v*/ ctx[11];
			debugcolor.$set(debugcolor_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugcolor.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugcolor.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugcolor, detaching);
		}
	};
}

// (53:10) {#if typeof v === "number"}
function create_if_block_4(ctx) {
	let debugh4;
	let t;
	let debugslidernumber;
	let current;

	debugh4 = new DebugH4({
			props: {
				padding: "1",
				$$slots: { default: [create_default_slot_6$1] },
				$$scope: { ctx }
			}
		});

	debugslidernumber = new DebugSliderNumber({
			props: {
				min: /*getRangeMin*/ ctx[2](/*k*/ ctx[10]),
				max: /*getRangeMax*/ ctx[3](/*k*/ ctx[10]),
				step: /*getRangeStep*/ ctx[4](/*k*/ ctx[10]),
				value: /*v*/ ctx[11]
			}
		});

	return {
		c() {
			create_component(debugh4.$$.fragment);
			t = space();
			create_component(debugslidernumber.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh4, target, anchor);
			insert(target, t, anchor);
			mount_component(debugslidernumber, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh4_changes = {};

			if (dirty & /*$$scope, material*/ 16385) {
				debugh4_changes.$$scope = { dirty, ctx };
			}

			debugh4.$set(debugh4_changes);
			const debugslidernumber_changes = {};
			if (dirty & /*material*/ 1) debugslidernumber_changes.min = /*getRangeMin*/ ctx[2](/*k*/ ctx[10]);
			if (dirty & /*material*/ 1) debugslidernumber_changes.max = /*getRangeMax*/ ctx[3](/*k*/ ctx[10]);
			if (dirty & /*material*/ 1) debugslidernumber_changes.step = /*getRangeStep*/ ctx[4](/*k*/ ctx[10]);
			if (dirty & /*material*/ 1) debugslidernumber_changes.value = /*v*/ ctx[11];
			debugslidernumber.$set(debugslidernumber_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh4.$$.fragment, local);
			transition_in(debugslidernumber.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh4.$$.fragment, local);
			transition_out(debugslidernumber.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}

			destroy_component(debugh4, detaching);
			destroy_component(debugslidernumber, detaching);
		}
	};
}

// (54:12) <DebugH4 padding="1">
function create_default_slot_6$1(ctx) {
	let t_value = /*k*/ ctx[10] + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*material*/ 1 && t_value !== (t_value = /*k*/ ctx[10] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (52:8) {#each Object.entries(value).filter((p) => !(typeof p[1] === "function")) as [k, v]}
function create_each_block_1$1(ctx) {
	let show_if;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_4, create_if_block_5];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (dirty & /*material*/ 1) show_if = null;
		if (typeof /*v*/ ctx[11] === "number") return 0;
		if (show_if == null) show_if = !!(Array.isArray(/*v*/ ctx[11]) && /*v*/ ctx[11].length === 3);
		if (show_if) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}
		}
	};
}

// (50:6) <DebugBlock level={4}>
function create_default_slot_5$1(ctx) {
	let t;
	let current;
	let each_value_1 = ensure_array_like(Object.entries(/*value*/ ctx[7]).filter(func_1));
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, t, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*getRangeMin, Object, material, getRangeMax, getRangeStep, Array*/ 29) {
				each_value_1 = ensure_array_like(Object.entries(/*value*/ ctx[7]).filter(func_1));
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(t.parentNode, t);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (51:8) <DebugH4 slot="title">
function create_default_slot_4$1(ctx) {
	let t_value = /*key*/ ctx[6] + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*material*/ 1 && t_value !== (t_value = /*key*/ ctx[6] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (51:8) 
function create_title_slot_1$1(ctx) {
	let debugh4;
	let current;

	debugh4 = new DebugH4({
			props: {
				slot: "title",
				$$slots: { default: [create_default_slot_4$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugh4.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh4, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh4_changes = {};

			if (dirty & /*$$scope, material*/ 16385) {
				debugh4_changes.$$scope = { dirty, ctx };
			}

			debugh4.$set(debugh4_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh4.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh4.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugh4, detaching);
		}
	};
}

// (42:6) <DebugH4 padding="1">
function create_default_slot_3$1(ctx) {
	let t_value = /*key*/ ctx[6] + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*material*/ 1 && t_value !== (t_value = /*key*/ ctx[6] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (37:6) <DebugH4 padding="1">
function create_default_slot_2$1(ctx) {
	let t_value = /*key*/ ctx[6] + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*material*/ 1 && t_value !== (t_value = /*key*/ ctx[6] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (35:2) {#each Object.entries(get(material)) as [key, value]}
function create_each_block$2(ctx) {
	let show_if;
	let show_if_1;
	let show_if_2;
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;

	function func(...args) {
		return /*func*/ ctx[5](/*key*/ ctx[6], ...args);
	}

	const if_block_creators = [create_if_block$1, create_if_block_1$1, create_if_block_2$1, create_if_block_3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (dirty & /*material*/ 1) show_if = null;
		if (dirty & /*material*/ 1) show_if_1 = null;
		if (dirty & /*material*/ 1) show_if_2 = null;
		if (show_if == null) show_if = !!/*key*/ ctx[6].includes("Map");
		if (show_if) return 0;
		if (show_if_1 == null) show_if_1 = !!colorProps.some(func);
		if (show_if_1) return 1;
		if (/*key*/ ctx[6] in /*materialPropsRange*/ ctx[1]) return 2;
		if (show_if_2 == null) show_if_2 = !!(Object.keys(/*value*/ ctx[7]).length > 0);
		if (show_if_2) return 3;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx, -1))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}
		}
	};
}

// (33:0) <DebugBlock level={3}>
function create_default_slot_1$1(ctx) {
	let each_1_anchor;
	let current;
	let each_value = ensure_array_like(Object.entries(get_store_value(/*material*/ ctx[0])));
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*Object, material, getFileName, getRangeMin, getRangeMax, getRangeStep, materialPropsRange, Array*/ 31) {
				each_value = ensure_array_like(Object.entries(get_store_value(/*material*/ ctx[0])));
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (34:2) <DebugH4 slot="title">
function create_default_slot$1(ctx) {
	let t;

	return {
		c() {
			t = text("Material");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (34:2) 
function create_title_slot$1(ctx) {
	let debugh4;
	let current;

	debugh4 = new DebugH4({
			props: {
				slot: "title",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugh4.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh4, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh4_changes = {};

			if (dirty & /*$$scope*/ 16384) {
				debugh4_changes.$$scope = { dirty, ctx };
			}

			debugh4.$set(debugh4_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh4.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh4.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugh4, detaching);
		}
	};
}

function create_fragment$3(ctx) {
	let debugblock;
	let current;

	debugblock = new DebugBlock({
			props: {
				level: 3,
				$$slots: {
					title: [create_title_slot$1],
					default: [create_default_slot_1$1]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugblock.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugblock, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const debugblock_changes = {};

			if (dirty & /*$$scope, material*/ 16385) {
				debugblock_changes.$$scope = { dirty, ctx };
			}

			debugblock.$set(debugblock_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugblock.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugblock.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugblock, detaching);
		}
	};
}

function getFileName(url) {
	return url.split("/").pop();
}

const func_1 = p => !(typeof p[1] === "function");

function instance$3($$self, $$props, $$invalidate) {
	const materialPropsRange = {
		opacity: [0, 1],
		roughness: [0, 1],
		metalness: [0, 1],
		ior: [0, 2],
		intensity: [0, 30]
	};

	function getRangeMin(key) {
		return materialPropsRange[key][0];
	}

	function getRangeMax(key) {
		return materialPropsRange[key][1];
	}

	function getRangeStep(key) {
		return (materialPropsRange[key][1] - materialPropsRange[key][0]) / 20;
	}

	let { material } = $$props;
	const func = (key, c) => c === key;

	$$self.$$set = $$props => {
		if ('material' in $$props) $$invalidate(0, material = $$props.material);
	};

	return [material, materialPropsRange, getRangeMin, getRangeMax, getRangeStep, func];
}

class DebugMaterial extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$3, create_fragment$3, safe_not_equal, { material: 0 }, add_css$3);
	}
}

/* src\components\DebugPanel\DebugMatrix.svelte generated by Svelte v4.2.18 */

function add_css$2(target) {
	append_styles(target, "svelte-16sh817", "div.svelte-16sh817{display:grid;grid-template-columns:repeat(4, 1fr);gap:5px;padding:5px 40px}span.svelte-16sh817{font-size:0.8rem;color:var(--panel-light-color);background:var(--panel-dark-color);padding:var(--panel-horizontal-padding) var(--panel-vertical-padding);border-radius:0.3125rem;max-width:3rem;overflow:hidden;white-space:nowrap}");
}

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i];
	return child_ctx;
}

// (8:2) {#each matrix as num}
function create_each_block$1(ctx) {
	let span;
	let t_value = /*num*/ ctx[1] + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
			attr(span, "class", "svelte-16sh817");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*matrix*/ 1 && t_value !== (t_value = /*num*/ ctx[1] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

function create_fragment$2(ctx) {
	let div;
	let each_value = ensure_array_like(/*matrix*/ ctx[0]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "svelte-16sh817");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*matrix*/ 1) {
				each_value = ensure_array_like(/*matrix*/ ctx[0]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { matrix } = $$props;

	$$self.$$set = $$props => {
		if ('matrix' in $$props) $$invalidate(0, matrix = $$props.matrix);
	};

	return [matrix];
}

class DebugMatrix extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { matrix: 0 }, add_css$2);
	}
}

/* src\components\DebugPanel\DebugMeshes.svelte generated by Svelte v4.2.18 */

function add_css$1(target) {
	append_styles(target, "svelte-1qktr34", "span.svelte-1qktr34{padding:0px 7px}");
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i].attributes;
	child_ctx[2] = list[i].drawMode;
	child_ctx[3] = list[i].matrix;
	child_ctx[4] = list[i].matrices;
	child_ctx[5] = list[i].material;
	child_ctx[6] = list[i].instances;
	child_ctx[8] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[3] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i][0];
	child_ctx[12] = list[i][1];
	return child_ctx;
}

// (20:8) {#each Object.entries(attributes) as [key, value]}
function create_each_block_2(ctx) {
	let span;
	let t0_value = /*key*/ ctx[11] + "";
	let t0;
	let t1;
	let t2_value = /*value*/ ctx[12].length + "";
	let t2;

	return {
		c() {
			span = element("span");
			t0 = text(t0_value);
			t1 = text(": ");
			t2 = text(t2_value);
			attr(span, "class", "svelte-1qktr34");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
			append(span, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*$meshes*/ 1 && t0_value !== (t0_value = /*key*/ ctx[11] + "")) set_data(t0, t0_value);
			if (dirty & /*$meshes*/ 1 && t2_value !== (t2_value = /*value*/ ctx[12].length + "")) set_data(t2, t2_value);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (18:6) <DebugBlock level={3}>
function create_default_slot_13(ctx) {
	let each_1_anchor;
	let each_value_2 = ensure_array_like(Object.entries(/*attributes*/ ctx[1]));
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*Object, $meshes*/ 1) {
				each_value_2 = ensure_array_like(Object.entries(/*attributes*/ ctx[1]));
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (19:8) <DebugH4 slot="title">
function create_default_slot_12(ctx) {
	let t;

	return {
		c() {
			t = text("Attributes");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (19:8) 
function create_title_slot_6(ctx) {
	let debugh4;
	let current;

	debugh4 = new DebugH4({
			props: {
				slot: "title",
				$$slots: { default: [create_default_slot_12] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugh4.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh4, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh4_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				debugh4_changes.$$scope = { dirty, ctx };
			}

			debugh4.$set(debugh4_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh4.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh4.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugh4, detaching);
		}
	};
}

// (24:6) <DebugBlock level={3}>
function create_default_slot_11(ctx) {
	let span;
	let t_value = /*drawMode*/ ctx[2] + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
			attr(span, "class", "svelte-1qktr34");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$meshes*/ 1 && t_value !== (t_value = /*drawMode*/ ctx[2] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (25:8) <DebugH4 slot="title">
function create_default_slot_10(ctx) {
	let t;

	return {
		c() {
			t = text("Draw Mode");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (25:8) 
function create_title_slot_5(ctx) {
	let debugh4;
	let current;

	debugh4 = new DebugH4({
			props: {
				slot: "title",
				$$slots: { default: [create_default_slot_10] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugh4.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh4, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh4_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				debugh4_changes.$$scope = { dirty, ctx };
			}

			debugh4.$set(debugh4_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh4.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh4.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugh4, detaching);
		}
	};
}

// (28:6) {#if instances}
function create_if_block_2(ctx) {
	let debugblock;
	let current;

	debugblock = new DebugBlock({
			props: {
				level: 3,
				$$slots: {
					title: [create_title_slot_4],
					default: [create_default_slot_9]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugblock.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugblock, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugblock_changes = {};

			if (dirty & /*$$scope, $meshes*/ 32769) {
				debugblock_changes.$$scope = { dirty, ctx };
			}

			debugblock.$set(debugblock_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugblock.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugblock.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugblock, detaching);
		}
	};
}

// (29:6) <DebugBlock level={3}>
function create_default_slot_9(ctx) {
	let span;
	let t_value = /*instances*/ ctx[6] + "";
	let t;

	return {
		c() {
			span = element("span");
			t = text(t_value);
			attr(span, "class", "svelte-1qktr34");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*$meshes*/ 1 && t_value !== (t_value = /*instances*/ ctx[6] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (30:8) <DebugH4 slot="title">
function create_default_slot_8(ctx) {
	let t;

	return {
		c() {
			t = text("Instances");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (30:8) 
function create_title_slot_4(ctx) {
	let debugh4;
	let current;

	debugh4 = new DebugH4({
			props: {
				slot: "title",
				$$slots: { default: [create_default_slot_8] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugh4.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh4, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh4_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				debugh4_changes.$$scope = { dirty, ctx };
			}

			debugh4.$set(debugh4_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh4.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh4.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugh4, detaching);
		}
	};
}

// (39:25) 
function create_if_block_1(ctx) {
	let debugblock;
	let current;

	debugblock = new DebugBlock({
			props: {
				level: 3,
				$$slots: {
					title: [create_title_slot_3],
					default: [create_default_slot_7]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugblock.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugblock, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugblock_changes = {};

			if (dirty & /*$$scope, $meshes*/ 32769) {
				debugblock_changes.$$scope = { dirty, ctx };
			}

			debugblock.$set(debugblock_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugblock.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugblock.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugblock, detaching);
		}
	};
}

// (34:6) {#if matrix}
function create_if_block(ctx) {
	let debugblock;
	let current;

	debugblock = new DebugBlock({
			props: {
				level: 3,
				$$slots: {
					title: [create_title_slot_2],
					default: [create_default_slot_5]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugblock.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugblock, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugblock_changes = {};

			if (dirty & /*$$scope, $meshes*/ 32769) {
				debugblock_changes.$$scope = { dirty, ctx };
			}

			debugblock.$set(debugblock_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugblock.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugblock.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugblock, detaching);
		}
	};
}

// (42:8) {#each matrices as matrix}
function create_each_block_1(ctx) {
	let debugmatrix;
	let current;

	debugmatrix = new DebugMatrix({
			props: { matrix: get_store_value(/*matrix*/ ctx[3]) }
		});

	return {
		c() {
			create_component(debugmatrix.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugmatrix, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugmatrix_changes = {};
			if (dirty & /*$meshes*/ 1) debugmatrix_changes.matrix = get_store_value(/*matrix*/ ctx[3]);
			debugmatrix.$set(debugmatrix_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugmatrix.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugmatrix.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugmatrix, detaching);
		}
	};
}

// (40:6) <DebugBlock level={3}>
function create_default_slot_7(ctx) {
	let each_1_anchor;
	let current;
	let each_value_1 = ensure_array_like(/*matrices*/ ctx[4]);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*$meshes*/ 1) {
				each_value_1 = ensure_array_like(/*matrices*/ ctx[4]);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (41:8) <DebugH4 slot="title">
function create_default_slot_6(ctx) {
	let t;

	return {
		c() {
			t = text("Matrices");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (41:8) 
function create_title_slot_3(ctx) {
	let debugh4;
	let current;

	debugh4 = new DebugH4({
			props: {
				slot: "title",
				$$slots: { default: [create_default_slot_6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugh4.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh4, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh4_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				debugh4_changes.$$scope = { dirty, ctx };
			}

			debugh4.$set(debugh4_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh4.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh4.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugh4, detaching);
		}
	};
}

// (35:6) <DebugBlock level={3}>
function create_default_slot_5(ctx) {
	let debugmatrix;
	let current;

	debugmatrix = new DebugMatrix({
			props: { matrix: get_store_value(/*matrix*/ ctx[3]) }
		});

	return {
		c() {
			create_component(debugmatrix.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugmatrix, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugmatrix_changes = {};
			if (dirty & /*$meshes*/ 1) debugmatrix_changes.matrix = get_store_value(/*matrix*/ ctx[3]);
			debugmatrix.$set(debugmatrix_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugmatrix.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugmatrix.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugmatrix, detaching);
		}
	};
}

// (36:8) <DebugH4 slot="title">
function create_default_slot_4(ctx) {
	let t;

	return {
		c() {
			t = text("Matrix");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (36:8) 
function create_title_slot_2(ctx) {
	let debugh4;
	let current;

	debugh4 = new DebugH4({
			props: {
				slot: "title",
				$$slots: { default: [create_default_slot_4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugh4.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh4, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh4_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				debugh4_changes.$$scope = { dirty, ctx };
			}

			debugh4.$set(debugh4_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh4.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh4.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugh4, detaching);
		}
	};
}

// (16:4) <DebugBlock level={2}>
function create_default_slot_3(ctx) {
	let debugblock0;
	let t0;
	let debugblock1;
	let t1;
	let t2;
	let current_block_type_index;
	let if_block1;
	let t3;
	let debugmaterial;
	let t4;
	let current;

	debugblock0 = new DebugBlock({
			props: {
				level: 3,
				$$slots: {
					title: [create_title_slot_6],
					default: [create_default_slot_13]
				},
				$$scope: { ctx }
			}
		});

	debugblock1 = new DebugBlock({
			props: {
				level: 3,
				$$slots: {
					title: [create_title_slot_5],
					default: [create_default_slot_11]
				},
				$$scope: { ctx }
			}
		});

	let if_block0 = /*instances*/ ctx[6] && create_if_block_2(ctx);
	const if_block_creators = [create_if_block, create_if_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*matrix*/ ctx[3]) return 0;
		if (/*matrices*/ ctx[4]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	debugmaterial = new DebugMaterial({ props: { material: /*material*/ ctx[5] } });

	return {
		c() {
			create_component(debugblock0.$$.fragment);
			t0 = space();
			create_component(debugblock1.$$.fragment);
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			create_component(debugmaterial.$$.fragment);
			t4 = space();
		},
		m(target, anchor) {
			mount_component(debugblock0, target, anchor);
			insert(target, t0, anchor);
			mount_component(debugblock1, target, anchor);
			insert(target, t1, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t2, anchor);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, t3, anchor);
			mount_component(debugmaterial, target, anchor);
			insert(target, t4, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugblock0_changes = {};

			if (dirty & /*$$scope, $meshes*/ 32769) {
				debugblock0_changes.$$scope = { dirty, ctx };
			}

			debugblock0.$set(debugblock0_changes);
			const debugblock1_changes = {};

			if (dirty & /*$$scope, $meshes*/ 32769) {
				debugblock1_changes.$$scope = { dirty, ctx };
			}

			debugblock1.$set(debugblock1_changes);

			if (/*instances*/ ctx[6]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$meshes*/ 1) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t2.parentNode, t2);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block1) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(t3.parentNode, t3);
				} else {
					if_block1 = null;
				}
			}

			const debugmaterial_changes = {};
			if (dirty & /*$meshes*/ 1) debugmaterial_changes.material = /*material*/ ctx[5];
			debugmaterial.$set(debugmaterial_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugblock0.$$.fragment, local);
			transition_in(debugblock1.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(debugmaterial.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugblock0.$$.fragment, local);
			transition_out(debugblock1.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(debugmaterial.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
				detach(t2);
				detach(t3);
				detach(t4);
			}

			destroy_component(debugblock0, detaching);
			destroy_component(debugblock1, detaching);
			if (if_block0) if_block0.d(detaching);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			destroy_component(debugmaterial, detaching);
		}
	};
}

// (17:6) <DebugH3 slot="title">
function create_default_slot_2(ctx) {
	let t0;
	let t1;

	return {
		c() {
			t0 = text("Mesh ");
			t1 = text(/*i*/ ctx[8]);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, t1, anchor);
		},
		p: noop,
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
			}
		}
	};
}

// (17:6) 
function create_title_slot_1(ctx) {
	let debugh3;
	let current;

	debugh3 = new DebugH3({
			props: {
				slot: "title",
				$$slots: { default: [create_default_slot_2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugh3.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh3, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh3_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				debugh3_changes.$$scope = { dirty, ctx };
			}

			debugh3.$set(debugh3_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh3.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh3.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugh3, detaching);
		}
	};
}

// (15:2) {#each $meshes as { attributes, drawMode, matrix,matrices, material,instances }
function create_each_block(ctx) {
	let debugblock;
	let current;

	debugblock = new DebugBlock({
			props: {
				level: 2,
				$$slots: {
					title: [create_title_slot_1],
					default: [create_default_slot_3]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugblock.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugblock, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugblock_changes = {};

			if (dirty & /*$$scope, $meshes*/ 32769) {
				debugblock_changes.$$scope = { dirty, ctx };
			}

			debugblock.$set(debugblock_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugblock.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugblock.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugblock, detaching);
		}
	};
}

// (13:0) <DebugBlock>
function create_default_slot_1(ctx) {
	let each_1_anchor;
	let current;
	let each_value = ensure_array_like(/*$meshes*/ ctx[0]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*$meshes, Object*/ 1) {
				each_value = ensure_array_like(/*$meshes*/ ctx[0]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

// (14:2) <DebugH2 slot="title">
function create_default_slot(ctx) {
	let t;

	return {
		c() {
			t = text("Meshes");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (14:2) 
function create_title_slot(ctx) {
	let debugh2;
	let current;

	debugh2 = new DebugH2({
			props: {
				slot: "title",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugh2.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugh2, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const debugh2_changes = {};

			if (dirty & /*$$scope*/ 32768) {
				debugh2_changes.$$scope = { dirty, ctx };
			}

			debugh2.$set(debugh2_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugh2.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugh2.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugh2, detaching);
		}
	};
}

function create_fragment$1(ctx) {
	let debugblock;
	let current;

	debugblock = new DebugBlock({
			props: {
				$$slots: {
					title: [create_title_slot],
					default: [create_default_slot_1]
				},
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(debugblock.$$.fragment);
		},
		m(target, anchor) {
			mount_component(debugblock, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const debugblock_changes = {};

			if (dirty & /*$$scope, $meshes*/ 32769) {
				debugblock_changes.$$scope = { dirty, ctx };
			}

			debugblock.$set(debugblock_changes);
		},
		i(local) {
			if (current) return;
			transition_in(debugblock.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugblock.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(debugblock, detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let $meshes;
	component_subscribe($$self, meshes, $$value => $$invalidate(0, $meshes = $$value));
	return [$meshes];
}

class DebugMeshes extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {}, add_css$1);
	}
}

/* src\components\DebugPanel\DebugPanel.svelte generated by Svelte v4.2.18 */

function add_css(target) {
	append_styles(target, "svelte-5opaaz", ".panel.svelte-5opaaz{font-family:Arial, sans-serif;position:absolute;top:0;right:0;width:350px;height:100%;overflow-y:auto;color:white;background-color:var(--panel-darkest-color);--input-thumb-color:#cfcfcf;--input-track-color:#393939;--input-thumb-size:16px;--input-track-size:8px;--panel-darkest-color:#252525;--panel-dark-color:#393939;--panel-medium-color:#777777;--panel-medium-light-color:#b7b7b7;--panel-light-color:#cfcfcf;--panel-vertical-padding:7px;--panel-horizontal-padding:5px}.panelContent.svelte-5opaaz{display:flex;flex-direction:column;justify-content:center;align-items:left;gap:0px;margin:50px 0px 20px 0px}.collapsed.svelte-5opaaz{display:none !important}.collapseButton.svelte-5opaaz{font-size:1.5rem;font-weight:bold;background:none;border:none;color:inherit;cursor:pointer;position:absolute;top:0;right:0;width:50px;height:50px}.openButton.svelte-5opaaz{background-color:rgba(0, 0, 0, 0.8);color:white;display:flex;justify-content:center;align-items:center;font-family:Arial, sans-serif}");
}

function create_fragment(ctx) {
	let div0;
	let t1;
	let div2;
	let div1;
	let button;
	let t3;
	let debugrenderer;
	let t4;
	let debugcamera;
	let t5;
	let debugmeshes;
	let t6;
	let debuglights;
	let current;
	let mounted;
	let dispose;
	debugrenderer = new DebugRenderer({});
	debugcamera = new DebugCamera({});
	debugmeshes = new DebugMeshes({});
	debuglights = new DebugLights({});

	return {
		c() {
			div0 = element("div");
			div0.textContent = `${"<"}`;
			t1 = space();
			div2 = element("div");
			div1 = element("div");
			button = element("button");
			button.textContent = `${">"}`;
			t3 = space();
			create_component(debugrenderer.$$.fragment);
			t4 = space();
			create_component(debugcamera.$$.fragment);
			t5 = space();
			create_component(debugmeshes.$$.fragment);
			t6 = space();
			create_component(debuglights.$$.fragment);
			attr(div0, "class", "collapseButton openButton svelte-5opaaz");
			toggle_class(div0, "collapsed", !/*collapsed*/ ctx[0]);
			attr(button, "class", "collapseButton svelte-5opaaz");
			attr(div1, "class", "panelContent svelte-5opaaz");
			attr(div2, "class", "panel svelte-5opaaz");
			toggle_class(div2, "collapsed", /*collapsed*/ ctx[0]);
		},
		m(target, anchor) {
			insert(target, div0, anchor);
			insert(target, t1, anchor);
			insert(target, div2, anchor);
			append(div2, div1);
			append(div1, button);
			append(div1, t3);
			mount_component(debugrenderer, div1, null);
			append(div1, t4);
			mount_component(debugcamera, div1, null);
			append(div1, t5);
			mount_component(debugmeshes, div1, null);
			append(div1, t6);
			mount_component(debuglights, div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*collapse*/ ctx[1]),
					listen(button, "click", /*collapse*/ ctx[1])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (!current || dirty & /*collapsed*/ 1) {
				toggle_class(div0, "collapsed", !/*collapsed*/ ctx[0]);
			}

			if (!current || dirty & /*collapsed*/ 1) {
				toggle_class(div2, "collapsed", /*collapsed*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(debugrenderer.$$.fragment, local);
			transition_in(debugcamera.$$.fragment, local);
			transition_in(debugmeshes.$$.fragment, local);
			transition_in(debuglights.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(debugrenderer.$$.fragment, local);
			transition_out(debugcamera.$$.fragment, local);
			transition_out(debugmeshes.$$.fragment, local);
			transition_out(debuglights.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div0);
				detach(t1);
				detach(div2);
			}

			destroy_component(debugrenderer);
			destroy_component(debugcamera);
			destroy_component(debugmeshes);
			destroy_component(debuglights);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	function collapse() {
		$$invalidate(0, collapsed = !collapsed);
	}

	let collapsed = false;
	return [collapsed, collapse];
}

class DebugPanel extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);
	}
}

export { DebugPanel as D };
