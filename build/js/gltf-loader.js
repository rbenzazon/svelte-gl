import{R as t,x as n,y as e,a3 as r,a4 as a}from"./engine.js";import{c as i}from"./specular.js";const o={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},s={MAT2:4,MAT3:9,MAT4:16,SCALAR:1,VEC2:2,VEC3:3,VEC4:4};async function l(r,a=void 0){try{let i=new Map;a&&i.set(a,c(a));const l=await fetch(r);if(!l.ok)throw new Error(`Failed to fetch GLB file: ${l.statusText}`);const u=await l.json();return await async function(r,a,i){const l=a.substring(0,a.lastIndexOf("/")+1),{buffers:u,bufferViews:f,accessors:d,scenes:m,nodes:y,meshes:h,cameras:b,materials:w,scene:v}=r,E=await Promise.all(u.map((async t=>{const{uri:n}=t,e=l+n;return i.has(e)?i.get(e):c(e)}))),x=await Promise.all(f.map((async t=>{const{buffer:n,byteOffset:e,byteLength:r,byteStride:a}=t;return{dataView:E[n].slice(e,e+r),byteStride:a}}))),T={};function A(t,n){return T[t]&&T[t][n]}function M(t,n,e){T[n]=T[n]||{},T[n][e]=t}function O(t,n){return T[t]&&null!=T[t][n]}const g=d.map((t=>{const{bufferView:n,byteOffset:e}=t,{dataView:r,byteStride:a}=x[n],{type:i,componentType:l,count:c,min:u,max:f}=t,d=s[i],m=o[l],p=m.BYTES_PER_ELEMENT;let y,h,b,w=!1;if(null!=a&&a!==p*d){y=Math.floor(e/a)*a,h=c*a/p,w=!0}else y=e,h=c*d;return w&&O(r,y)?b=A(r,y):(b=new m(r,y,h),w&&M(b,r,y)),{type:i,componentType:l,count:c,min:u,max:f,data:b,interleaved:w,...w?{byteOffset:e,byteStride:a}:{}}})),S=h.map((t=>G(t)));function F(t){return"mesh"in t}function L(t){return"camera"in t}function R(t){return"children"in t}const I=y.map((t=>F(t)?{...S[t.mesh],matrix:p(t)}:L(t)?N(t):R(t)?t:void 0)),V=I.map((t=>null!=t.children?U(t):t)),C=m[v];let{nodes:P}=C,B=P.map((t=>V[t]));return B.forEach((t=>{j(t)})),{scene:B,materials:w};function G(n){const{primitives:e}=n,r=e[0],{attributes:a,indices:i}=e[0],{POSITION:o,NORMAL:s,TEXCOORD_0:l}=a,c=g[o],u=g[s],f=g[l];return{position:c,normal:u,indices:g[i],uv:f,material:r.material,drawMode:t[r.mode]}}function N(t){let r;return r=null!=t.scale||null!=t.translation||null!=t.rotation?p(t):n(e()),{...t,matrix:r,...b[t.camera]}}function j(t,n=null){const{children:e}=t;if(null!=n&&(t.parent=n),null!=e)return e.map((n=>{j(n,t)}))}function U(t){const{children:r,matrix:a,scale:i,translation:o,rotation:s}=t;let l;return l=null!=a||null==i&&null==o&&null==s?null!=a?a:n(e()):p(t),{children:r.map((t=>null!=I[t].children?U(I[t]):I[t])),matrix:l}}}(u,r,i)}catch(t){console.error("Error loading GLTF file:",t)}}async function c(t){let n;if(t){if(n=await fetch(t),!n.ok)throw new Error(`Failed to fetch GLTF Binary file: ${n.statusText}`);return await n.arrayBuffer()}}function u(t){return"interleaved"in t}function f(t,n){const e=n,r=t.materials[e.material],a={diffuse:[1,1,1],metalness:0};if(r.pbrMetallicRoughness){const{baseColorFactor:t,metallicFactor:n,roughnessFactor:e}=r.pbrMetallicRoughness,o=t?.slice(0,3)??[1,1,1];3===o.length&&(a.diffuse=o),null!=e&&(a.specular=i({roughness:e})),a.metalness=n}return{attributes:{positions:u(e.position)?{data:e.position.data,interleaved:e.position.interleaved,byteOffset:e.position.byteOffset,byteStride:e.position.byteStride}:e.position.data,normals:u(e.normal)?{data:e.normal.data,interleaved:e.normal.interleaved,byteOffset:e.normal.byteOffset,byteStride:e.normal.byteStride}:e.normal.data,elements:e.indices.data,...e.uv?.data?{uvs:e.uv.data}:{}},drawMode:e.drawMode??"TRIANGLES",material:a,matrix:e.matrix}}function d(t){const{perspective:n,translation:e}=t;return{position:e,target:[0,0,0],fov:n.yfov/Math.PI*180,near:n.znear,far:n.zfar,up:[0,1,0]}}function m(t){const a=[];let i=t;for(;null!=i.parent;)a.unshift(i.matrix),i=i.parent;return a.reduce(((t,n)=>r(t,t,n)),n(e()))}function p(t){const{translation:r,rotation:i,scale:o}=t,s=n(e());return a(s,i||[0,0,0,0],r||[0,0,0],o||[1,1,1]),s}function y(t,n){t.forEach((t=>{n(t),null!=t.children&&y(t.children,n)}))}function h(t,n=[]){return t.forEach((t=>{n.push(t),null!=t.children&&h(t.children,n)})),n}function b(t){return"position"in t}function w(t){return"perspective"in t}export{w as a,d as b,f as c,m as g,b as i,l,h as m,y as t};
