import{R as t,y as e,z as n,av as a,aw as r}from"./engine.js";import{c as i}from"./specular.js";const o={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},s={MAT2:4,MAT3:9,MAT4:16,SCALAR:1,VEC2:2,VEC3:3,VEC4:4};async function l(a,r=void 0,i=void 0){try{let l=new Map;r&&l.set(r,c(r));const u=await fetch(a);if(!u.ok)throw new Error(`Failed to fetch GLB file: ${u.statusText}`);const f=await u.json();return await async function(a,r,i,l){const u=r.substring(0,r.lastIndexOf("/")+1),{buffers:f,bufferViews:d,accessors:m,scenes:y,nodes:h,meshes:b,cameras:w,materials:v,scene:x}=a,E=await Promise.all(f.map((async t=>{const{uri:e}=t,n=u+e;return i.has(n)?i.get(n):c(n)}))),T=await Promise.all(d.map((async t=>{const{buffer:e,byteOffset:n,byteLength:a,byteStride:r}=t;return{dataView:E[e].slice(n,n+a),byteStride:r}}))),g={};function M(t,e){return g[t]&&g[t][e]}function A(t,e,n){g[e]=g[e]||{},g[e][n]=t}function O(t,e){return g[t]&&null!=g[t][e]}const S=m.map((t=>{const{bufferView:e,byteOffset:n}=t;if(null==e)return;const{dataView:a,byteStride:r}=T[e],{type:i,componentType:l,count:c,min:u,max:f}=t,d=s[i],m=o[l],p=m.BYTES_PER_ELEMENT;let y,h,b,w=!1;if(null!=r&&r!==p*d){y=Math.floor(n/r)*r,h=c*r/p,w=!0}else y=n,h=c*d;return w&&O(a,y)?b=M(a,y):(b=new m(a,y,h),w&&A(b,a,y)),{type:i,componentType:l,count:c,min:u,max:f,data:b,interleaved:w,...w?{byteOffset:n,byteStride:r}:{}}})),R=await Promise.all(b.map((t=>G(t))));function V(t){return"mesh"in t}function _(t){return"camera"in t}function F(t){return"children"in t}const L=h.map((t=>V(t)?{...R[t.mesh],matrix:p(t)}:_(t)?j(t):F(t)?t:void 0)),I=L.map((t=>null!=t.children?U(t):t)),C=y[x];let{nodes:P}=C,B=P.map((t=>I[t]));return B.forEach((t=>{z(t)})),{scene:B,materials:v};async function G(e){const{primitives:n}=e,a=n[0],{attributes:r,indices:i}=a,{POSITION:o,NORMAL:s,TEXCOORD_0:c}=r;if(a?.extensions?.KHR_draco_mesh_compression){const{extensions:{KHR_draco_mesh_compression:e}}=a,{bufferView:n,attributes:r}=e;if(l&&null!=n){const e=N(r,a),c=await l.decode(l,T[n].dataView,r,e),u=c.geometry.attributes,f=u[o],d=m[o],p=u[s],y=m[o],h=c.geometry.index,b=m[i];return{position:{...d,data:f.array},normal:{...y,data:p.array},indices:{...b,data:h.array},material:a.material,drawMode:t[a.mode]}}}const u=S[o],f=S[s],d=S[c];return{position:u,normal:f,indices:S[i],uv:d,material:a.material,drawMode:t[a.mode]}}function N(t,e){const n={};for(const a in e.attributes)if(void 0!==t[a]){const t=m[e.attributes[a]],r=o[t.componentType];n[a]=r.name}return n}function j(t){let a;return a=null!=t.scale||null!=t.translation||null!=t.rotation?p(t):e(n()),{...t,matrix:a,...w[t.camera]}}function z(t,e=null){const{children:n}=t;if(null!=e&&(t.parent=e),null!=n)return n.map((e=>{z(e,t)}))}function U(t){const{children:a,matrix:r,scale:i,translation:o,rotation:s}=t;let l;return l=null!=r||null==i&&null==o&&null==s?null!=r?r:e(n()):p(t),{children:a.map((t=>null!=L[t].children?U(L[t]):L[t])),matrix:l}}}(f,a,l,i)}catch(l){console.error("Error loading GLTF file:",l)}}async function c(t){let e;if(t){if(e=await fetch(t),!e.ok)throw new Error(`Failed to fetch GLTF Binary file: ${e.statusText}`);return await e.arrayBuffer()}}function u(t){return"interleaved"in t}function f(t,e){const n=e,a=t.materials[n.material],r={diffuse:[1,1,1],metalness:0};if(a.pbrMetallicRoughness){const{baseColorFactor:t,metallicFactor:e,roughnessFactor:n}=a.pbrMetallicRoughness,o=t?.slice(0,3)??[1,1,1];3===o.length&&(r.diffuse=o),null!=n&&(r.specular=i({roughness:n})),r.metalness=e}return{attributes:{positions:u(n.position)?{data:n.position.data,interleaved:n.position.interleaved,byteOffset:n.position.byteOffset,byteStride:n.position.byteStride}:n.position.data,normals:u(n.normal)?{data:n.normal.data,interleaved:n.normal.interleaved,byteOffset:n.normal.byteOffset,byteStride:n.normal.byteStride}:n.normal.data,elements:n.indices.data,...n.uv?.data?{uvs:n.uv.data}:{}},drawMode:n.drawMode??"TRIANGLES",material:r,matrix:n.matrix}}function d(t){const{perspective:e,translation:n}=t;return{position:n,target:[0,0,0],fov:e.yfov/Math.PI*180,near:e.znear,far:e.zfar,up:[0,1,0]}}function m(t){const r=[];let i=t;for(;null!=i.parent;)r.unshift(i.matrix),i=i.parent;return r.reduce(((t,e)=>a(t,t,e)),e(n()))}function p(t){const{translation:a,rotation:i,scale:o}=t,s=e(n());return r(s,i||[0,0,0,0],a||[0,0,0],o||[1,1,1]),s}function y(t,e){t.forEach((t=>{e(t),null!=t.children&&y(t.children,e)}))}function h(t,e=[]){return t.forEach((t=>{e.push(t),null!=t.children&&h(t.children,e)})),e}function b(t){return"position"in t}function w(t){return"perspective"in t}export{w as a,f as b,d as c,m as g,b as i,l,h as m,y as t};
