import{R as t,y as e,z as n,aE as a,aI as r}from"./engine.js";import{c as i}from"./specular.js";const o={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},s={MAT2:4,MAT3:9,MAT4:16,SCALAR:1,VEC2:2,VEC3:3,VEC4:4};async function l(a,r=void 0,i=void 0){try{let l=new Map;r&&l.set(r,c(r));const u=await fetch(a);if(!u.ok)throw new Error(`Failed to fetch GLB file: ${u.statusText}`);const f=await u.json();return await async function(a,r,i,l){const u=r.substring(0,r.lastIndexOf("/")+1),{buffers:f,bufferViews:d,accessors:m,scenes:y,nodes:h,meshes:b,cameras:w,materials:v,scene:O}=a,E=await Promise.all(f.map((async t=>{const{uri:e}=t,n=u+e;return i.has(n)?i.get(n):c(n)}))),T=await Promise.all(d.map((async t=>{const{buffer:e,byteOffset:n,byteLength:a,byteStride:r}=t;return{dataView:E[e].slice(n,n+a),byteStride:r}}))),x={};function M(t,e){return x[t]&&x[t][e]}function g(t,e,n){x[e]=x[e]||{},x[e][n]=t}function A(t,e){return x[t]&&null!=x[t][e]}const R=m.map((t=>{const{bufferView:e,byteOffset:n}=t;if(null==e)return;const{dataView:a,byteStride:r}=T[e],{type:i,componentType:l,count:c,min:u,max:f}=t,d=s[i],m=o[l],p=m.BYTES_PER_ELEMENT;let y,h,b,w=!1;if(null!=r&&r!==p*d){y=Math.floor(n/r)*r,h=c*r/p,w=!0}else y=n,h=c*d;return w&&A(a,y)?b=M(a,y):(b=new m(a,y,h),w&&g(b,a,y)),{type:i,componentType:l,count:c,min:u,max:f,data:b,interleaved:w,...w?{byteOffset:n,byteStride:r}:{}}})),S=await Promise.all(b.map((t=>D(t))));function _(t){return"mesh"in t}function I(t){return"camera"in t}function C(t){return"children"in t}const L=h.map((t=>_(t)?{...S[t.mesh],matrix:p(t),name:t.name}:I(t)?G(t):C(t)?t:void 0)),V=L.map((t=>null!=t.children?j(t):t)),F=y[O];let{nodes:P}=F,N=P.map((t=>V[t]));return N.forEach((t=>{X(t)})),{scene:N,materials:v};async function D(e){const{primitives:n}=e,a=n[0],{attributes:r,indices:i}=a,{POSITION:o,NORMAL:s,TEXCOORD_0:c,TEXCOORD_1:u}=r;if(a?.extensions?.KHR_draco_mesh_compression){const{extensions:{KHR_draco_mesh_compression:e}}=a,{bufferView:n,attributes:r}=e,{POSITION:o,NORMAL:s,TEXCOORD_0:c,TEXCOORD_1:u}=r;if(!l)throw new Error("Draco decoder not provided");if(l&&null!=n){const e=B(r,a),f=await l.decode(l,T[n].dataView,r,e),d=f.geometry.attributes,p=d[o],y=m[o],h=d[s],b=m[o],w=d[c],v=m[c],O=d[u],E=m[u],x=f.geometry.index,M=m[i];return{position:{...y,data:p.array},normal:{...b,data:h.array},uv:{...v,data:w.array},uv1:{...E,data:O.array},indices:{...M,data:x.array},material:a.material,drawMode:t[a.mode]}}}const f={},d=R[o],p=R[s],y=R[c];null!=R[u]&&(f.uv1=R[u]);const h=R[i];return{...f,position:d,normal:p,indices:h,uv:y,material:a.material,drawMode:t[a.mode]}}function B(t,e){const n={};for(const a in e.attributes)if(void 0!==t[a]){const t=m[e.attributes[a]],r=o[t.componentType];n[a]=r.name}return n}function G(t){let a;return a=null!=t.scale||null!=t.translation||null!=t.rotation?p(t):e(n()),{...t,matrix:a,...w[t.camera]}}function X(t,e=null){const{children:n}=t;if(null!=e&&(t.parent=e),null!=n)return n.map((e=>{X(e,t)}))}function j(t){const{children:a,matrix:r,scale:i,translation:o,rotation:s}=t;let l;return l=null!=r||null==i&&null==o&&null==s?null!=r?r:e(n()):p(t),{children:a.map((t=>null!=L[t].children?j(L[t]):L[t])),matrix:l}}}(f,a,l,i)}catch(l){console.error("Error loading GLTF file:",l)}}async function c(t){let e;if(t){if(e=await fetch(t),!e.ok)throw new Error(`Failed to fetch GLTF Binary file: ${e.statusText}`);return await e.arrayBuffer()}}function u(t){return"interleaved"in t}function f(t,e){const n=e,a=t.materials?t.materials[n?.material]??{}:{},r={diffuse:[1,1,1],metalness:0};if(a.pbrMetallicRoughness){const{baseColorFactor:t,metallicFactor:e,roughnessFactor:n}=a.pbrMetallicRoughness,o=t?.slice(0,3)??[1,1,1];3===o.length&&(r.diffuse=o),null!=n&&(r.specular=i({roughness:n})),r.metalness=e}return{attributes:{positions:u(n.position)?{data:n.position.data,interleaved:n.position.interleaved,byteOffset:n.position.byteOffset,byteStride:n.position.byteStride}:n.position.data,normals:u(n.normal)?{data:n.normal.data,interleaved:n.normal.interleaved,byteOffset:n.normal.byteOffset,byteStride:n.normal.byteStride}:n.normal.data,elements:n.indices.data,...n.uv?.data?{uvs:n.uv.data}:{}},drawMode:n.drawMode??"TRIANGLES",material:r,matrix:n.matrix}}function d(t){const{perspective:e,translation:n}=t;return{position:n,target:[0,0,0],fov:e.yfov/Math.PI*180,near:e.znear,far:e.zfar,up:[0,1,0]}}function m(t){const r=[];let i=t;for(;null!=i.parent;)r.unshift(i.matrix),i=i.parent;return r.reduce(((t,e)=>a(t,t,e)),e(n()))}function p(t){const{translation:a,rotation:i,scale:o}=t,s=e(n());return r(s,i||[0,0,0,0],a||[0,0,0],o||[1,1,1]),s}function y(t,e){t.forEach((t=>{e(t),null!=t.children&&y(t.children,e)}))}function h(t,e=[]){return t.forEach((t=>{e.push(t),null!=t.children&&h(t.children,e)})),e}function b(t){return"position"in t}function w(t){return"perspective"in t}export{w as a,f as b,d as c,m as g,b as i,l,h as m,y as t};
