import{R as t,y as e,z as n,az as r,aA as a}from"./engine.js";import{c as i}from"./specular.js";const o={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},s={MAT2:4,MAT3:9,MAT4:16,SCALAR:1,VEC2:2,VEC3:3,VEC4:4};async function l(r,a=void 0,i=void 0){try{let l=new Map;a&&l.set(a,c(a));const u=await fetch(r);if(!u.ok)throw new Error(`Failed to fetch GLB file: ${u.statusText}`);const f=await u.json();return await async function(r,a,i,l){const u=a.substring(0,a.lastIndexOf("/")+1),{buffers:f,bufferViews:d,accessors:m,scenes:y,nodes:h,meshes:b,cameras:w,materials:v,scene:E}=r,O=await Promise.all(f.map((async t=>{const{uri:e}=t,n=u+e;return i.has(n)?i.get(n):c(n)}))),T=await Promise.all(d.map((async t=>{const{buffer:e,byteOffset:n,byteLength:r,byteStride:a}=t;return{dataView:O[e].slice(n,n+r),byteStride:a}}))),x={};function A(t,e){return x[t]&&x[t][e]}function M(t,e,n){x[e]=x[e]||{},x[e][n]=t}function g(t,e){return x[t]&&null!=x[t][e]}const S=m.map((t=>{const{bufferView:e,byteOffset:n}=t;if(null==e)return;const{dataView:r,byteStride:a}=T[e],{type:i,componentType:l,count:c,min:u,max:f}=t,d=s[i],m=o[l],p=m.BYTES_PER_ELEMENT;let y,h,b,w=!1;if(null!=a&&a!==p*d){y=Math.floor(n/a)*a,h=c*a/p,w=!0}else y=n,h=c*d;return w&&g(r,y)?b=A(r,y):(b=new m(r,y,h),w&&M(b,r,y)),{type:i,componentType:l,count:c,min:u,max:f,data:b,interleaved:w,...w?{byteOffset:n,byteStride:a}:{}}})),R=await Promise.all(b.map((t=>z(t))));function _(t){return"mesh"in t}function I(t){return"camera"in t}function L(t){return"children"in t}const V=h.map((t=>_(t)?{...R[t.mesh],matrix:p(t),name:t.name}:I(t)?G(t):L(t)?t:void 0)),F=V.map((t=>null!=t.children?D(t):t)),C=y[E];let{nodes:P}=C,N=P.map((t=>F[t]));return N.forEach((t=>{j(t)})),{scene:N,materials:v};async function z(e){const{primitives:n}=e,r=n[0],{attributes:a,indices:i}=r,{POSITION:o,NORMAL:s,TEXCOORD_0:c}=a;if(r?.extensions?.KHR_draco_mesh_compression){const{extensions:{KHR_draco_mesh_compression:e}}=r,{bufferView:n,attributes:a}=e,{POSITION:o,NORMAL:s,TEXCOORD_0:c}=a;if(!l)throw new Error("Draco decoder not provided");if(l&&null!=n){const e=B(a,r),c=await l.decode(l,T[n].dataView,a,e),u=c.geometry.attributes,f=u[o],d=m[o],p=u[s],y=m[o],h=c.geometry.index,b=m[i];return{position:{...d,data:f.array},normal:{...y,data:p.array},indices:{...b,data:h.array},material:r.material,drawMode:t[r.mode]}}}const u=S[o],f=S[s],d=S[c];return{position:u,normal:f,indices:S[i],uv:d,material:r.material,drawMode:t[r.mode]}}function B(t,e){const n={};for(const r in e.attributes)if(void 0!==t[r]){const t=m[e.attributes[r]],a=o[t.componentType];n[r]=a.name}return n}function G(t){let r;return r=null!=t.scale||null!=t.translation||null!=t.rotation?p(t):e(n()),{...t,matrix:r,...w[t.camera]}}function j(t,e=null){const{children:n}=t;if(null!=e&&(t.parent=e),null!=n)return n.map((e=>{j(e,t)}))}function D(t){const{children:r,matrix:a,scale:i,translation:o,rotation:s}=t;let l;return l=null!=a||null==i&&null==o&&null==s?null!=a?a:e(n()):p(t),{children:r.map((t=>null!=V[t].children?D(V[t]):V[t])),matrix:l}}}(f,r,l,i)}catch(l){console.error("Error loading GLTF file:",l)}}async function c(t){let e;if(t){if(e=await fetch(t),!e.ok)throw new Error(`Failed to fetch GLTF Binary file: ${e.statusText}`);return await e.arrayBuffer()}}function u(t){return"interleaved"in t}function f(t,e){const n=e,r=t.materials?t.materials[n?.material]??{}:{},a={diffuse:[1,1,1],metalness:0};if(r.pbrMetallicRoughness){const{baseColorFactor:t,metallicFactor:e,roughnessFactor:n}=r.pbrMetallicRoughness,o=t?.slice(0,3)??[1,1,1];3===o.length&&(a.diffuse=o),null!=n&&(a.specular=i({roughness:n})),a.metalness=e}return{attributes:{positions:u(n.position)?{data:n.position.data,interleaved:n.position.interleaved,byteOffset:n.position.byteOffset,byteStride:n.position.byteStride}:n.position.data,normals:u(n.normal)?{data:n.normal.data,interleaved:n.normal.interleaved,byteOffset:n.normal.byteOffset,byteStride:n.normal.byteStride}:n.normal.data,elements:n.indices.data,...n.uv?.data?{uvs:n.uv.data}:{}},drawMode:n.drawMode??"TRIANGLES",material:a,matrix:n.matrix}}function d(t){const{perspective:e,translation:n}=t;return{position:n,target:[0,0,0],fov:e.yfov/Math.PI*180,near:e.znear,far:e.zfar,up:[0,1,0]}}function m(t){const a=[];let i=t;for(;null!=i.parent;)a.unshift(i.matrix),i=i.parent;return a.reduce(((t,e)=>r(t,t,e)),e(n()))}function p(t){const{translation:r,rotation:i,scale:o}=t,s=e(n());return a(s,i||[0,0,0,0],r||[0,0,0],o||[1,1,1]),s}function y(t,e){t.forEach((t=>{e(t),null!=t.children&&y(t.children,e)}))}function h(t,e=[]){return t.forEach((t=>{e.push(t),null!=t.children&&h(t.children,e)})),e}function b(t){return"position"in t}function w(t){return"perspective"in t}export{w as a,f as b,d as c,m as g,b as i,l,h as m,y as t};
