import{a4 as e,W as r,ax as n,Y as t,U as i,y as a,Z as o,_ as c,a0 as u,a1 as s,a2 as l,q as f,F as v,av as m,T as E,R as p}from"./engine.js";const d=r=>({exposure:`${r.exposure.toLocaleString("en",{minimumFractionDigits:1})}f`,shader:e("${declaration?\r\n`\r\n#ifndef saturate\r\n    #define saturate( a ) clamp( a, 0.0, 1.0 )\r\n#endif\r\n\r\nfloat toneMappingExposure = ${exposure};\r\n\r\nvec3 RRTAndODTFit( vec3 v ) {\r\n    vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\r\n    vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\r\n    return a / b;\r\n}\r\nvec3 ACESFilmicToneMapping( vec3 color ) {\r\n    const mat3 ACESInputMat = mat3(\r\n    vec3( 0.59719, 0.07600, 0.02840 ), vec3( 0.35458, 0.90834, 0.13383 ), vec3( 0.04823, 0.01566, 0.83777 )\r\n    );\r\n    const mat3 ACESOutputMat = mat3(\r\n    vec3(  1.60475, -0.10208, -0.00327 ), vec3( -0.53108, 1.10813, -0.07276 ), vec3( -0.07367, -0.00605, 1.07602 )\r\n    );\r\n    color *= toneMappingExposure / 0.6;\r\n    color = ACESInputMat * color;\r\n    color = RRTAndODTFit( color );\r\n    color = ACESOutputMat * color;\r\n    return saturate( color );\r\n}\r\n` : ''\r\n}\r\n${color?\r\n`\r\n    fragColor = vec4(ACESFilmicToneMapping(fragColor.rgb),1.0f);\r\n` : ''\r\n}",{declaration:!1,exposure:1,color:!1})});function T(e,o,c,u,s=1024){if(!o.getExtension("EXT_color_buffer_float"))throw new Error("EXT_color_buffer_float extension not supported");const l=e instanceof WebGLTexture?e:function(e,r,n,t){const i=e.createTexture();return e.bindTexture(e.TEXTURE_2D,i),e.texImage2D(e.TEXTURE_2D,0,e.RGBA16F,n,t,0,e.RGBA,e.HALF_FLOAT,r),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),i}(o,e,c,u),f=function(e,r){const n=e.createTexture();e.bindTexture(e.TEXTURE_CUBE_MAP,n);for(let n=0;n<6;n++)e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X+n,0,e.RGBA16F,r,r,0,e.RGBA,e.HALF_FLOAT,null);return e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_R,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MAG_FILTER,e.LINEAR),n}(o,s),{program:v,vertexArray:m}=function(e){const r="#version 300 es\n\n    #define SHADER_NAME hdrToCubeVertex\n\n    layout(location = 0) in vec2 position;\n    out vec3 localPos;\n    uniform mat4 projectionMatrix;\n    uniform mat4 view;\n\n    void main() {\n        // Use the quad positions directly for rendering\n        gl_Position = vec4(position, 0.0, 1.0);\n        \n        // Create the ray direction for this fragment\n        // Map from [-1,1] to [-1,1] in view space for proper cubemap sampling\n        vec4 viewPos = inverse(projectionMatrix * view) * vec4(position, 1.0, 1.0);\n        localPos = viewPos.xyz / viewPos.w;\n    }",n="#version 300 es\n\n    #define SHADER_NAME hdrToCubeFragment\n\n    precision highp float;\n    in vec3 localPos;\n    out vec4 fragColor;\n    uniform sampler2D equirectangularMap;\n\n    vec2 SampleSphericalMap(vec3 v) {\n        // Convert direction vector to spherical coordinates\n        float phi = atan(v.z, v.x);\n        float theta = asin(v.y);\n        \n        // Map from [-π to π] for phi and [-π/2 to π/2] for theta to [0,1] range\n        vec2 uv = vec2(\n            0.5 + 0.5 * phi / 3.1415926535897932,\n            0.5 - theta / 3.1415926535897932\n        );\n        \n        return uv;\n    }\n\n    void main() {\n        vec3 direction = normalize(localPos);\n        vec2 uv = SampleSphericalMap(direction);\n        fragColor = texture(equirectangularMap, uv);\n    }",t=e.createProgram();if(i(e,t,r,n),e.linkProgram(t),!e.getProgramParameter(t,e.LINK_STATUS))throw console.error("Shader program error:",e.getProgramInfoLog(t)),new Error("Failed to compile shaders");const a=e.createVertexArray();e.bindVertexArray(a);const o=new Float32Array([-1,-1,1,-1,-1,1,1,1]),c=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,c),e.bufferData(e.ARRAY_BUFFER,o,e.STATIC_DRAW),e.enableVertexAttribArray(0),e.vertexAttribPointer(0,2,e.FLOAT,!1,0,0),{program:t,vertexArray:a}}(o),E=o.createFramebuffer();o.bindFramebuffer(o.FRAMEBUFFER,E),o.useProgram(v),o.bindVertexArray(m),o.activeTexture(o.TEXTURE0),o.bindTexture(o.TEXTURE_2D,l),o.uniform1i(o.getUniformLocation(v,"equirectangularMap"),0);const p=a(),d=Math.PI/2,T=1/Math.tan(d/2);p[0]=T/1,p[5]=T,p[10]=10.1/-9.9,p[11]=-1,p[14]=2/-9.9;const g=o.getUniformLocation(v,"projectionMatrix");o.uniformMatrix4fv(g,!1,p);const _=[],M=r();for(let e=0;e<6;e++){const r=n();let i,a;switch(e){case 0:i=[1,0,0],a=[0,-1,0];break;case 1:i=[-1,0,0],a=[0,-1,0];break;case 2:i=[0,1,0],a=[0,0,1];break;case 3:i=[0,-1,0],a=[0,0,-1];break;case 4:i=[0,0,1],a=[0,-1,0];break;case 5:i=[0,0,-1],a=[0,-1,0]}const o=[M[0]+i[0],M[1]+i[1],M[2]+i[2]];t(r,M,o,a),_.push(r)}for(let e=0;e<6;e++){o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_CUBE_MAP_POSITIVE_X+e,f,0);const r=o.checkFramebufferStatus(o.FRAMEBUFFER);r===o.FRAMEBUFFER_COMPLETE?(o.uniformMatrix4fv(o.getUniformLocation(v,"view"),!1,_[e]),o.viewport(0,0,s,s),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT),o.drawArrays(o.TRIANGLE_STRIP,0,4)):console.error("Framebuffer not complete:",r)}return o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(E),o.deleteTexture(l),o.bindTexture(o.TEXTURE_CUBE_MAP,f),o.generateMipmap(o.TEXTURE_CUBE_MAP),f}function g(e){return d({exposure:e})}var _="#version 300 es\r\n\r\nprecision mediump float;\r\nprecision mediump int;\r\n\r\nin vec3 position;\r\nin vec2 uv;\r\nin float faceIndex;\r\n\r\nout vec3 vOutputDirection;\r\n\r\n// RH coordinate system; PMREM face-indexing convention\r\nvec3 getDirection(vec2 uv, float face) {\r\n\r\n    uv = 2.0 * uv - 1.0;\r\n\r\n    vec3 direction = vec3(uv, 1.0);\r\n\r\n    if(face == 0.0) {\r\n        // 0 0 0\r\n        // X 0 0\r\n        direction = direction.zyx; // ( 1, v, u ) pos x\r\n\r\n    } else if(face == 1.0) {\r\n        //0 0 0\r\n        //0 X 0\r\n        direction = direction.xzy;\r\n        direction.xz *= -1.0; // ( -u, 1, -v ) pos y\r\n\r\n    } else if(face == 2.0) {\r\n        //0 0 0\r\n        //0 0 X\r\n        direction.x *= -1.0; // ( -u, v, 1 ) pos z\r\n\r\n    } else if(face == 3.0) {\r\n        // X 0 0\r\n        // 0 0 0\r\n        direction = direction.zyx;\r\n        direction.xz *= -1.0; // ( -1, v, -u ) neg x\r\n\r\n    } else if(face == 4.0) {\r\n        //0 X 0\r\n        //0 0 0\r\n        direction = direction.xzy;\r\n        direction.xy *= -1.0; // ( -u, -1, v ) neg y\r\n\r\n    } else if(face == 5.0) {\r\n        //0 0 X\r\n        //0 0 0\r\n        direction.z *= -1.0; // ( u, v, -1 ) neg z\r\n    }\r\n\r\n    return direction;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n    vOutputDirection = getDirection(uv, faceIndex);\r\n    gl_Position = vec4(position, 1.0);\r\n\r\n}",M="#version 300 es\r\n\r\nprecision mediump float;\r\nprecision mediump int;\r\n\r\n#define n 20\r\n#define CUBEUV_TEXEL_WIDTH ${CUBEUV_TEXEL_WIDTH}\r\n#define CUBEUV_TEXEL_HEIGHT ${CUBEUV_TEXEL_HEIGHT}\r\n#define CUBEUV_MAX_MIP ${CUBEUV_MAX_MIP}\r\n#define cubeUV_minMipLevel 4.0\r\n#define cubeUV_minTileSize 16.0\r\n\r\nin vec3 vOutputDirection;\r\n\r\nuniform sampler2D envMap;\r\n\r\nuniform int samples;\r\nuniform float weights[n];\r\nuniform bool latitudinal;\r\nuniform float dTheta;\r\nuniform float mipInt;\r\nuniform vec3 poleAxis;\r\n\r\nout vec4 fragColor;\r\n\r\nfloat getFace(vec3 direction) {\r\n    vec3 absDirection = abs(direction);\r\n    float face = -1.0;\r\n    if(absDirection.x > absDirection.z) {\r\n        if(absDirection.x > absDirection.y)\r\n            face = direction.x > 0.0 ? 0.0 : 3.0;\r\n        else\r\n            face = direction.y > 0.0 ? 1.0 : 4.0;\r\n    } else {\r\n        if(absDirection.z > absDirection.y)\r\n            face = direction.z > 0.0 ? 2.0 : 5.0;\r\n        else\r\n            face = direction.y > 0.0 ? 1.0 : 4.0;\r\n    }\r\n    return face;\r\n}\r\n\r\n// RH coordinate system; PMREM face-indexing convention\r\nvec2 getUV( vec3 direction, float face ) {\r\n    vec2 uv;\r\n    if ( face == 0.0 ) {\r\n        uv = vec2( direction.z, direction.y ) / abs( direction.x );\r\n    }\r\n    else if ( face == 1.0 ) {\r\n        uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\r\n    }\r\n    else if ( face == 2.0 ) {\r\n        uv = vec2( - direction.x, direction.y ) / abs( direction.z );\r\n    }\r\n    else if ( face == 3.0 ) {\r\n        uv = vec2( - direction.z, direction.y ) / abs( direction.x );\r\n    }\r\n    else if ( face == 4.0 ) {\r\n        uv = vec2( - direction.x, direction.z ) / abs( direction.y );\r\n    }\r\n    else {\r\n        uv = vec2( direction.x, direction.y ) / abs( direction.z );\r\n    }\r\n    return 0.5 * ( uv + 1.0 );\r\n}\r\n\r\nvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\r\n    float face = getFace( direction );\r\n    float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\r\n    mipInt = max( mipInt, cubeUV_minMipLevel );\r\n    float faceSize = exp2( mipInt );\r\n    highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\r\n    if ( face > 2.0 ) {\r\n        uv.y += faceSize;\r\n        face -= 3.0;\r\n    }\r\n    uv.x += face * faceSize;\r\n    uv.x += filterInt * 3.0 * cubeUV_minTileSize;\r\n    uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\r\n    uv.x *= CUBEUV_TEXEL_WIDTH;\r\n    uv.y *= CUBEUV_TEXEL_HEIGHT;\r\n    //return texture( envMap, uv).rgb;\r\n    return textureGrad( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\r\n}\r\n\r\nvec3 getSample(float theta, vec3 axis) {\r\n    float cosTheta = cos(theta);\r\n    // Rodrigues' axis-angle rotation\r\n    vec3 sampleDirection = vOutputDirection * cosTheta\r\n    + cross(axis, vOutputDirection) * sin(theta)\r\n    + axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\r\n    return bilinearCubeUV(envMap, sampleDirection, mipInt);\r\n}\r\n\r\nvoid main() {\r\n\r\n    vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\r\n    if(all(equal(axis, vec3(0.0)))) {\r\n        axis = vec3(vOutputDirection.z, 0.0, -vOutputDirection.x);\r\n    }\r\n\r\n    axis = normalize(axis);\r\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n    //fragColor = vec4(mipInt/10.0, mipInt/10.0, mipInt/10.0, 1.0f);\r\n    //fragColor = vec4(dTheta*40.0, dTheta*40.0, dTheta*40.0, 1.0f);\r\n    //fragColor.rgb = dTheta;\r\n    //fragColor.rgb += texture(envMap, vOutputDirection.xy).rgb;\r\n    fragColor.rgb += weights[0] * getSample(0.0, axis);\r\n    for(int i = 1; i < n; i++) {\r\n        if(i >= samples) {\r\n            break;\r\n        }\r\n        float theta = dTheta * float(i);\r\n        fragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\r\n        fragColor.rgb += weights[i] * getSample(theta, axis);\r\n    }\r\n}",h="#version 300 es\r\n\r\nprecision highp float;\r\nprecision highp int;\r\nprecision highp sampler2D;\r\n\r\n#define RECIPROCAL_PI 0.3183098861837907\r\n#define RECIPROCAL_PI2 0.15915494309189535\r\n\r\nuniform float flipEnvMap;\r\n\r\nin vec3 vOutputDirection;\r\n\r\nuniform sampler2D envMap;\r\n\r\nout highp vec4 fragColor;\r\n\r\nvec2 equirectUv( in vec3 dir ) {\r\n    float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\r\n    float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n    v = 0.5 * (1.0 + flipEnvMap) * (1.0 - 2.0 * v) + v;\r\n    return vec2( u, v );\r\n}\r\n\r\nvoid main() {\r\n    vec3 outputDirection = normalize( vOutputDirection );\r\n    vec2 uv = equirectUv( outputDirection );\r\n\r\n    fragColor = vec4( texture ( envMap, uv ).rgb, 1.0 );\r\n}";const x=4,b=[.125,.215,.35,.446,.526,.582],U=(1+Math.sqrt(5))/2,R=1/U,A=[[-U,R,0],[U,R,0],[-R,0,U],[R,0,U],[0,U,-R],[0,U,R],[-1,1,-1],[1,1,-1],[-1,1,1],[1,1,1]];function P(e,r,n){let t={};t.image=e;const i=e.width??r;t.cubeImageSize=i/4,t.lodMax=Math.floor(Math.log2(t.cubeImageSize)),t.cubeSize=Math.pow(2,t.lodMax),t.renderTargetWidth=3*Math.max(t.cubeSize,112),t.renderTargetHeight=4*t.cubeSize,function(e){const r=[],n=[],t=[];let i=e.lodMax;const a=e.lodMax-x+1+b.length;for(let o=0;o<a;o++){const a=Math.pow(2,i);n.push(a);let c=1/a;o>e.lodMax-x?c=b[o-e.lodMax+x-1]:0===o&&(c=0),t.push(c);const u=1/(a-2),s=-u,l=1+u,f=[s,s,l,s,l,l,s,s,l,l,s,l],v=6,m=6,E=3,d=2,T=1,g=new Float32Array(E*m*v),_=new Float32Array(d*m*v),M=new Float32Array(T*m*v);for(let e=0;e<v;e++){const r=e%3*2/3-1,n=e>2?0:-1,t=[r,n,0,r+2/3,n,0,r+2/3,n+1,0,r,n,0,r+2/3,n+1,0,r,n+1,0];g.set(t,E*m*e),_.set(f,d*m*e);const i=[e,e,e,e,e,e];M.set(i,T*m*e)}const h={attributes:{positions:g,uvs:_,faceIndex:{array:M,itemSize:T}},drawMode:p[4]};r.push(h),i>x&&i--}e.lodPlanes=r,e.sizeLods=n,e.sigmas=t}(t);const a={n:20,CUBEUV_TEXEL_WIDTH:1/t.renderTargetWidth,CUBEUV_TEXEL_HEIGHT:1/t.renderTargetHeight,CUBEUV_MAX_MIP:`${t.lodMax}.0`};let l,f,v,m,d;function T(e){l=e}function g(){return l}function _(e){f=e}function M(){return f}function h(e){v=e}function U(){return v}function R(e){m=e}function P(){return m}function w(e){d=e}function z(){return d}const N=(Math.floor((2*(t.lodPlanes.length-1)-1)/2)+1)%2==0?M:P;return{programs:[{createProgram:C(t,e,T),setupProgram:[F,o,c,X(t,h,_)],useProgram:u,selectProgram:s,setupMaterial:[(H=e instanceof WebGLTexture,function(){const{gl:e,program:r}=E,n=e.getUniformLocation(r,"flipEnvMap");e.uniform1f(n,H?1:-1)}),B(g)],setupCamera:()=>()=>{},setFrameBuffer:O(U,t,y,!0),meshes:[t.lodPlanes[0]]},...new Array(2*(t.lodPlanes.length-1)).fill(0).map(((e,r)=>{const n=Math.floor(r/2)+1,i=r%2==0,l=i?"latitudinal":"longitudinal",f=i?z:U,v=i?M:P,m=Math.sqrt(t.sigmas[n]*t.sigmas[n]-t.sigmas[n-1]*t.sigmas[n-1]),E=A[(t.lodPlanes.length-n-1)%A.length],p=i?n-1:n,d=n,b=t.sizeLods[p]-1,y=isFinite(m)?Math.PI/(2*b):2*Math.PI/39,C=m/y,F=isFinite(m)?1+Math.floor(3*C):20,H=[];let G=0;for(let e=0;e<20;++e){const r=e/C,n=Math.exp(-r*r/2);H.push(n),0===e?G+=n:e<F&&(G+=2*n)}for(let e=0;e<H.length;e++)H[e]=H[e]/G;const W=t.sizeLods[d],Y=3*W*(d>t.lodMax-x?d-t.lodMax+x:0),j=4*(t.cubeSize-W),q=3*W,$=2*W;return{createProgram:V(0!==r),setupProgram:[...0===r?[S(a),o,c,X(t,w,R)]:[]],setupMaterial:[],useProgram:u,selectProgram:s,setupCamera:()=>()=>{},setFrameBuffer:O(f,t,D(Y,j,q,$)),updateProgram:[B(v),L(F,H,"latitudinal"===l,E,y,t.lodMax-p)],meshes:[t.lodPlanes[n]],...r===2*(t.lodPlanes.length-1)-1?{postDraw:I(g,T,M,_,U,h,P,R,z,w,N,t)}:{}}}))],getTexture:N,order:-1,type:"environmentMap",width:t.renderTargetWidth,height:t.renderTargetHeight,lodMax:t.lodMax};var H}function I(e,r,n,t,i,a,o,c,u,s,m,p){return function(){!function(){const{gl:e}=E;e.enable(e.DEPTH_TEST),e.depthMask(!0)}(),function(){const{gl:e}=E;e.disable(e.SCISSOR_TEST),e.scissor(0,0,e.canvas.width,e.canvas.height)}(),function(){const{gl:e}=E;e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!1)}(),l();const{gl:d}=E,T=e();p.image instanceof WebGLTexture||!T||(d.deleteTexture(T),r(null));const g=m(),_=n();_&&_!==g&&(d.deleteTexture(_),t(null));const M=o();M&&M!==g&&(d.deleteTexture(M),c(null));const h=i();h&&(d.deleteFramebuffer(h),a(null));const x=u();x&&(d.deleteFramebuffer(x),s(null)),f.set(v(f).filter((e=>"environmentMap"!==e.type)))}}function L(e,r,n,t,i,a){return function(){const{gl:o,program:c}=E,u=o.getUniformLocation(c,"samples");o.uniform1i(u,e);const s=o.getUniformLocation(c,"weights");o.uniform1fv(s,r);const l=o.getUniformLocation(c,"latitudinal");if(o.uniform1i(l,n?1:0),t){const e=o.getUniformLocation(c,"poleAxis");o.uniform3fv(e,t)}const f=o.getUniformLocation(c,"dTheta");o.uniform1f(f,i);const v=o.getUniformLocation(c,"mipInt");o.uniform1f(v,a)}}function y(e){const r=e.cubeSize;return{x:0,y:0,width:3*r,height:2*r}}function D(e,r,n,t){return function(){return{x:e,y:r,width:n,height:t}}}function C(e,r,n){return function(e){return function(){const{gl:t}=E;if(!t.getExtension("EXT_color_buffer_float"))throw new Error("EXT_color_buffer_float extension not supported");!function(e,r){const{gl:n}=E;if(e instanceof WebGLTexture)return void r(e);n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,!0),n.pixelStorei(n.UNPACK_ALIGNMENT,1),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1);const t=n.createTexture();r(t),n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,n.RGBA16F,e.width,e.height,0,n.RGBA,n.HALF_FLOAT,e.data),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,!0),n.pixelStorei(n.UNPACK_ALIGNMENT,1),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),n.bindTexture(n.TEXTURE_2D,null)}(r,n),m(e)(),function(){const{gl:e}=E;e.disable(e.DEPTH_TEST),e.depthMask(!1)}(),function(){const{gl:e}=E;e.enable(e.SCISSOR_TEST)}()}}}function F(){const{gl:e,program:r}=E;i(e,r,_,h)}function S(r){return function(){const{gl:n,program:t}=E,a=e(M,r)(r);i(n,t,_,a)}}function X(e,r,n){return function(){const{gl:t}=E,{renderTargetWidth:i,renderTargetHeight:a}=e,o=t.createTexture();n(o),t.bindTexture(t.TEXTURE_2D,o),t.texImage2D(t.TEXTURE_2D,0,t.RGBA16F,i,a,0,t.RGBA,t.HALF_FLOAT,null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR);const c=t.createFramebuffer();r(c),t.bindFramebuffer(t.FRAMEBUFFER,c),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,o,0),t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null)}}function B(e){return function(){const{gl:r,program:n}=E,t=r.getUniformLocation(n,"envMap");r.uniform1i(t,0),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,e())}}function O(e=null,r,n,t=!1){return function(){const{gl:i}=E,a=e?e():null,{renderTargetWidth:o,renderTargetHeight:c}=r;if(i.bindFramebuffer(i.FRAMEBUFFER,a),E.fbo!==a&&null!=a){const{x:e,y:a,width:u,height:s}=n(r);i.viewport(e,a,u,s),i.scissor(e,a,u,s),E.frameBufferWidth=o,E.frameBufferHeight=c,t&&(i.clearColor(0,0,0,0),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT|i.STENCIL_BUFFER_BIT))}E.fbo=a}}function V(e=!1){return function(r){return function(){const{gl:n,programMap:t,vaoMap:i}=E;if(t.has(r)||e)e?(t.set(r,E.program),i.set(r,new Map)):E.program=E.programMap.get(r);else{const e=n.createProgram();t.set(r,e),i.set(r,new Map),E.program=e}}}}var w={},z={};Object.defineProperty(z,"__esModule",{value:!0}),z.setMatrixArrayType=function(e){z.ARRAY_TYPE=H=e},z.toRadian=function(e){return e*W},z.equals=function(e,r){return Math.abs(e-r)<=N*Math.max(1,Math.abs(e),Math.abs(r))},z.RANDOM=z.ARRAY_TYPE=z.EPSILON=void 0;var N=1e-6;z.EPSILON=N;var H="undefined"!=typeof Float32Array?Float32Array:Array;z.ARRAY_TYPE=H;var G=Math.random;z.RANDOM=G;var W=Math.PI/180;function Y(e){return Y="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},Y(e)}Math.hypot||(Math.hypot=function(){for(var e=0,r=arguments.length;r--;)e+=arguments[r]*arguments[r];return Math.sqrt(e)}),Object.defineProperty(w,"__esModule",{value:!0}),w.create=function(){var e=new q.ARRAY_TYPE(9);q.ARRAY_TYPE!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0);return e[0]=1,e[4]=1,e[8]=1,e},w.fromMat4=function(e,r){return e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[4],e[4]=r[5],e[5]=r[6],e[6]=r[8],e[7]=r[9],e[8]=r[10],e},w.clone=function(e){var r=new q.ARRAY_TYPE(9);return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r},w.copy=function(e,r){return e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],e},w.fromValues=function(e,r,n,t,i,a,o,c,u){var s=new q.ARRAY_TYPE(9);return s[0]=e,s[1]=r,s[2]=n,s[3]=t,s[4]=i,s[5]=a,s[6]=o,s[7]=c,s[8]=u,s},w.set=function(e,r,n,t,i,a,o,c,u,s){return e[0]=r,e[1]=n,e[2]=t,e[3]=i,e[4]=a,e[5]=o,e[6]=c,e[7]=u,e[8]=s,e};var j=w.identity=function(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e};w.transpose=function(e,r){if(e===r){var n=r[1],t=r[2],i=r[5];e[1]=r[3],e[2]=r[6],e[3]=n,e[5]=r[7],e[6]=t,e[7]=i}else e[0]=r[0],e[1]=r[3],e[2]=r[6],e[3]=r[1],e[4]=r[4],e[5]=r[7],e[6]=r[2],e[7]=r[5],e[8]=r[8];return e},w.invert=function(e,r){var n=r[0],t=r[1],i=r[2],a=r[3],o=r[4],c=r[5],u=r[6],s=r[7],l=r[8],f=l*o-c*s,v=-l*a+c*u,m=s*a-o*u,E=n*f+t*v+i*m;if(!E)return null;return E=1/E,e[0]=f*E,e[1]=(-l*t+i*s)*E,e[2]=(c*t-i*o)*E,e[3]=v*E,e[4]=(l*n-i*u)*E,e[5]=(-c*n+i*a)*E,e[6]=m*E,e[7]=(-s*n+t*u)*E,e[8]=(o*n-t*a)*E,e},w.adjoint=function(e,r){var n=r[0],t=r[1],i=r[2],a=r[3],o=r[4],c=r[5],u=r[6],s=r[7],l=r[8];return e[0]=o*l-c*s,e[1]=i*s-t*l,e[2]=t*c-i*o,e[3]=c*u-a*l,e[4]=n*l-i*u,e[5]=i*a-n*c,e[6]=a*s-o*u,e[7]=t*u-n*s,e[8]=n*o-t*a,e},w.determinant=function(e){var r=e[0],n=e[1],t=e[2],i=e[3],a=e[4],o=e[5],c=e[6],u=e[7],s=e[8];return r*(s*a-o*u)+n*(-s*i+o*c)+t*(u*i-a*c)},w.multiply=k,w.translate=function(e,r,n){var t=r[0],i=r[1],a=r[2],o=r[3],c=r[4],u=r[5],s=r[6],l=r[7],f=r[8],v=n[0],m=n[1];return e[0]=t,e[1]=i,e[2]=a,e[3]=o,e[4]=c,e[5]=u,e[6]=v*t+m*o+s,e[7]=v*i+m*c+l,e[8]=v*a+m*u+f,e},w.rotate=function(e,r,n){var t=r[0],i=r[1],a=r[2],o=r[3],c=r[4],u=r[5],s=r[6],l=r[7],f=r[8],v=Math.sin(n),m=Math.cos(n);return e[0]=m*t+v*o,e[1]=m*i+v*c,e[2]=m*a+v*u,e[3]=m*o-v*t,e[4]=m*c-v*i,e[5]=m*u-v*a,e[6]=s,e[7]=l,e[8]=f,e},w.scale=function(e,r,n){var t=n[0],i=n[1];return e[0]=t*r[0],e[1]=t*r[1],e[2]=t*r[2],e[3]=i*r[3],e[4]=i*r[4],e[5]=i*r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],e},w.fromTranslation=function(e,r){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=r[0],e[7]=r[1],e[8]=1,e},w.fromRotation=function(e,r){var n=Math.sin(r),t=Math.cos(r);return e[0]=t,e[1]=n,e[2]=0,e[3]=-n,e[4]=t,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},w.fromScaling=function(e,r){return e[0]=r[0],e[1]=0,e[2]=0,e[3]=0,e[4]=r[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e},w.fromMat2d=function(e,r){return e[0]=r[0],e[1]=r[1],e[2]=0,e[3]=r[2],e[4]=r[3],e[5]=0,e[6]=r[4],e[7]=r[5],e[8]=1,e},w.fromQuat=function(e,r){var n=r[0],t=r[1],i=r[2],a=r[3],o=n+n,c=t+t,u=i+i,s=n*o,l=t*o,f=t*c,v=i*o,m=i*c,E=i*u,p=a*o,d=a*c,T=a*u;return e[0]=1-f-E,e[3]=l-T,e[6]=v+d,e[1]=l+T,e[4]=1-s-E,e[7]=m-p,e[2]=v-d,e[5]=m+p,e[8]=1-s-f,e},w.normalFromMat4=function(e,r){var n=r[0],t=r[1],i=r[2],a=r[3],o=r[4],c=r[5],u=r[6],s=r[7],l=r[8],f=r[9],v=r[10],m=r[11],E=r[12],p=r[13],d=r[14],T=r[15],g=n*c-t*o,_=n*u-i*o,M=n*s-a*o,h=t*u-i*c,x=t*s-a*c,b=i*s-a*u,U=l*p-f*E,R=l*d-v*E,A=l*T-m*E,P=f*d-v*p,I=f*T-m*p,L=v*T-m*d,y=g*L-_*I+M*P+h*A-x*R+b*U;if(!y)return null;return y=1/y,e[0]=(c*L-u*I+s*P)*y,e[1]=(u*A-o*L-s*R)*y,e[2]=(o*I-c*A+s*U)*y,e[3]=(i*I-t*L-a*P)*y,e[4]=(n*L-i*A+a*R)*y,e[5]=(t*A-n*I-a*U)*y,e[6]=(p*b-d*x+T*h)*y,e[7]=(d*M-E*b-T*_)*y,e[8]=(E*x-p*M+T*g)*y,e},w.projection=function(e,r,n){return e[0]=2/r,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e},w.str=function(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"},w.frob=function(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])},w.add=function(e,r,n){return e[0]=r[0]+n[0],e[1]=r[1]+n[1],e[2]=r[2]+n[2],e[3]=r[3]+n[3],e[4]=r[4]+n[4],e[5]=r[5]+n[5],e[6]=r[6]+n[6],e[7]=r[7]+n[7],e[8]=r[8]+n[8],e},w.subtract=K,w.multiplyScalar=function(e,r,n){return e[0]=r[0]*n,e[1]=r[1]*n,e[2]=r[2]*n,e[3]=r[3]*n,e[4]=r[4]*n,e[5]=r[5]*n,e[6]=r[6]*n,e[7]=r[7]*n,e[8]=r[8]*n,e},w.multiplyScalarAndAdd=function(e,r,n,t){return e[0]=r[0]+n[0]*t,e[1]=r[1]+n[1]*t,e[2]=r[2]+n[2]*t,e[3]=r[3]+n[3]*t,e[4]=r[4]+n[4]*t,e[5]=r[5]+n[5]*t,e[6]=r[6]+n[6]*t,e[7]=r[7]+n[7]*t,e[8]=r[8]+n[8]*t,e},w.exactEquals=function(e,r){return e[0]===r[0]&&e[1]===r[1]&&e[2]===r[2]&&e[3]===r[3]&&e[4]===r[4]&&e[5]===r[5]&&e[6]===r[6]&&e[7]===r[7]&&e[8]===r[8]},w.equals=function(e,r){var n=e[0],t=e[1],i=e[2],a=e[3],o=e[4],c=e[5],u=e[6],s=e[7],l=e[8],f=r[0],v=r[1],m=r[2],E=r[3],p=r[4],d=r[5],T=r[6],g=r[7],_=r[8];return Math.abs(n-f)<=q.EPSILON*Math.max(1,Math.abs(n),Math.abs(f))&&Math.abs(t-v)<=q.EPSILON*Math.max(1,Math.abs(t),Math.abs(v))&&Math.abs(i-m)<=q.EPSILON*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(a-E)<=q.EPSILON*Math.max(1,Math.abs(a),Math.abs(E))&&Math.abs(o-p)<=q.EPSILON*Math.max(1,Math.abs(o),Math.abs(p))&&Math.abs(c-d)<=q.EPSILON*Math.max(1,Math.abs(c),Math.abs(d))&&Math.abs(u-T)<=q.EPSILON*Math.max(1,Math.abs(u),Math.abs(T))&&Math.abs(s-g)<=q.EPSILON*Math.max(1,Math.abs(s),Math.abs(g))&&Math.abs(l-_)<=q.EPSILON*Math.max(1,Math.abs(l),Math.abs(_))},w.sub=w.mul=void 0;var q=function(e,r){if(e&&e.__esModule)return e;if(null===e||"object"!==Y(e)&&"function"!=typeof e)return{default:e};var n=$(r);if(n&&n.has(e))return n.get(e);var t={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in e)if("default"!==a&&Object.prototype.hasOwnProperty.call(e,a)){var o=i?Object.getOwnPropertyDescriptor(e,a):null;o&&(o.get||o.set)?Object.defineProperty(t,a,o):t[a]=e[a]}t.default=e,n&&n.set(e,t);return t}(z);function $(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,n=new WeakMap;return($=function(e){return e?n:r})(e)}function k(e,r,n){var t=r[0],i=r[1],a=r[2],o=r[3],c=r[4],u=r[5],s=r[6],l=r[7],f=r[8],v=n[0],m=n[1],E=n[2],p=n[3],d=n[4],T=n[5],g=n[6],_=n[7],M=n[8];return e[0]=v*t+m*o+E*s,e[1]=v*i+m*c+E*l,e[2]=v*a+m*u+E*f,e[3]=p*t+d*o+T*s,e[4]=p*i+d*c+T*l,e[5]=p*a+d*u+T*f,e[6]=g*t+_*o+M*s,e[7]=g*i+_*c+M*l,e[8]=g*a+_*u+M*f,e}function K(e,r,n){return e[0]=r[0]-n[0],e[1]=r[1]-n[1],e[2]=r[2]-n[2],e[3]=r[3]-n[3],e[4]=r[4]-n[4],e[5]=r[5]-n[5],e[6]=r[6]-n[6],e[7]=r[7]-n[7],e[8]=r[8]-n[8],e}var Q=k;w.mul=Q;var Z=K;w.sub=Z;const J="envMap",ee=({envMap:r,width:n,height:t,lodMax:i,envMapIntensity:a=1,envMapRotation:o=j([])})=>{const c={CUBEUV_TEXEL_WIDTH:1/n,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${i}.0`};let u;return{type:J,...a&&{envMapIntensity:a},...o&&{envMapRotation:o},shader:e("${declaration?\r\n`\r\n#define PI 3.141592653589793\r\n\r\n#define CUBEUV_TEXEL_WIDTH ${CUBEUV_TEXEL_WIDTH}\r\n#define CUBEUV_TEXEL_HEIGHT ${CUBEUV_TEXEL_HEIGHT}\r\n#define CUBEUV_MAX_MIP ${CUBEUV_MAX_MIP}\r\n\r\n#define cubeUV_minMipLevel 4.0\r\n#define cubeUV_minTileSize 16.0\r\n\r\nuniform float envMapIntensity;\r\nuniform mat3 envMapRotation;\r\nuniform sampler2D envMap;\r\n\r\nfloat getFace( vec3 direction ) {\r\n    vec3 absDirection = abs( direction );\r\n    float face = - 1.0;\r\n    if ( absDirection.x > absDirection.z ) {\r\n        if ( absDirection.x > absDirection.y )\r\n        face = direction.x > 0.0 ? 0.0 : 3.0;\r\n        else\r\n        face = direction.y > 0.0 ? 1.0 : 4.0;\r\n    }\r\n    else {\r\n        if ( absDirection.z > absDirection.y )\r\n        face = direction.z > 0.0 ? 2.0 : 5.0;\r\n        else\r\n        face = direction.y > 0.0 ? 1.0 : 4.0;\r\n    }\r\n    return face;\r\n}\r\nvec2 getUV( vec3 direction, float face ) {\r\n    vec2 uv;\r\n    if ( face == 0.0 ) {\r\n        uv = vec2( direction.z, direction.y ) / abs( direction.x );\r\n    }\r\n    else if ( face == 1.0 ) {\r\n        uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\r\n    }\r\n    else if ( face == 2.0 ) {\r\n        uv = vec2( - direction.x, direction.y ) / abs( direction.z );\r\n    }\r\n    else if ( face == 3.0 ) {\r\n        uv = vec2( - direction.z, direction.y ) / abs( direction.x );\r\n    }\r\n    else if ( face == 4.0 ) {\r\n        uv = vec2( - direction.x, direction.z ) / abs( direction.y );\r\n    }\r\n    else {\r\n        uv = vec2( direction.x, direction.y ) / abs( direction.z );\r\n    }\r\n    return 0.5 * ( uv + 1.0 );\r\n}\r\n\r\nvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\r\n    float face = getFace( direction );\r\n    float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\r\n    mipInt = max( mipInt, cubeUV_minMipLevel );\r\n    float faceSize = exp2( mipInt );\r\n    highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\r\n    if ( face > 2.0 ) {\r\n        uv.y += faceSize;\r\n        face -= 3.0;\r\n    }\r\n    uv.x += face * faceSize;\r\n    uv.x += filterInt * 3.0 * cubeUV_minTileSize;\r\n    uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\r\n    uv.x *= CUBEUV_TEXEL_WIDTH;\r\n    uv.y *= CUBEUV_TEXEL_HEIGHT;\r\n    //return texture( envMap, uv).rgb;\r\n    return textureGrad( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\r\n}\r\nfloat roughnessToMip( float roughness ) {\r\n    float mip = 0.0;\r\n    if ( roughness >= 0.8 ) {\r\n        mip = ( 1.0 - roughness ) * ( - 1.0 - - 2.0 ) / ( 1.0 - 0.8 ) + - 2.0;\r\n    }\r\n    else if ( roughness >= 0.4 ) {\r\n        mip = ( 0.8 - roughness ) * ( 2.0 - - 1.0 ) / ( 0.8 - 0.4 ) + - 1.0;\r\n    }\r\n    else if ( roughness >= 0.305 ) {\r\n        mip = ( 0.4 - roughness ) * ( 3.0 - 2.0 ) / ( 0.4 - 0.305 ) + 2.0;\r\n    }\r\n    else if ( roughness >= 0.21 ) {\r\n        mip = ( 0.305 - roughness ) * ( 4.0 - 3.0 ) / ( 0.305 - 0.21 ) + 3.0;\r\n    }\r\n    else {\r\n        mip = - 2.0 * log2( 1.16 * roughness );\r\n    }\r\n    return mip;\r\n}\r\nvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\r\n    float mip = clamp( roughnessToMip( roughness ), - 2.0, 8.0 );\r\n    float mipF = fract( mip );\r\n    float mipInt = floor( mip );\r\n    vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\r\n    if ( mipF == 0.0 ) {\r\n        return vec4( color0, 1.0 );\r\n    }\r\n    else {\r\n        vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\r\n        return vec4( mix( color0, color1, mipF ), 1.0 );\r\n    }\r\n}\r\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\r\n    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\r\n}\r\nvec3 getIBLIrradiance( const in vec3 normal ) {\r\n    vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\r\n    vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\r\n    return PI * envMapColor.rgb * envMapIntensity;\r\n}\r\nvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\r\n    vec3 reflectVec = reflect( - viewDir, normal );\r\n    reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\r\n    reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\r\n    vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\r\n    return envMapColor.rgb * envMapIntensity;\r\n}\r\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\r\n    float dotNV = saturate( dot( normal, viewDir ) );\r\n    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\r\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\r\n    vec4 r = roughness * c0 + c1;\r\n    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\r\n    vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\r\n    return fab;\r\n}\r\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\r\n    vec2 fab = DFGApprox( normal, viewDir, roughness );\r\n    vec3 Fr = specularColor;\r\n    vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\r\n    float Ess = fab.x + fab.y;\r\n    float Ems = 1.0 - Ess;\r\n    vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\r\n    vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\r\n    singleScatter += FssEss;\r\n    multiScatter += Fms * Ems;\r\n}\r\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\r\n    vec3 singleScattering = vec3( 0.0 );\r\n    vec3 multiScattering = vec3( 0.0 );\r\n    vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\r\n    computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\r\n    vec3 totalScattering = singleScattering + multiScattering;\r\n    vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\r\n    reflectedLight.indirectSpecular += radiance * singleScattering;\r\n    reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\r\n    reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\r\n}\r\n` : ''\r\n}\r\n${irradiance?\r\n`\r\n    vec3 geometryClearcoatNormal = vec3( 0.0 );\r\n    vec3 clearcoatRadiance = vec3( 0.0 );\r\n    vec3 iblIrradiance = vec3( 0.0 );\r\n    vec3 radiance = vec3( 0.0 );\r\n    iblIrradiance += getIBLIrradiance( geometryNormal );\r\n    radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\r\n    RE_IndirectSpecular_Physical( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\r\n` : ''\r\n}\r\n",{declaration:!1,irradiance:!1,CUBEUV_TEXEL_WIDTH:0,CUBEUV_TEXEL_HEIGHT:0,CUBEUV_MAX_MIP:0}),shaderDefines:c,setupTexture:ne(r,(function(e){u=e}),a,o),bindTexture:re((function(){return u})),envMap:r}};function re(e){return function(){const{gl:r,program:n}=E,t=r.getUniformLocation(n,J);r.activeTexture(r.TEXTURE3),r.bindTexture(r.TEXTURE_2D,e()),r.uniform1i(t,3)}}function ne(e,r,n,t){return function(){const{gl:i,program:a}=E;r(e());const o=i.getUniformLocation(a,J);i.activeTexture(i.TEXTURE3),i.bindTexture(i.TEXTURE_2D,e()),i.uniform1i(o,3),i.uniform1f(i.getUniformLocation(a,"envMapIntensity"),n),i.uniformMatrix3fv(i.getUniformLocation(a,"envMapRotation"),!1,t)}}export{P as a,ee as b,d as c,g,T as h};
