function t(){}function e(t){return t()}function n(){return Object.create(null)}function r(t){t.forEach(e)}function o(t){return"function"==typeof t}function a(t,e){return t!=t?e==e:t!==e||t&&"object"==typeof t||"function"==typeof t}function i(e,...n){if(null==e){for(const t of n)t(void 0);return t}const r=e.subscribe(...n);return r.unsubscribe?()=>r.unsubscribe():r}function s(t){let e;return i(t,(t=>e=t))(),e}function c(t,e,n){t.$$.on_destroy.push(i(e,n))}function u(t,e,n){return t.set(n),e}function l(t,e,n){t.insertBefore(e,n||null)}function f(t){t.parentNode&&t.parentNode.removeChild(t)}function p(t){return document.createElement(t)}let d;function m(t){d=t}function h(t){(function(){if(!d)throw new Error("Function called outside component initialization");return d})().$$.on_mount.push(t)}const g=[],v=[];let b=[];const M=[],y=Promise.resolve();let A=!1;function x(t){b.push(t)}const E=new Set;let L=0;function R(){if(0!==L)return;const t=d;do{try{for(;L<g.length;){const t=g[L];L++,m(t),_(t.$$)}}catch(t){throw g.length=0,L=0,t}for(m(null),g.length=0,L=0;v.length;)v.pop()();for(let t=0;t<b.length;t+=1){const e=b[t];E.has(e)||(E.add(e),e())}b.length=0}while(g.length);for(;M.length;)M.pop()();A=!1,E.clear(),m(t)}function _(t){if(null!==t.fragment){t.update(),r(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(x)}}const P=new Set;function T(t,e){const n=t.$$;null!==n.fragment&&(!function(t){const e=[],n=[];b.forEach((r=>-1===t.indexOf(r)?e.push(r):n.push(r))),n.forEach((t=>t())),b=e}(n.after_update),r(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}function F(t,e){-1===t.$$.dirty[0]&&(g.push(t),A||(A=!0,y.then(R)),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function w(a,i,s,c,u,l,p=null,h=[-1]){const g=d;m(a);const v=a.$$={fragment:null,ctx:[],props:l,update:t,not_equal:u,bound:n(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(i.context||(g?g.$$.context:[])),callbacks:n(),dirty:h,skip_bound:!1,root:i.target||g.$$.root};p&&p(v.root);let b=!1;if(v.ctx=s?s(a,i.props||{},((t,e,...n)=>{const r=n.length?n[0]:e;return v.ctx&&u(v.ctx[t],v.ctx[t]=r)&&(!v.skip_bound&&v.bound[t]&&v.bound[t](r),b&&F(a,t)),e})):[],v.update(),b=!0,r(v.before_update),v.fragment=!!c&&c(v.ctx),i.target){if(i.hydrate){const t=function(t){return Array.from(t.childNodes)}(i.target);v.fragment&&v.fragment.l(t),t.forEach(f)}else v.fragment&&v.fragment.c();i.intro&&((M=a.$$.fragment)&&M.i&&(P.delete(M),M.i(y))),function(t,n,a){const{fragment:i,after_update:s}=t.$$;i&&i.m(n,a),x((()=>{const n=t.$$.on_mount.map(e).filter(o);t.$$.on_destroy?t.$$.on_destroy.push(...n):r(n),t.$$.on_mount=[]})),s.forEach(x)}(a,i.target,i.anchor),R()}var M,y;m(g)}class S{$$=void 0;$$set=void 0;$destroy(){T(this,1),this.$destroy=t}$on(e,n){if(!o(n))return t;const r=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return r.push(n),()=>{const t=r.indexOf(n);-1!==t&&r.splice(t,1)}}$set(t){var e;this.$$set&&(e=t,0!==Object.keys(e).length)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}"undefined"!=typeof window&&(window.__svelte||(window.__svelte={v:new Set})).v.add("4");const B=[];function D(e,n=t){let r;const o=new Set;function i(t){if(a(e,t)&&(e=t,r)){const t=!B.length;for(const t of o)t[1](),B.push(t,e);if(t){for(let t=0;t<B.length;t+=2)B[t][0](B[t+1]);B.length=0}}}function s(t){i(t(e))}return{set:i,update:s,subscribe:function(a,c=t){const u=[a,c];return o.add(u),1===o.size&&(r=n(i,s)||t),a(e),()=>{o.delete(u),0===o.size&&r&&(r(),r=null)}}}}function U(e,n,a){const s=!Array.isArray(e),c=s?[e]:e;if(!c.every(Boolean))throw new Error("derived() expects stores as input, got a falsy value");const u=n.length<2;return l=(e,a)=>{let l=!1;const f=[];let p=0,d=t;const m=()=>{if(p)return;d();const r=n(s?f[0]:f,e,a);u?e(r):d=o(r)?r:t},h=c.map(((t,e)=>i(t,(t=>{f[e]=t,p&=~(1<<e),l&&m()}),(()=>{p|=1<<e}))));return l=!0,m(),function(){r(h),d(),l=!1}},{subscribe:D(a,l).subscribe};var l}var $=1e-6,C="undefined"!=typeof Float32Array?Float32Array:Array;function I(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function N(t,e,n){var r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],c=e[5],u=e[6],l=e[7],f=e[8],p=e[9],d=e[10],m=e[11],h=e[12],g=e[13],v=e[14],b=e[15],M=n[0],y=n[1],A=n[2],x=n[3];return t[0]=M*r+y*s+A*f+x*h,t[1]=M*o+y*c+A*p+x*g,t[2]=M*a+y*u+A*d+x*v,t[3]=M*i+y*l+A*m+x*b,M=n[4],y=n[5],A=n[6],x=n[7],t[4]=M*r+y*s+A*f+x*h,t[5]=M*o+y*c+A*p+x*g,t[6]=M*a+y*u+A*d+x*v,t[7]=M*i+y*l+A*m+x*b,M=n[8],y=n[9],A=n[10],x=n[11],t[8]=M*r+y*s+A*f+x*h,t[9]=M*o+y*c+A*p+x*g,t[10]=M*a+y*u+A*d+x*v,t[11]=M*i+y*l+A*m+x*b,M=n[12],y=n[13],A=n[14],x=n[15],t[12]=M*r+y*s+A*f+x*h,t[13]=M*o+y*c+A*p+x*g,t[14]=M*a+y*u+A*d+x*v,t[15]=M*i+y*l+A*m+x*b,t}function O(t,e,n){var r,o,a,i,s,c,u,l,f,p,d,m,h=n[0],g=n[1],v=n[2];return e===t?(t[12]=e[0]*h+e[4]*g+e[8]*v+e[12],t[13]=e[1]*h+e[5]*g+e[9]*v+e[13],t[14]=e[2]*h+e[6]*g+e[10]*v+e[14],t[15]=e[3]*h+e[7]*g+e[11]*v+e[15]):(r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],c=e[5],u=e[6],l=e[7],f=e[8],p=e[9],d=e[10],m=e[11],t[0]=r,t[1]=o,t[2]=a,t[3]=i,t[4]=s,t[5]=c,t[6]=u,t[7]=l,t[8]=f,t[9]=p,t[10]=d,t[11]=m,t[12]=r*h+s*g+f*v+e[12],t[13]=o*h+c*g+p*v+e[13],t[14]=a*h+u*g+d*v+e[14],t[15]=i*h+l*g+m*v+e[15]),t}function Y(t,e,n){var r=n[0],o=n[1],a=n[2];return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t[4]=e[4]*o,t[5]=e[5]*o,t[6]=e[6]*o,t[7]=e[7]*o,t[8]=e[8]*a,t[9]=e[9]*a,t[10]=e[10]*a,t[11]=e[11]*a,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function q(t,e,n){var r=Math.sin(n),o=Math.cos(n),a=e[0],i=e[1],s=e[2],c=e[3],u=e[8],l=e[9],f=e[10],p=e[11];return e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=a*o-u*r,t[1]=i*o-l*r,t[2]=s*o-f*r,t[3]=c*o-p*r,t[8]=a*r+u*o,t[9]=i*r+l*o,t[10]=s*r+f*o,t[11]=c*r+p*o,t}function V(t,e,n){var r=Math.sin(n),o=Math.cos(n),a=e[0],i=e[1],s=e[2],c=e[3],u=e[4],l=e[5],f=e[6],p=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=a*o+u*r,t[1]=i*o+l*r,t[2]=s*o+f*r,t[3]=c*o+p*r,t[4]=u*o-a*r,t[5]=l*o-i*r,t[6]=f*o-s*r,t[7]=p*o-c*r,t}function k(t,e){return t[0]=e[12],t[1]=e[13],t[2]=e[14],t}function z(t,e,n,r){var o=e[0],a=e[1],i=e[2],s=e[3],c=o+o,u=a+a,l=i+i,f=o*c,p=o*u,d=o*l,m=a*u,h=a*l,g=i*l,v=s*c,b=s*u,M=s*l,y=r[0],A=r[1],x=r[2];return t[0]=(1-(m+g))*y,t[1]=(p+M)*y,t[2]=(d-b)*y,t[3]=0,t[4]=(p-M)*A,t[5]=(1-(f+g))*A,t[6]=(h+v)*A,t[7]=0,t[8]=(d+b)*x,t[9]=(h-v)*x,t[10]=(1-(f+m))*x,t[11]=0,t[12]=n[0],t[13]=n[1],t[14]=n[2],t[15]=1,t}Math.hypot||(Math.hypot=function(){for(var t=0,e=arguments.length;e--;)t+=arguments[e]*arguments[e];return Math.sqrt(t)});var j=function(t,e,n,r,o){var a,i=1/Math.tan(e/2);return t[0]=i/n,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=o&&o!==1/0?(a=1/(r-o),t[10]=(o+r)*a,t[14]=2*o*r*a):(t[10]=-1,t[14]=-2*r),t};function G(t,e,n,r,o,a,i){var s=1/(e-n),c=1/(r-o),u=1/(a-i);return t[0]=-2*s,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*c,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*u,t[11]=0,t[12]=(e+n)*s,t[13]=(o+r)*c,t[14]=(i+a)*u,t[15]=1,t}function W(t,e,n,r){var o,a,i,s,c,u,l,f,p,d,m=e[0],h=e[1],g=e[2],v=r[0],b=r[1],M=r[2],y=n[0],A=n[1],x=n[2];return Math.abs(m-y)<$&&Math.abs(h-A)<$&&Math.abs(g-x)<$?I(t):(l=m-y,f=h-A,p=g-x,o=b*(p*=d=1/Math.hypot(l,f,p))-M*(f*=d),a=M*(l*=d)-v*p,i=v*f-b*l,(d=Math.hypot(o,a,i))?(o*=d=1/d,a*=d,i*=d):(o=0,a=0,i=0),s=f*i-p*a,c=p*o-l*i,u=l*a-f*o,(d=Math.hypot(s,c,u))?(s*=d=1/d,c*=d,u*=d):(s=0,c=0,u=0),t[0]=o,t[1]=s,t[2]=l,t[3]=0,t[4]=a,t[5]=c,t[6]=f,t[7]=0,t[8]=i,t[9]=u,t[10]=p,t[11]=0,t[12]=-(o*m+a*h+i*g),t[13]=-(s*m+c*h+u*g),t[14]=-(l*m+f*h+p*g),t[15]=1,t)}const X=(t,e)=>{const n=Function.constructor(...Object.entries(e).map((([t,e])=>(""===e&&(e='""'),`${t}${null!=e?`=${e}`:""}`))),`return \`${t}\``);return t=>n(...Object.keys(e).map((e=>null!=t[e]?t[e]:void 0)))};function H(t){return Array.isArray(t)?[...t]:"number"==typeof t?K(t):"string"==typeof t&&t.startsWith("#")?K(parseInt(t.replace("#","0x"))):t}function K(t){return[(t>>16&255)/255,(t>>8&255)/255,(255&t)/255]}function J(t,e){return 3===e?t:t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}const Q=0,Z=Math.PI/180;function tt(){const t=Xt.canvas.getBoundingClientRect();Xt.canvas.width=t.width,Xt.canvas.height=t.height;const e=Xt.canvas.getContext("webgl2");Xt.gl=e,e.enable(e.DEPTH_TEST),e.enable(e.CULL_FACE),e.frontFace(e.CCW),e.cullFace(e.BACK)}function et(){const{gl:t}=Xt;t.enable(t.BLEND),t.blendFunc(t.ONE,t.ONE_MINUS_SRC_ALPHA)}function nt(){const{gl:t}=Xt;t.disable(t.BLEND)}function rt(){const{gl:t,program:e}=Xt,n=t.getUniformLocation(e,"time");t.uniform1f(n,performance.now())}function ot(t,e,n){return function(){const{gl:r,program:o}=Xt,a=t.attributes.positionsSize??3,i=t.attributes.elements?t.attributes.elements.length:t.attributes.positions.length/a;e?r.drawArraysInstanced(r[n],0,i,e):t.attributes.elements?r.drawElements(r[n],i,r.UNSIGNED_SHORT,0):r.drawArrays(r[n],0,i),r.bindVertexArray(null)}}function at(){const{gl:t,vao:e}=Xt;t.bindVertexArray(e)}function it(t){return function(){const{gl:e}=Xt,n=e.createProgram();Xt.programMap.set(t,n),Xt.vaoMap.set(t,new Map),Xt.program=n}}function st(){const{gl:t,program:e}=Xt;t.linkProgram(e),t.getProgramParameter(e,t.LINK_STATUS)||console.error("ERROR linking program!",t.getProgramInfoLog(e))}function ct(){const{gl:t,program:e}=Xt;t.validateProgram(e),t.getProgramParameter(e,t.VALIDATE_STATUS)||console.error("ERROR validating program!",t.getProgramInfoLog(e))}function ut(){const{gl:t,program:e}=Xt;t.useProgram(e)}function lt(){const{gl:t,backgroundColor:e}=Xt;t.bindFramebuffer(t.FRAMEBUFFER,null),t.viewport(0,0,t.canvas.width,t.canvas.height),Xt.frameBufferWidth=t.canvas.width,Xt.frameBufferHeight=t.canvas.height,t.clearColor(...e),t.clear(t.COLOR_BUFFER_BIT|t.DEPTH_BUFFER_BIT)}function ft(t,e,n,r){return function(){const{gl:o,program:a}=Xt;let i="",s="",c="",u="";const[l]=e,f=l.animations?.filter((({type:t})=>"vertex"===t));f?.length>0&&(c+=f.reduce(((t,e)=>t+e.shader({declaration:!0})),""),u+=f.reduce(((t,e)=>t+e.shader({position:!0})),""),i+=c,s+=u);const p=X("#version 300 es\r\nprecision mediump float;\r\n    \r\nin vec3 position;\r\nin vec3 normal;\r\nin vec2 uv;\r\n${instances ?\r\n`\r\nin mat4 world;\r\nin mat4 normalMatrix;\r\n` : `\r\nuniform mat4 world;\r\nuniform mat4 normalMatrix;\r\n`}\r\n\r\n\r\nuniform float time;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\n// Pass the color attribute down to the fragment shader\r\nout vec3 vertexColor;\r\nout vec3 vNormal;\r\nout vec3 vertex;\r\nout vec3 vViewPosition;\r\nout highp vec2 vUv;\r\n\r\n${declarations}\r\n\r\nvoid main() {\r\n    vec3 modifiedNormal = normal;\r\n    vec3 animatedPosition = position;\r\n    ${positionModifier}\r\n\r\n    vUv = vec3( uv, 1 ).xy;\r\n    // Pass the color down to the fragment shader\r\n    vertexColor = vec3(1.27,1.27,1.27);\r\n    // Pass the vertex down to the fragment shader\r\n    //vertex = vec3(world * vec4(position, 1.0));\r\n    vertex = vec3(world * vec4(animatedPosition, 1.0));\r\n    // Pass the normal down to the fragment shader\r\n    // todo : use modifiedNormal when effect is done\r\n    vNormal = vec3(normalMatrix * vec4(modifiedNormal , 1.0));\r\n    //vNormal = normal;\r\n    \r\n    // Pass the position down to the fragment shader\r\n    gl_Position = projection * view * world * vec4(animatedPosition, 1.0);\r\n    vViewPosition = -gl_Position.xyz;\r\n}",{instances:!1,declarations:"",positionModifier:""})({instances:l.instances>1,declarations:i,positionModifier:s}),d=o.createShader(o.VERTEX_SHADER);o.shaderSource(d,p),o.compileShader(d),o.getShaderParameter(d,o.COMPILE_STATUS)||console.error("ERROR compiling vertex shader!",o.getShaderInfoLog(d));let m="",h="";t.specular&&(h=t.specular.shader({declaration:!0}),m=t.specular.shader({irradiance:!0}),console.log("specularIrradiance",m),console.log("specularDeclaration",h));let g="",v="";t.diffuseMap&&(g=t.diffuseMap.shader({declaration:!0,mapType:t.diffuseMap.type}),v=t.diffuseMap.shader({diffuseMapSample:!0,mapType:t.diffuseMap.type,coordinateSpace:t.diffuseMap.coordinateSpace}));let b="",M="";t.normalMap&&(b=t.normalMap.shader({declaration:!0,mapType:t.normalMap.type}),M=t.normalMap.shader({normalMapSample:!0,mapType:t.normalMap.type}));const y=X("#version 300 es\r\nprecision mediump float;\r\n\r\n${defines}\r\n\r\n#define RECIPROCAL_PI 0.3183098861837907\r\n\r\nuniform vec3 diffuse;\r\nuniform float opacity;\r\nuniform float metalness;\r\nuniform vec3 ambientLightColor;\r\nuniform vec3 cameraPosition;\r\n//uniform mat3 normalMatrix;\r\n\r\nin vec3 vertex;\r\nin vec3 vNormal;\r\nin highp vec2 vUv;\r\nin vec3 vViewPosition;\r\n\r\nout vec4 fragColor;\r\n\r\nstruct ReflectedLight {\r\n\tvec3 directDiffuse;\r\n\tvec3 directSpecular;\r\n\tvec3 indirectDiffuse;\r\n\tvec3 indirectSpecular;\r\n};\r\n\r\nstruct PhysicalMaterial {\r\n\tvec3 diffuseColor;\r\n\tfloat diffuseAlpha;\r\n\tfloat roughness;\r\n\tvec3 specularColor;\r\n\tfloat specularF90;\r\n\tfloat ior;\r\n};\r\n\r\nvec3 BRDF_Lambert(const in vec3 diffuseColor) {\r\n\treturn RECIPROCAL_PI * diffuseColor;\r\n}\r\n\r\n\r\n${declarations}\r\n\r\nvec4 sRGBTransferOETF(in vec4 value) {\r\n\treturn vec4(mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308)))), value.a);\r\n}\r\n\r\nvec4 linearToOutputTexel(vec4 value) {\r\n\treturn (sRGBTransferOETF(value));\r\n}\r\n\r\nvoid main() {\r\n    PhysicalMaterial material;\r\n\tmaterial.diffuseAlpha = 1.0;\r\n\tmaterial.diffuseColor = diffuse.rgb * (1.0 - metalness);\r\n\t${diffuseMapSample}\r\n\t\r\n\r\n\tvec3 normal = normalize( vNormal );\r\n\t${normalMapSample}\r\n\r\n    ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\r\n\r\n    reflectedLight.indirectDiffuse += ambientLightColor * BRDF_Lambert(material.diffuseColor);\r\n\r\n    vec3 totalIrradiance = vec3(0.0f);\r\n    ${irradiance}\r\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse + reflectedLight.directDiffuse + reflectedLight.directSpecular;\r\n    fragColor = vec4(outgoingLight, opacity*material.diffuseAlpha);\r\n    //fragColor = vec4(totalIrradiance, 1.0f);\r\n    ${toneMapping}\r\n\tfragColor = linearToOutputTexel(fragColor);\r\n}",{defines:"",declarations:"",diffuseMapSample:"",normalMapSample:"",irradiance:"",toneMapping:"",numPointLights:0})({defines:(A={...n?{NUM_POINT_LIGHTS:n}:void 0},["",...Object.entries(A).map((([t,e])=>`#define ${t} ${e}`))].join("\n")),declarations:[...n?[r({declaration:!0,irradiance:!1})]:[],...Xt.toneMappings?.length>0?[...Xt.toneMappings.map((t=>t.shader({declaration:!0,exposure:t.exposure})))]:[],...t.specular?[h]:[],...t.diffuseMap?[g]:[],...t.normalMap?[b]:[]].join("\n"),diffuseMapSample:v,normalMapSample:M,irradiance:[...n?[r({declaration:!1,irradiance:!0,specularIrradiance:m})]:[]].join("\n"),toneMapping:[...Xt.toneMappings?.length>0?[...Xt.toneMappings.map((t=>t.shader({color:!0})))]:[]].join("\n"),numPointLights:n});var A;const x=o.createShader(o.FRAGMENT_SHADER);o.shaderSource(x,y),o.compileShader(x),o.getShaderParameter(x,o.COMPILE_STATUS)||console.error("ERROR compiling fragment shader!",o.getShaderInfoLog(x)),o.attachShader(a,d),o.attachShader(a,x)}}function pt({diffuse:t,metalness:e,opacity:n}){return function(){const{gl:r,program:o}=Xt,a=r.getUniformLocation(o,"diffuse");if(null==a)return;r.uniform3fv(a,new Float32Array(t.map(J)));const i=r.getUniformLocation(o,"metalness");r.uniform1f(i,e);const s=r.getUniformLocation(o,"opacity");r.uniform1f(s,n??1)}}function dt(){const{gl:t,program:e,ambientLightColor:n}=Xt,r=t.getUniformLocation(e,"ambientLightColor");t.uniform3fv(r,new Float32Array(n))}function mt(t,e,n){return{projection:j(new Float32Array(16),(r=t.fov,r*Z),e/n,t.near,t.far),view:W(new Float32Array(16),t.position,t.target,t.up)};var r}function ht(t){return function(){const{gl:e,program:n,canvas:r}=Xt,{projection:o,view:a}=mt(t,r.width,r.height),i=e.getUniformLocation(n,"projection");e.uniformMatrix4fv(i,!1,o);const s=e.getUniformLocation(n,"view");e.uniformMatrix4fv(s,!1,a);const c=e.getUniformLocation(n,"cameraPosition");e.uniform3fv(c,t.position)}}function gt(t,e,n,r){return null==r?function(){const{gl:t,program:e}=Xt,r=t.getUniformLocation(e,"world");null!=r&&(n||I(n=new Float32Array(16)),Xt.transformMatrix=n,t.uniformMatrix4fv(r,!1,n))}:function(){if(null==n)return;const{gl:t,program:e,vaoMap:o}=Xt;let a;a=(Xt.transformMatricesWindows=null)?[]:Xt.transformMatricesWindows;const i=n.reduce(((t,e)=>[...t,...s(e)]),[]),c=new Float32Array(i);for(let t=0;t<r;++t){const e=16*t*4,n=16;a.push(new Float32Array(c.buffer,e,n))}t.bindVertexArray(Xt.vao);const u=t.createBuffer();var l;l={matrixBuffer:u,transformMatricesWindows:a},Xt={...Xt,...l};const f=t.getAttribLocation(e,"world");t.bindBuffer(t.ARRAY_BUFFER,u),t.bufferData(t.ARRAY_BUFFER,c.byteLength,t.DYNAMIC_DRAW);for(let e=0;e<4;++e){const n=f+e;t.enableVertexAttribArray(n);const r=16*e;t.vertexAttribPointer(n,4,t.FLOAT,!1,64,r),t.vertexAttribDivisor(n,1)}t.bufferSubData(t.ARRAY_BUFFER,0,c),t.bindVertexArray(null)}}function vt(t,e,n){return null==n?function(){const{gl:t,program:e,transformMatrix:n}=Xt,r=t.getUniformLocation(e,"normalMatrix");null!=r&&t.uniformMatrix4fv(r,!1,bt(n))}:function(){const{gl:t,program:e,vaoMap:r,transformMatricesWindows:o}=Xt,a=t.getAttribLocation(e,"normalMatrix");if(null==a)return;t.bindVertexArray(Xt.vao);const i=[];for(let t=0;t<n;t++)i.push(...bt(o[t]));const s=new Float32Array(i),c=t.createBuffer();Xt.normalMatrixBuffer=c,t.bindBuffer(t.ARRAY_BUFFER,c),t.bufferData(t.ARRAY_BUFFER,s.byteLength,t.DYNAMIC_DRAW),t.bufferSubData(t.ARRAY_BUFFER,0,s);for(let e=0;e<4;++e){const n=a+e;t.enableVertexAttribArray(n);const r=16*e;t.vertexAttribPointer(n,4,t.FLOAT,!1,64,r),t.vertexAttribDivisor(n,1)}t.bindVertexArray(null)}}function bt(t){const e=(n=new C(16),C!=Float32Array&&(n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0),n[0]=1,n[5]=1,n[10]=1,n[15]=1,n);var n;return function(t,e){var n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],c=e[6],u=e[7],l=e[8],f=e[9],p=e[10],d=e[11],m=e[12],h=e[13],g=e[14],v=e[15],b=n*s-r*i,M=n*c-o*i,y=n*u-a*i,A=r*c-o*s,x=r*u-a*s,E=o*u-a*c,L=l*h-f*m,R=l*g-p*m,_=l*v-d*m,P=f*g-p*h,T=f*v-d*h,F=p*v-d*g,w=b*F-M*T+y*P+A*_-x*R+E*L;w&&(w=1/w,t[0]=(s*F-c*T+u*P)*w,t[1]=(o*T-r*F-a*P)*w,t[2]=(h*E-g*x+v*A)*w,t[3]=(p*x-f*E-d*A)*w,t[4]=(c*_-i*F-u*R)*w,t[5]=(n*F-o*_+a*R)*w,t[6]=(g*y-m*E-v*M)*w,t[7]=(l*E-p*y+d*M)*w,t[8]=(i*T-s*_+u*L)*w,t[9]=(r*_-n*T-a*L)*w,t[10]=(m*x-h*y+v*b)*w,t[11]=(f*y-l*x-d*b)*w,t[12]=(s*R-i*P-c*L)*w,t[13]=(n*P-r*R+o*L)*w,t[14]=(h*M-m*A-g*b)*w,t[15]=(l*A-f*M+p*b)*w)}(e,t),function(t,e){if(t===e){var n=e[1],r=e[2],o=e[3],a=e[6],i=e[7],s=e[11];t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=n,t[6]=e[9],t[7]=e[13],t[8]=r,t[9]=a,t[11]=e[14],t[12]=o,t[13]=i,t[14]=s}else t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15]}(e,e),e}function Mt(t){let e,n;t.data?(e=t.data,n=t.interleaved):e=t;return{data:e.buffer&&e.buffer instanceof ArrayBuffer?e:new Float32Array(e),interleaved:n,...n?{byteStride:t.byteStride,byteOffset:t.byteOffset}:{}}}function yt(t,e){return function(){const{gl:n,program:r,vaoMap:o}=Xt,{positions:a,normals:i,elements:s,uvs:c,positionsSize:u}=e.attributes;let l;o.has(t)&&o.get(t).has(e)?l=o.get(t).get(e):(l=n.createVertexArray(),o.get(t).set(e,l)),Xt.vao=l,n.bindVertexArray(l);const{data:f,interleaved:p,byteStride:d,byteOffset:m}=Mt(a),h=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,h),n.bufferData(n.ARRAY_BUFFER,f,n.STATIC_DRAW);const g=n.getAttribLocation(r,"position");n.bindBuffer(n.ARRAY_BUFFER,h);const v=null!=u?u:3;if(n.vertexAttribPointer(g,v,n.FLOAT,!1,d,m),n.enableVertexAttribArray(g),e.attributes.normals){const{data:t,interleaved:e,byteStride:o,byteOffset:a}=Mt(i);if(!e){const e=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,e),n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW),n.bindBuffer(n.ARRAY_BUFFER,e)}const s=n.getAttribLocation(r,"normal");-1!=s&&(n.vertexAttribPointer(s,3,n.FLOAT,!1,o,a),n.enableVertexAttribArray(s))}if(e.attributes.elements){const t=new Uint16Array(e.attributes.elements),r=n.createBuffer();n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,r),n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)}if(e.attributes.uvs){const t=new Float32Array(e.attributes.uvs),o=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,o),n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW);const a=n.getAttribLocation(r,"uv");-1!=a&&(n.bindBuffer(n.ARRAY_BUFFER,o),n.vertexAttribPointer(a,2,n.FLOAT,!1,0,0),n.enableVertexAttribArray(a))}n.bindVertexArray(null)}}function At(t,e){if(null==t||null==e||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function xt(t){return(t=s(t)).shader instanceof Function&&t.setupLights instanceof Function&&t.updateOneLight instanceof Function}function Et(t,e,n){return t[0]=e[0]-n[0],t[1]=e[1]-n[1],t[2]=e[2]-n[2],t}function Lt(t,e){var n=e[0],r=e[1],o=e[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),t[0]=e[0]*a,t[1]=e[1]*a,t[2]=e[2]*a,t}function Rt(t,e,n){var r=e[0],o=e[1],a=e[2],i=n[0],s=n[1],c=n[2];return t[0]=o*c-a*s,t[1]=a*i-r*c,t[2]=r*s-o*i,t}function _t(t,e,n,r){var o=e[0],a=e[1],i=e[2];return t[0]=o+r*(n[0]-o),t[1]=a+r*(n[1]-a),t[2]=i+r*(n[2]-i),t}function Pt(t,e,n){var r=e[0],o=e[1],a=e[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,t[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,t[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,t[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,t}var Tt;Tt=new C(3),C!=Float32Array&&(Tt[0]=0,Tt[1]=0,Tt[2]=0);const Ft=function(){const t=D({position:[0,0,-1],target:[0,0,0],fov:80,near:.1,far:1e3,up:[0,1,0],matrix:null}),{subscribe:e,update:n}=t,r=D(0);function o(t){n((e=>{const n={...e,...t(e)};return r.update((t=>t+1)),n}))}return{subscribe:e,set:function(t){o((e=>t))},update:o,get revision(){return s(r)}}}(),wt=function(){const t={canvas:null,loop:null,backgroundColor:16777215,ambientLightColor:[16777215,0],toneMappings:[],enabled:!1};let e=t,n=new Map;const r=D(t),{subscribe:o,update:a}=r,i=D(0);function c(t){a((r=>{const o=t(r);var a;return i.update((t=>t+1)),null!=e.canvas&&o.canvas!==e.canvas&&o.canvas,null!=e.loop&&o.loop!==e.loop&&o.loop,o.backgroundColor!==e.backgroundColor&&(a=o.backgroundColor,n.set("backgroundColor",[...H(a),1])),At(o.ambientLightColor,e.ambientLightColor)||function([t,e]){n.set("ambientLightColor",H(t).map((t=>t*e)))}(o.ambientLightColor),At(o.toneMappings,e.toneMappings)||o.toneMappings,o.enabled!==e.enabled&&o.enabled,e=o,o}))}return{subscribe:o,set:function(t){c((e=>t))},update:c,get processed(){const t=s(r);return Object.entries(t).map((([t,e])=>n.has(t)?[t,n.get(t)]:[t,e])).reduce(((t,[e,n])=>(t[e]=n,t)),{})},get revision(){return s(i)}}}();const St=function(){const t=D([]),e=D(0),{subscribe:n,update:r}=t;function o(t){r((n=>{const r=t(n);return e.update((t=>t+1)),r}))}return{subscribe:n,set:function(t){o((e=>t))},update:o,get revision(){return s(e)}}}(),Bt=t=>{const{subscribe:e,set:n}=D(t);return{subscribe:e,set:t=>{n(t)}}};let Dt;const Ut=U([St],(([t])=>{const e=t.filter((t=>null!=t.attributes));if(At(Dt,e))throw new Error("meshes unchanged");return Dt=e,e}));let $t;const Ct=U([St],(([t])=>{const e=t.filter(jt).filter(xt);if(At($t,e))throw new Error("lights unchanged");return $t=e,e})),It=D([]);let Nt;const Ot=U([Ut],(([t])=>{const e=new Set;if(t.forEach((t=>{e.add(t.material)})),function(t,e){if(null==t||null==e||t.size!==e.size)return!1;for(let n of t)if(!e.has(n))return!1;return!0}(Nt,e))throw new Error("materials unchanged");return Nt=e,e}));function Yt(t){return t?.opacity<1||t?.transparent}function qt(t,e){return(Yt(t.material)?1:-1)-(Yt(e.material)?1:-1)}function Vt(t){if(0===t.length||null==s(wt).canvas)return;let e=!1;const n=s(wt).canvas,{projection:r,view:o}=mt(s(Ft),n.width,n.height),a=N([],r,o);t.forEach((t=>{(e||Yt(t.material))&&(e=!0,t.meshes.forEach(((t,e)=>{const n=k([],t.matrix);t.clipSpacePosition=Pt([],n,a)})),t.meshes=t.meshes.sort(((t,e)=>e.clipSpacePosition[2]-t.clipSpacePosition[2])))}));return t.sort(((t,e)=>null==t.material||null==e.material||null==t.meshes[0].clipSpacePosition||null==e.meshes[0].clipSpacePosition?0:e.meshes[0].clipSpacePosition[2]-t.meshes[0].clipSpacePosition[2]))}const kt=U([Ut,Ct,Ot,It],(([t,e,n,r])=>{let o=r.filter((t=>t.order<0)).reduce(((t,e)=>t.concat(...e.programs)),[]).map((e=>({...e,...e.allMeshes?{meshes:t}:{}}))),a=Array.from(n);const i=new Set(t.filter((t=>t.instances>1||t.animations?.some((t=>"vertex"===t.type)))));a=a.reduce(((e,n)=>{const r=t.filter((t=>t.material===n)),{currentNormalMeshes:o,currentSpecialMeshes:a}=r.reduce(((t,e)=>(i.has(e)?t.currentSpecialMeshes.push(e):t.currentNormalMeshes.push(e),t)),{currentNormalMeshes:[],currentSpecialMeshes:[]});return o.length>0&&e.push({material:n,meshes:o}),a.forEach((t=>{const r=t.animations?.some((t=>t.requireTime));e.push({requireTime:r,material:n,meshes:[t]})})),e}),[]),a=a.sort(qt),Vt(a);const c=e.filter((t=>"point"===s(t).type)),u=c.length;let l;return u>0&&(l=s(c[0]).shader),[...o,...a.map(((t,n)=>{const r=0===n,o={...t,useProgram:ut,setupMaterial:[dt],bindTextures:[],createProgram:it,selectProgram:Gt};return o.setupProgram=[ft(t.material,t.meshes,u,l),st,ct],r&&(o.setFrameBuffer=lt),t.material?.specular&&o.setupMaterial.push(t.material.specular.setupSpecular),t.material?.diffuseMap&&(o.setupMaterial.push(t.material.diffuseMap.setupTexture),o.bindTextures.push(t.material.diffuseMap.bindTexture)),t.material?.normalMap&&(o.setupMaterial.push(t.material.normalMap.setupTexture),o.bindTextures.push(t.material.normalMap.bindTexture)),t.requireTime&&o.setupMaterial.push(rt),o.setupMaterial.push(...Array.from(e.reduce(((t,e)=>{const n=s(e);return t.has(n.setupLights)?t.set(n.setupLights,[...t.get(n.setupLights),e]):t.set(n.setupLights,[e]),t}),new Map)).map((([t,e])=>t(e)))),o}))]})),zt=D({init:!1});function jt(t){return null!=t&&null!=t.subscribe}function Gt(t){return function(){const{programMap:e}=Xt,n=e.get(t);Xt.program=n}}function Wt(t,e){return function(){const{vaoMap:n}=Xt,r=n.get(t).get(e);Xt.vao=r}}let Xt={programMap:new Map,vaoMap:new Map};const Ht=[],Kt=new Map;Kt.set(wt,0),Kt.set(St,0),Kt.set(Ft,0);const Jt=D(0),Qt=U([wt,kt,St,Ft,Jt],(([t,e,n,r,o])=>{if(!t.enabled||4===o||1===o)return Ht;const a=function(){const t=new Set;return Kt.get(wt)!==wt.revision&&t.add(wt),Kt.get(St)!==St.revision&&t.add(St),Kt.get(Ft)!==Ft.revision&&t.add(Ft),Kt.set(wt,wt.revision),Kt.set(St,St.revision),Kt.set(Ft,Ft.revision),t}();if(0===a.length)return Ht;const i=wt.processed;let c={canvas:t.canvas,backgroundColor:i.backgroundColor,ambientLightColor:i.ambientLightColor,...t.toneMappings.length>0?{toneMappings:t.toneMappings}:void 0};const u=[];Xt={...Xt,...c};s(zt).init||u.push(tt);const l=Vt(e);let f=!1;return u.push(nt),u.push(...l.reduce(((t,e)=>(Yt(e.material)&&!f&&(f=!0,t.push(et)),[...t,...Xt.programMap.has(e)?[e.selectProgram(e),e.useProgram,...e.bindTextures]:[e.createProgram(e),...e.setupProgram,e.useProgram,...e.setupMaterial],...e.setupCamera?[e.setupCamera]:[...a.has(Ft)?[ht(r)]:[]],...e.setFrameBuffer?[e.setFrameBuffer]:[],...e.meshes.reduce(((t,n)=>[...t,...Xt.vaoMap.has(e)&&Xt.vaoMap.get(e).has(n)?[Wt(e,n),...null==n.instances?[gt(0,0,n.matrix),vt()]:[]]:[yt(e,n),...e.material?[pt(e.material)]:[],gt(0,0,null==n.instances?n.matrix:n.matrices,n.instances),vt(0,0,n.instances),...n.animations?.map((t=>t.setupAnimation))||[]],at,ot(n,n.instances,n.drawMode)]),[]),...e.postDraw?[e.postDraw]:[]])),[])),u}),Ht);U([Qt],(([t])=>{if(0===t.length)return 0;if(!s(zt).init&&0===s(Jt))return Jt.set(1),t.forEach((t=>{t()})),zt.set({init:!0}),Jt.set(2),1;if(2===s(Jt))return Jt.set(3),requestAnimationFrame((async function t(){Jt.set(4),s(wt).loop&&s(wt).loop(),Jt.set(3),s(Qt).forEach((t=>{t()})),Jt.set(4),requestAnimationFrame(t)})),2})).subscribe((t=>{}));function Zt(){return new Array(3).fill(0)}function te(t,e){return t[0]*=e,t[1]*=e,t[2]*=e,t}const ee=t=>({type:"point",position:[0,0,0],color:[1,1,1],intensity:3,cutoffDistance:5,decayExponent:1,...t,shader:X("${declaration?\r\n`\r\n\r\nfloat pow4(const in float x) {\r\n    float x2 = x * x;\r\n    return x2 * x2;\r\n}\r\nfloat pow2(const in float x) {\r\n    return x * x;\r\n}\r\n\r\nfloat saturate(const in float a) {\r\n    return clamp(a, 0.0f, 1.0f);\r\n}\r\n\r\nstruct LightParams {\r\n    vec3 irradiance;\r\n    vec3 direction;\r\n    vec3 color;\r\n    float distance;\r\n};\r\n\r\nstruct PointLight {\r\n    vec3 position;\r\n    vec3 color;\r\n    float cutoffDistance;\r\n    float decayExponent;\r\n};\r\n\r\nlayout(std140) uniform PointLights {\r\n    PointLight pointLights[NUM_POINT_LIGHTS];\r\n};\r\n\r\nfloat getDistanceAttenuation(const in float lightDistance, const in float cutoffDistance, const in float decayExponent) {\r\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\r\n\t// page 32, equation 26: E[window1]\r\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n    float distanceFalloff = 1.0f / max(pow(lightDistance, decayExponent), 0.01f);\r\n    if(cutoffDistance > 0.0f) {\r\n        distanceFalloff *= pow2(saturate(1.0f - pow4(lightDistance / cutoffDistance)));\r\n    }\r\n    return distanceFalloff;\r\n\r\n}\r\n\r\nLightParams getDirectDiffuse(const in PointLight pointLight,const in vec3 vertexPosition, const in vec3 normal,const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\r\n    LightParams lightParams = LightParams(vec3(0.0f), vec3(0.0f), vec3(0.0f), 0.0f);\r\n    vec3 lVector = pointLight.position - vertexPosition;\r\n    lightParams.distance = length(lVector);\r\n    lightParams.direction = normalize(lVector);\r\n    float dotNL = saturate(dot(normal, lightParams.direction));\r\n    lightParams.color = pointLight.color;\r\n    lightParams.color *= getDistanceAttenuation(lightParams.distance, pointLight.cutoffDistance, pointLight.decayExponent);\r\n    lightParams.irradiance = dotNL * lightParams.color;\r\n    \r\n    reflectedLight.directDiffuse += lightParams.irradiance * BRDF_Lambert(material.diffuseColor);\r\n    return lightParams;\r\n}\r\n\r\nfloat calculatePointLightBrightness(float lightDistance, float cutoffDistance, float decayExponent) {\r\n    return getDistanceAttenuation(lightDistance, cutoffDistance, decayExponent);\r\n}\r\n` : ''\r\n}\r\n${irradiance?\r\n`\r\n    vec3 irradiance = vec3(0.0f);\r\n    vec3 direction = vec3(0.0f);\r\n    for(int i = 0; i < NUM_POINT_LIGHTS; i++) {\r\n        PointLight pointLight = pointLights[i];\r\n        \r\n\r\n        LightParams lightParams = getDirectDiffuse(pointLight, vertex, normal, material, reflectedLight);\r\n        totalIrradiance += reflectedLight.directDiffuse;\r\n        ${specularIrradiance}\r\n    }\r\n` : ''\r\n}\r\n",{declaration:!1,irradiance:!1,specularIrradiance:""}),setupLights:ie,updateOneLight:se});let ne=null;const re=t=>{ne=t},oe=()=>ne;function ae(t,e,n){e.preMultipliedColor=[...e.color],te(e.preMultipliedColor,e.intensity),t[n]=e.position[0],t[n+1]=e.position[1],t[n+2]=e.position[2],t[n+4]=e.preMultipliedColor[0],t[n+5]=e.preMultipliedColor[1],t[n+6]=e.preMultipliedColor[2],t[n+7]=e.cutoffDistance,t[n+8]=e.decayExponent,t[n+9]=0,t[n+10]=0,t[n+11]=0,t[n+12]=0}function ie(t){return function(){const{gl:e,program:n}=Xt;oe()||function(t){const{gl:e}=Xt,n=t.length,r=new Float32Array(12*n);for(let e=0;e<n;e++)ae(r,s(t[e]),12*e);const o=e.createBuffer();re(o),e.bindBufferBase(e.UNIFORM_BUFFER,Q,o),e.bufferData(e.UNIFORM_BUFFER,r,e.DYNAMIC_DRAW)}(t);const r=e.getUniformBlockIndex(n,"PointLights");e.uniformBlockBinding(n,r,Q)}}function se(t,e){const{gl:n}=Xt,r=t.filter((t=>"point"===s(t).type)).findIndex((t=>t===e)),o=oe();if(-1!==r){const t=new Float32Array(12),a=12*r;ae(t,s(e),a),n.bindBuffer(n.UNIFORM_BUFFER,o),n.bufferSubData(n.UNIFORM_BUFFER,a*Float32Array.BYTES_PER_ELEMENT,t)}}const ce=8900331;function ue(t,e,n){return t[0]=e[0]+n[0],t[1]=e[1]+n[1],t}function le(t,e,n){return t[0]=e[0]/n[0],t[1]=e[1]/n[1],t}!function(){var t=function(){var t=new C(2);return C!=Float32Array&&(t[0]=0,t[1]=0),t}()}();const fe={0:"POINTS",1:"LINES",2:"LINE_LOOP",3:"LINE_STRIP",4:"TRIANGLES",5:"TRIANGLE_STRIP",6:"TRIANGLE_FAN"},pe=(t,e,n)=>{const r=[];!function(t){const e=Zt(),n=Zt(),r=Zt();for(let o=0;o<ye.length;o+=3)a(ye[o+0],e),a(ye[o+1],n),a(ye[o+2],r),i(e,n,r,t)}(e),function(t){const e=Zt();for(let n=0;n<r.length;n+=3)e[0]=r[n+0],e[1]=r[n+1],e[2]=r[n+2],Lt(e,e),te(e,t),r[n+0]=e[0],r[n+1]=e[1],r[n+2]=e[2]}(t);let o=n(r);return{attributes:{positions:r,normals:o},drawMode:fe[4]};function a(t,e){const n=3*t;e[0]=Me[n+0],e[1]=Me[n+1],e[2]=Me[n+2]}function i(t,e,n,r){const o=r+1,a=[];for(let r=0;r<=o;r++){a[r]=[];let i=Zt();_t(i,[...t],n,r/o);let s=Zt();_t(s,[...e],n,r/o);const c=o-r;for(let t=0;t<=c;t++)if(0===t&&r===o)a[r][t]=i;else{let e=Zt();_t(e,[...i],s,t/c),a[r][t]=e}}for(let t=0;t<o;t++)for(let e=0;e<2*(o-t)-1;e++){const n=Math.floor(e/2);e%2==0?(s(a[t][n+1]),s(a[t+1][n]),s(a[t][n])):(s(a[t][n+1]),s(a[t+1][n+1]),s(a[t+1][n]))}}function s(t){r.push(...t)}};function de(t){const e=t.slice();return function(t){for(let e=0,n=t.length;e<n;e+=3){const n=t[e+0],r=t[e+1],o=t[e+2],a=1/Math.sqrt(n*n+r*r+o*o);t[e+0]*=a,t[e+1]*=a,t[e+2]*=a}}(e),e}function me({positions:t}){const e=[];for(let r=0;r<t.length;r+=3){const o=[t[r+0],t[r+1],t[r+2]],a=ge(o)/2/Math.PI+.5,i=(n=o,Math.atan2(-n[1],Math.sqrt(n[0]*n[0]+n[2]*n[2]))/Math.PI+.5);e.push(a,1-i)}var n;return function(t,e){for(let n=0,r=0;n<e.length;n+=9,r+=6){const o=[e[n+0],e[n+1],e[n+2]],a=[e[n+3],e[n+4],e[n+5]],i=[e[n+6],e[n+7],e[n+8]],s=[t[r+0],t[r+1]],c=[t[r+2],t[r+3]],u=[t[r+4],t[r+5]],l=[...o];ue(l,l,a),ue(l,l,i),le(l,l,3);const f=ge(l);he(t,s,r+0,o,f),he(t,c,r+2,a,f),he(t,u,r+4,i,f)}}(e,t),function(t){for(let e=0;e<t.length;e+=6){const n=t[e+0],r=t[e+2],o=t[e+4],a=Math.max(n,r,o),i=Math.min(n,r,o);a>.9&&i<.1&&(n<.2&&(t[e+0]+=1),r<.2&&(t[e+2]+=1),o<.2&&(t[e+4]+=1))}}(e),e}function he(t,e,n,r,o){o<0&&1===e.x&&(t[n]=e.x-1),0===r[0]&&0===r[2]&&(t[n]=o/2/Math.PI+.5)}function ge(t){return Math.atan2(t[2],-t[0])}const ve=(1+Math.sqrt(5))/2,be=1/ve,Me=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-be,-ve,0,-be,ve,0,be,-ve,0,be,ve,-be,-ve,0,-be,ve,0,be,-ve,0,be,ve,0,-ve,0,-be,ve,0,-be,-ve,0,be,ve,0,be],ye=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];function Ae(t,e){let n,r;function o(e){let o="mousemove",a="mouseup",s=e;"touchstart"===e.type&&(o="touchmove",a="touchend",s=e.touches[0]),t.addEventListener(o,i,{passive:!1}),n=s.clientX,r=s.clientY,t.addEventListener(a,u,{passive:!1}),e.preventDefault(),e.stopPropagation()}function a(t,e){const n=Math.sqrt(Math.pow(t[0]-e[0],2)+Math.pow(t[1]-e[1],2)+Math.pow(t[2]-e[2],2));return{radius:n,polar:Math.acos(Math.max(-1,Math.min(1,(t[1]-e[1])/n))),azimuth:Math.atan2(t[0]-e[0],t[2]-e[2])}}function i(t){let o=t;"touchmove"===t.type&&(o=t.touches[0]);const i=o.clientX-n,u=o.clientY-r,l=s(e),{position:f,target:p,fov:d}=l,{radius:m,polar:h,azimuth:g}=a(f,p),v=c(m,h-u/100,g-i/100);v[0]=v[0]+p[0],v[1]=v[1]+p[1],v[2]=v[2]+p[2],e.set({position:v,target:p,fov:d}),n=o.clientX,r=o.clientY}function c(t,e,n){const r=Math.sin(e)*t;return[r*Math.sin(n),Math.cos(e)*t,r*Math.cos(n)]}function u(e){let n="mousemove",r="mouseup";"touchend"===e.type&&(n="touchmove",r="touchend"),t.removeEventListener(n,i,{passive:!1}),t.removeEventListener(r,u,{passive:!1})}t.addEventListener("touchstart",o,{passive:!1}),t.addEventListener("mousedown",o,{passive:!1}),t.addEventListener("wheel",(function(t){const n=s(e),{position:r,target:o,fov:i}=n,{radius:u,polar:l,azimuth:f}=a(r,o);console.log("radius",u);const p=c(u+.001*t.deltaY*u,l,f);p[0]=p[0]+o[0],p[1]=p[1]+o[1],p[2]=p[2]+o[2],e.set({position:p,target:o,fov:i})}),{passive:!1})}const xe={diffuse:"diffuseMap",normal:"normalMap"},Ee={diffuse:0,normal:1},Le=async t=>{let e;var n;let r;t.url?e=await(n=t.url,new Promise(((t,e)=>{const r=new Image;r.onload=()=>{t(r)},r.onerror=e,r.src=n}))):"function"==typeof t.textureBuffer&&(e=t.textureBuffer);let o={type:xe[t.type],coordinateSpace:t.coordinateSpace,shader:X("${declaration?\r\n`\r\nuniform sampler2D ${mapType};\r\nuniform vec2 normalScale;\r\n\r\n\r\nmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\r\n    vec3 q0 = dFdx( eye_pos.xyz );\r\n    vec3 q1 = dFdy( eye_pos.xyz );\r\n    vec2 st0 = dFdx( uv.st );\r\n    vec2 st1 = dFdy( uv.st );\r\n    vec3 N = surf_norm;\r\n    vec3 q1perp = cross( q1, N );\r\n    vec3 q0perp = cross( N, q0 );\r\n    vec3 T = q1perp * st0.x + q0perp * st1.x;\r\n    vec3 B = q1perp * st0.y + q0perp * st1.y;\r\n    float det = max( dot( T, T ), dot( B, B ) );\r\n    float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\r\n    return mat3( T * scale, B * scale, N );\r\n}\r\n` : ''\r\n}\r\n${diffuseMapSample?\r\n`\r\n    //atan(uv.y, uv.x)\r\n    ${coordinateSpace === 'circular' ?\r\n`   vec2 uv = vec2(vUv.x/vUv.y, vUv.y);\r\n` :\r\n`   vec2 uv = vUv;\r\n`}\r\n    vec4 textureColor = texture( ${mapType}, uv );\r\n    material.diffuseColor *= textureColor.rgb;\r\n    material.diffuseAlpha = textureColor.a;\r\n    \r\n` : ''\r\n}\r\n${normalMapSample?\r\n`\r\n    mat3 tbn =  getTangentFrame( -vViewPosition, vNormal, vUv );\r\n    normal = texture( normalMap, vUv ).xyz * 2.0 - 1.0;\r\n    normal.xy *= normalScale;\r\n    normal = normalize(tbn * normal);\r\n\t//normal = normalize( normalMatrix * normal );\r\n` : ''\r\n}\r\n",{declaration:!1,diffuseMapSample:!1,normalMapSample:!1,mapType:void 0,coordinateSpace:void 0}),setupTexture:_e(e,xe[t.type],Ee[t.type],t.normalScale,(function(t){r=t})),bindTexture:Re(Ee[t.type],(function(){return r}),xe[t.type])};return o="function"==typeof e?{...o,get textureBuffer(){return e()}}:{...o,texture:e},o};function Re(t,e,n){return function(){const{gl:r,program:o}=Xt,a=r.getUniformLocation(o,n);r.activeTexture(r["TEXTURE"+t]),r.bindTexture(r.TEXTURE_2D,e()),r.uniform1i(a,t)}}function _e(t,e,n,r=[1,1],o){return function(){const{gl:a,program:i}=Xt;let s;s="function"==typeof t?t():a.createTexture(),o(s);const c=a.getUniformLocation(i,e);if(a.activeTexture(a["TEXTURE"+n]),a.bindTexture(a.TEXTURE_2D,s),a.uniform1i(c,n),"function"!=typeof t&&a.texImage2D(a.TEXTURE_2D,0,a.RGBA,a.RGBA,a.UNSIGNED_BYTE,t),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.LINEAR_MIPMAP_LINEAR),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL,!0),a.generateMipmap(a.TEXTURE_2D),null!=r){const t=a.getUniformLocation(i,"normalScale");a.uniform2fv(t,r)}}}export{fe as A,Rt as B,Et as C,Lt as D,q as E,Xt as F,k as G,G as H,W as I,st as J,ct as K,ut as L,Gt as M,N,z as O,X as P,me as Q,S,l as a,St as b,c,f as d,p as e,Ft as f,It as g,V as h,w as i,Y as j,O as k,I as l,u as m,t as n,h as o,ce as p,pe as q,wt as r,a as s,Pt as t,Bt as u,ee as v,Le as w,Ae as x,v as y,de as z};
