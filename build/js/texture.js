import{a4 as e,T as r}from"./engine.js";const n={diffuse:"diffuseMap",normal:"normalMap",roughness:"roughnessMap",light:"lightMap"},t={diffuse:0,normal:1,roughness:2,light:3},a=async r=>{let a,l,c=0,u=0;var p;let s;return r.url?a=await(p=r.url,new Promise(((e,r)=>{const n=new Image;n.onload=()=>{e(n)},n.onerror=r,n.src=p}))):"function"==typeof r.textureBuffer?l=r.textureBuffer:r.image&&(a=r.image,c=r.width,u=r.height),{type:n[r.type],coordinateSpace:r.coordinateSpace,shader:e("${declaration?\r\n`\r\nuniform sampler2D ${mapType};\r\n` : ''\r\n}\r\n${declarationNormal?\r\n`\r\nuniform vec2 normalScale;\r\nmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\r\n    vec3 q0 = dFdx( eye_pos.xyz );\r\n    vec3 q1 = dFdy( eye_pos.xyz );\r\n    vec2 st0 = dFdx( uv.st );\r\n    vec2 st1 = dFdy( uv.st );\r\n    vec3 N = surf_norm;\r\n    vec3 q1perp = cross( q1, N );\r\n    vec3 q0perp = cross( N, q0 );\r\n    vec3 T = q1perp * st0.x + q0perp * st1.x;\r\n    vec3 B = q1perp * st0.y + q0perp * st1.y;\r\n    float det = max( dot( T, T ), dot( B, B ) );\r\n    float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\r\n    return mat3( T * scale, B * scale, N );\r\n}\r\n` : ''\r\n}\r\n${declarationLight?\r\n`\r\nuniform float lightMapIntensity;\r\n` : ''\r\n}\r\n${diffuseMapSample?\r\n`\r\n    \n    ${coordinateSpace === 'circular' ?\r\n`   vec2 uv = vec2(vUv.x/vUv.y, vUv.y);\r\n` :\r\n`   vec2 uv = vUv;\r\n`}\r\n    vec4 textureColor = texture( ${mapType}, uv );\r\n    material.diffuseColor *= textureColor.rgb;\r\n    material.diffuseAlpha = textureColor.a;\r\n    \r\n` : ''\r\n}\r\n${normalMapSample?\r\n`\r\n    mat3 tbn =  getTangentFrame( -vViewPosition, vNormal, vUv );\r\n    vec2 rotatedUv = vec2(vUv.x, vUv.y);\r\n    normal = texture( ${mapType}, rotatedUv ).xyz * 2.0 - 1.0;\r\n    normal.xy *= normalScale;\r\n    normal = normalize(tbn * normal);\r\n\t\n` : ''\r\n}\r\n${roughnessMapSample?\r\n`\r\n    \n    ${coordinateSpace === 'circular' ?\r\n`   vec2 roughnessUv = vec2(vUv.x/vUv.y, vUv.y);\r\n` :\r\n`   vec2 roughnessUv = vec2(vUv.x, vUv.y);\r\n`}\r\n    vec4 texelRoughness = texture( ${mapType}, roughnessUv );\r\n    roughnessFactor = texelRoughness.g;\r\n` : ''\r\n}\r\n${lightMapSample?\r\n`\r\n    vec4 lightMapTexel = texture( ${mapType}, vUv1 );\r\n    vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\r\n    reflectedLight.directDiffuse += lightMapIrradiance * BRDF_Lambert(material.diffuseColor);\r\n` : ''\r\n}",{declaration:!1,declarationNormal:!1,declarationLight:!1,diffuseMapSample:!1,normalMapSample:!1,roughnessMapSample:!1,lightMapSample:!1,mapType:void 0,coordinateSpace:void 0}),setupTexture:i(a,n[r.type],t[r.type],r.normalScale,r.lightMapIntensity,(function(e){s=e}),l,c,u),bindTexture:o(t[r.type],(function(){return s}),n[r.type]),...r.url?{url:r.url}:{}}};function o(e,n,t){return function(){const{gl:a,program:o}=r,i=a.getUniformLocation(o,t);a.activeTexture(a["TEXTURE"+e]),a.bindTexture(a.TEXTURE_2D,n()),a.uniform1i(i,e)}}function i(e,n,t,a=[1,1],o=1,i,l=null,c=0,u=0){return function(){const{gl:p,program:s}=r;let v;v=null!==l?l():p.createTexture(),i(v);const m=p.getUniformLocation(s,n);if(p.activeTexture(p["TEXTURE"+t]),p.bindTexture(p.TEXTURE_2D,v),p.uniform1i(m,t),null===l&&(e instanceof HTMLImageElement?p.texImage2D(p.TEXTURE_2D,0,p.RGBA,p.RGBA,p.UNSIGNED_BYTE,e):p.texImage2D(p.TEXTURE_2D,0,p.RGBA,c,u,0,p.RGBA,p.UNSIGNED_BYTE,e)),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_MIN_FILTER,p.LINEAR_MIPMAP_LINEAR),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_WRAP_S,p.CLAMP_TO_EDGE),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_WRAP_T,p.CLAMP_TO_EDGE),p.generateMipmap(p.TEXTURE_2D),null!=a){const e=p.getUniformLocation(s,"normalScale");p.uniform2fv(e,a)}if(null!=o){const e=p.getUniformLocation(s,"lightMapIntensity");p.uniform1f(e,o)}}}export{a as c};
