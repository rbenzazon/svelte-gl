import{H as t,y as e,W as n,X as a}from"./Menu-Yuo5SiFP.js";const r={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},i={MAT2:4,MAT3:9,MAT4:16,SCALAR:1,VEC2:2,VEC3:3,VEC4:4};async function o(n,a=void 0){try{let o=new Map;a&&o.set(a,l(a));const s=await fetch(n);if(!s.ok)throw new Error(`Failed to fetch GLB file: ${s.statusText}`);const c=await s.json();return await async function(n,a,o){const s=a.substring(0,a.lastIndexOf("/")+1),{buffers:c,bufferViews:u,accessors:m,scenes:d,nodes:y,meshes:p,cameras:h,materials:b,scene:w}=n,v=await Promise.all(c.map((async t=>{const{uri:e}=t,n=s+e;return o.has(n)?o.get(n):l(n)}))),A=await Promise.all(u.map((async t=>{const{buffer:e,byteOffset:n,byteLength:a,byteStride:r}=t;return{dataView:v[e].slice(n,n+a),byteStride:r}}))),x={};function E(t,e){return x[t]&&x[t][e]}function M(t,e,n){x[e]=x[e]||{},x[e][n]=t}function T(t,e){return x[t]&&null!=x[t][e]}const O=m.map((t=>{const{bufferView:e,byteOffset:n}=t,{dataView:a,byteStride:o}=A[e],{type:l,componentType:s,count:c,min:u,max:f}=t,m=i[l],d=r[s],y=d.BYTES_PER_ELEMENT;let p,h,b,w=!1;if(null!=o&&o!==y*m){p=Math.floor(n/o)*o,h=c*o/y,w=!0}else p=n,h=c*m;return w&&T(a,p)?b=E(a,p):(b=new d(a,p,h),w&&M(b,a,p)),{type:l,componentType:s,count:c,min:u,max:f,data:b,interleaved:w,...w?{byteOffset:n,byteStride:o}:{}}})),F=p.map((t=>R(t)));let S=y.map((t=>null!=t.mesh?{...F[t.mesh],matrix:f(t)}:null!=t.camera?V(t):null!=t.children?t:void 0));S=S.map((t=>null!=t.children?P(t):t));const g=d[w];let{nodes:L}=g,I=L.map((t=>S[t]));I.forEach((t=>{C(t)}));return{scene:I,materials:b,lights:{},cameras:h};function R(e){const{primitives:n}=e;return n.map((e=>{const{attributes:n,indices:a}=e,{POSITION:r,NORMAL:i,TEXCOORD_0:o}=n,l=O[r],s=O[i],c=O[o];return{position:l,normal:s,indices:O[a],uv:c,material:e.material,drawMode:t[e.mode]}}))[0]}function V(t){return null!=t.matrix||null==t.scale&&null==t.translation&&null==t.rotation?null==t.matrix&&(t.matrix=e(new Float32Array(16))):t.matrix=f(t),{...t,...h[t.camera]}}function C(t,e=null){const{children:n}=t;if(null!=e&&(t.parent=e),null!=n)return n.map((e=>{C(e,t)}))}function P(t){const{children:n,matrix:a,scale:r,translation:i,rotation:o}=t;let l;return l=null!=a||null==r&&null==i&&null==o?null!=a?a:e(new Float32Array(16)):f(t),{children:n.map((t=>null!=S[t].children?P(S[t]):S[t])),matrix:l}}}(c,n,o)}catch(t){console.error("Error loading GLTF file:",t)}}async function l(t){let e;if(t){if(e=await fetch(t),!e.ok)throw new Error(`Failed to fetch GLTF Binary file: ${e.statusText}`);return await e.arrayBuffer()}}function s(t,e){const n=e,a=t.materials[n.material],r={};if(a.pbrMetallicRoughness){const{baseColorFactor:t,metallicFactor:e,roughnessFactor:n}=a.pbrMetallicRoughness;r.diffuse=t?.slice(0,3)??[1,1,1],r.roughness=n??1,r.metalness=0}return{attributes:{positions:n.position.interleaved?{data:n.position.data,interleaved:n.position.interleaved,byteOffset:n.position.byteOffset,byteStride:n.position.byteStride}:n.position.data,normals:n.normal.interleaved?{data:n.normal.data,interleaved:n.normal.interleaved,byteOffset:n.normal.byteOffset,byteStride:n.normal.byteStride}:n.normal.data,elements:n.indices.data,...n.uv?.data?{uvs:n.uv.data}:{}},drawMode:n.drawMode??"TRIANGLES",material:r,matrix:n.matrix}}function c(t){const{perspective:e,translation:n}=t;return{position:n,target:[0,0,0],fov:e.yfov/Math.PI*180,near:e.znear,far:e.zfar,up:[0,1,0]}}function u(t){const a=[];let r=t;for(;null!=r.parent;)a.unshift(r.matrix),r=r.parent;return a.reduce(((t,e)=>n(t,t,e)),e(new Float32Array(16)))}function f(t){const{translation:n,rotation:r,scale:i}=t,o=e(new Float32Array(16));return a(o,r||[0,0,0,0],n||[0,0,0],i||[1,1,1]),o}function m(t,e){t.forEach((t=>{e(t),null!=t.children&&m(t.children,e)}))}export{s as a,c,u as g,o as l,m as t};
