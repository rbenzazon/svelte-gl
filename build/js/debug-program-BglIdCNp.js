import{L as r,Q as e,R as a,T as o,U as t,V as n,W as i,X as s,Y as l}from"./Menu-C4XSDfXF.js";function c(e){const{normals:a,positions:o}=e.attributes;console.log("positions",o);const t="Float32Array"!=typeof o&&"data"in o?o.data:o,n="Float32Array"!=typeof a&&"data"in a?a.data:a,i=[];for(let r=0;r<t.length;r+=3)i.push(t[r],t[r+1],t[r+2]),i.push(t[r]+.2*n[r],t[r+1]+.2*n[r+1],t[r+2]+.2*n[r+2]);return{attributes:{positions:new Float32Array(i)},matrix:e.matrix,material:e.material,drawMode:r[1]}}var h="#version 300 es\r\nprecision mediump float;\r\n\r\n// Input from vertex shader\r\nin vec3 vertexColor;\r\nin vec3 vNormal;\r\nin vec3 vertex;\r\nin vec3 vViewPosition;\r\nin highp vec2 vUv;\r\n\r\n// Output color\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n    // Simply use the vertex color for the fragment color\r\n    // This will create a simple colored line with no lighting effects\r\n    fragColor = vec4(vertexColor, 1.0);\r\n    \r\n    // Alternative: if you want slightly smoother lines with anti-aliasing\r\n    // float intensity = 1.0;\r\n    // fragColor = vec4(vertexColor * intensity, 1.0);\r\n}";function d(){return{createProgram:e,setupProgram:[m,a,o],setupMaterial:[],useProgram:t,selectProgram:n,updateProgram:[]}}function m(){const{gl:r,program:e}=l,a=i(s,{instances:!1,declarations:"",positionModifier:""})({instances:!1,declarations:"",positionModifier:""}),o=r.createShader(r.VERTEX_SHADER);r.shaderSource(o,a),r.compileShader(o),r.getShaderParameter(o,r.COMPILE_STATUS)||console.error(r.getShaderInfoLog(o)),r.attachShader(e,o);const t=r.createShader(r.FRAGMENT_SHADER);r.shaderSource(t,h),r.compileShader(t),r.getShaderParameter(t,r.COMPILE_STATUS)||console.error(r.getShaderInfoLog(t)),r.attachShader(e,t)}export{d as a,c};
