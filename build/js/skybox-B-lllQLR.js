import{Q as r,av as n,Z as e,_ as t,a0 as o,a1 as a,a6 as i,aA as s,U as c,T as u,aB as E,r as l,R as g,aC as p,y as T,a3 as _,P as f,O as m,W as v,N as d}from"./engine-X40bdnq3.js";function P(n){const{normals:e,positions:t}=n.attributes,o="Float32Array"!=typeof t&&"data"in t?t.data:t,a="Float32Array"!=typeof e&&"data"in e?e.data:e,i=[];for(let r=0;r<o.length;r+=3)i.push(o[r],o[r+1],o[r+2]),i.push(o[r]+.2*a[r],o[r+1]+.2*a[r+1],o[r+2]+.2*a[r+2]);return{attributes:{positions:new Float32Array(i)},matrix:n.matrix.value,material:n.material,drawMode:r[1]}}var A="#version 300 es\r\nprecision mediump float;\r\n\r\n#define SHADER_NAME basicFragment\r\n\r\n// Input from vertex shader\r\nin vec3 vertexColor;\r\nin vec3 vNormal;\r\nin vec3 vertex;\r\nin vec3 vViewPosition;\r\nin highp vec2 vUv;\r\n\r\n// Output color\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n    // Simply use the vertex color for the fragment color\r\n    // This will create a simple colored line with no lighting effects\r\n    fragColor = vec4(vertexColor, 1.0);\r\n    \r\n    // Alternative: if you want slightly smoother lines with anti-aliasing\r\n    // float intensity = 1.0;\r\n    // fragColor = vec4(vertexColor * intensity, 1.0);\r\n}";function U(){return{createProgram:n,setupProgram:[M,e,t],setupMaterial:[],useProgram:o,selectProgram:a,updateProgram:[]}}function M(){const{gl:r,program:n}=u,e=i(s,{instances:!1,declarations:"",positionModifier:""})({instances:!1,declarations:"",positionModifier:""});c(r,n,e,A)}var h="#version 300 es\r\n\r\n#define SHADER_NAME skyboxVertex\r\n\r\nin vec4 position;\r\nout vec4 v_position;\r\nvoid main() {\r\n    v_position = position;\r\n    gl_Position = position;\r\n    gl_Position.z = 1.0;\r\n}",R="#version 300 es\r\nprecision highp float;\r\n\r\n#define SHADER_NAME skyboxFragment\r\n\r\nuniform samplerCube skybox;\r\nuniform mat4 viewDirectionProjectionInverse;\r\n\r\n${declarations}\r\n  \r\nin vec4 v_position;\r\n  \r\n// we need to declare an output for the fragment shader\r\nout vec4 fragColor;\r\nvec4 sRGBTransferOETF( in vec4 value ) {\r\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\r\n}\r\nvoid main() {\r\n  vec4 t = viewDirectionProjectionInverse * v_position;\r\n  fragColor = texture(skybox, normalize(t.xyz / t.w));\r\n  ${toneMappings}\r\n  ${hdrEncoding ? `\r\n  fragColor = sRGBTransferOETF(fragColor);\r\n  ` : ''}\r\n}";async function C(i){let s,c;function g(r){s=r}function p(){return s}const T={createProgram:n,setupProgram:[e,t],setupMaterial:[],bindTextures:[I(p)],setupCamera:y,useProgram:o,selectProgram:a,updateProgram:[X((function(r){c=r}))],meshes:[{attributes:{positionsSize:2,positions:new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1])},drawMode:r[4]}],postDraw:B((function(){return c}))};let _,f,m;if(function(r){return"url"in r&&"string"==typeof r.url}(i)){T.setupMaterial=[await i.convertToCube(i.url,g)];const r=i.hdrEncoding??!1;T.setupProgram=[x(null,r),...T.setupProgram],_={url:i.url}}else(function(r){return"typedArray"in r&&r.typedArray instanceof Uint16Array})(i)&&(f=i.typedArray,T.createProgram=function(r){return function(e){return function(){null!=r&&r(),n(e)()}}}(function(r,n,e,t,o,a,i){return function(){const{gl:s}=u;if(null==e()){const e=t(r,s,o,a,i);n(e),E(),l.update((r=>r))}}}(f,g,p,i.convertToCube,i.width,i.height,i.cubeSize)),m=i.toneMapping,T.setupProgram=[x(m,!0),...T.setupProgram],T.setupMaterial=[I(p)],_={});return{..._,order:0,programs:[T],getTexture:p}}function x(r,n){return function(){const{gl:e,program:t}=u;let o="",a="";null!=r&&(o=r.shader({declaration:!0,exposure:r.exposure}),a=r.shader({color:!0}));const s=i(R,{declarations:"",toneMappings:"",hdrEncoding:!1})({declarations:o,toneMappings:a,hdrEncoding:n});console.log("hdrEncoding",n),c(e,t,h,s)}}function y(r){return function(){const{gl:n,program:e}=u,t=g(r),{projection:o}=r,a=(i=t.position,s=t.target,c=t.up,E=T(),l=f(v(),m(v(),i,s)),P=f(v(),d(v(),c,l)),A=f(v(),d(v(),l,P)),E[0]=P[0],E[1]=P[1],E[2]=P[2],E[3]=0,E[4]=A[0],E[5]=A[1],E[6]=A[2],E[7]=0,E[8]=l[0],E[9]=l[1],E[10]=l[2],E[11]=0,E[12]=i[0],E[13]=i[1],E[14]=i[2],E[15]=1,E);var i,s,c,E,l,P,A;const U=p(T(),a);U[12]=0,U[13]=0,U[14]=0;const M=_(T(),o,U),h=p(T(),M),R=n.getUniformLocation(e,"viewDirectionProjectionInverse");n.uniformMatrix4fv(R,!1,h)}}async function w(r,n){const e=new Image;return await new Promise(((n,t)=>{e.src=r,e.onload=function(){n(e)},e.onerror=t})),function(){const{gl:e}=u,t=e.createTexture();n(t),e.bindTexture(e.TEXTURE_CUBE_MAP,t);const o=new Image;o.src=r,e.bindTexture(e.TEXTURE_CUBE_MAP,t),function(r,n){const e=document.createElement("canvas"),t=e.getContext("2d"),o=r.width/4,a=r.height/3;e.width=o,e.height=a;const i=[[2,1,n.TEXTURE_CUBE_MAP_POSITIVE_X],[0,1,n.TEXTURE_CUBE_MAP_NEGATIVE_X],[1,0,n.TEXTURE_CUBE_MAP_POSITIVE_Y],[1,2,n.TEXTURE_CUBE_MAP_NEGATIVE_Y],[1,1,n.TEXTURE_CUBE_MAP_POSITIVE_Z],[3,1,n.TEXTURE_CUBE_MAP_NEGATIVE_Z]];i.forEach((([i,s,c])=>{t.clearRect(0,0,o,a),t.drawImage(r,i*o,s*a,o,a,0,0,o,a),n.texImage2D(c,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)}))}(o,e),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MIN_FILTER,e.LINEAR_MIPMAP_LINEAR),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_CUBE_MAP,e.TEXTURE_WRAP_R,e.CLAMP_TO_EDGE),e.generateMipmap(e.TEXTURE_CUBE_MAP),l.update((r=>r))}}function I(r){return function(){const{gl:n,program:e}=u,t=n.getUniformLocation(e,"envMap");n.uniform1i(t,0),n.activeTexture(n.TEXTURE0),n.bindTexture(n.TEXTURE_CUBE_MAP,r())}}function X(r){return function(){const{gl:n}=u;r(n.getParameter(n.DEPTH_FUNC)),n.depthFunc(n.LEQUAL)}}function B(r){return function(){const{gl:n}=u;n.depthFunc(r())}}export{P as a,U as b,C as c,w as s};
