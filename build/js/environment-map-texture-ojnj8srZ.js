import{a6 as r,W as e,au as n,Y as t,U as i,y as a,Z as o,_ as c,a0 as s,a1 as l,a2 as u,q as f,F as m,av as v,T as E,R as p}from"./engine-KQm4jTw7.js";const d=e=>({exposure:`${e.exposure.toLocaleString("en",{minimumFractionDigits:1})}f`,shader:r("${declaration?\r\n`\r\n#ifndef saturate\r\n    #define saturate( a ) clamp( a, 0.0, 1.0 )\r\n#endif\r\n\r\nfloat toneMappingExposure = ${exposure};\r\n\r\nvec3 RRTAndODTFit( vec3 v ) {\r\n    vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\r\n    vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\r\n    return a / b;\r\n}\r\nvec3 ACESFilmicToneMapping( vec3 color ) {\r\n    const mat3 ACESInputMat = mat3(\r\n    vec3( 0.59719, 0.07600, 0.02840 ), vec3( 0.35458, 0.90834, 0.13383 ), vec3( 0.04823, 0.01566, 0.83777 )\r\n    );\r\n    const mat3 ACESOutputMat = mat3(\r\n    vec3(  1.60475, -0.10208, -0.00327 ), vec3( -0.53108, 1.10813, -0.07276 ), vec3( -0.07367, -0.00605, 1.07602 )\r\n    );\r\n    color *= toneMappingExposure / 0.6;\r\n    color = ACESInputMat * color;\r\n    color = RRTAndODTFit( color );\r\n    color = ACESOutputMat * color;\r\n    return saturate( color );\r\n}\r\n` : ''\r\n}\r\n${color?\r\n`\r\n    fragColor = vec4(ACESFilmicToneMapping(fragColor.rgb),1.0f);\r\n` : ''\r\n}",{declaration:!1,exposure:1,color:!1})}),g=1016,T=1015;async function M(r){const e=await fetch(r);return function(r){const e=g,n=1,t=2,i=3,a=4,o=1,c=2,s=4,l="\n",u=new Uint8Array(r);u.pos=0;const f=x(u),m=f.width,v=f.height,E=b(u.subarray(u.pos),m,v);let p,d;switch(e){case T:d=E.length/4;const r=new Float32Array(4*d);for(let e=0;e<d;e++)R(E,4*e,r,4*e);p=r;break;case g:d=E.length/4;const n=new Uint16Array(4*d);for(let r=0;r<d;r++)A(E,4*r,n,4*r);p=n;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+e)}return{width:m,height:v,data:p,header:f.string,gamma:f.gamma,exposure:f.exposure,type:e};function M(r,e){switch(r){case n:throw new Error("THREE.RGBELoader: Read Error: "+(e||""));case t:throw new Error("THREE.RGBELoader: Write Error: "+(e||""));case i:throw new Error("THREE.RGBELoader: Bad File Format: "+(e||""));default:throw new Error("THREE.RGBELoader: Memory Error: "+(e||""))}}function h(r,e,n){const t=128;e=e||1024;let i=r.pos,a=-1,o=0,c="",s=String.fromCharCode.apply(null,new Uint16Array(r.subarray(i,i+t)));for(;0>(a=s.indexOf(l))&&o<e&&i<r.byteLength;)c+=s,o+=s.length,i+=t,s+=String.fromCharCode.apply(null,new Uint16Array(r.subarray(i,i+t)));return-1<a&&(r.pos+=o+a+1,c+s.slice(0,a))}function x(r){const e=/^#\?(\S+)/,t=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,l=/^\s*FORMAT=(\S+)\s*$/,u=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,f={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let m,v;for((r.pos>=r.byteLength||!(m=h(r)))&&M(n,"no header found"),(v=m.match(e))||M(i,"bad initial token"),f.valid|=o,f.programtype=v[1],f.string+=m+"\n";m=h(r),!1!==m;)if(f.string+=m+"\n","#"!==m.charAt(0)){if((v=m.match(t))&&(f.gamma=parseFloat(v[1])),(v=m.match(a))&&(f.exposure=parseFloat(v[1])),(v=m.match(l))&&(f.valid|=c,f.format=v[1]),(v=m.match(u))&&(f.valid|=s,f.height=parseInt(v[1],10),f.width=parseInt(v[2],10)),f.valid&c&&f.valid&s)break}else f.comments+=m+"\n";return f.valid&c||M(i,"missing format specifier"),f.valid&s||M(i,"missing image size specifier"),f}function b(r,e,t){const o=e;if(o<8||o>32767||2!==r[0]||2!==r[1]||128&r[2])return new Uint8Array(r);o!==(r[2]<<8|r[3])&&M(i,"wrong scanline width");const c=new Uint8Array(4*e*t);c.length||M(a,"unable to allocate buffer space");let s=0,l=0;const u=4*o,f=new Uint8Array(4),m=new Uint8Array(u);let v=t;for(;v>0&&l<r.byteLength;){l+4>r.byteLength&&M(n),f[0]=r[l++],f[1]=r[l++],f[2]=r[l++],f[3]=r[l++],2==f[0]&&2==f[1]&&(f[2]<<8|f[3])==o||M(i,"bad rgbe scanline format");let e,t=0;for(;t<u&&l<r.byteLength;){e=r[l++];const n=e>128;if(n&&(e-=128),(0===e||t+e>u)&&M(i,"bad scanline data"),n){const n=r[l++];for(let r=0;r<e;r++)m[t++]=n}else m.set(r.subarray(l,l+e),t),t+=e,l+=e}const a=o;for(let r=0;r<a;r++){let e=0;c[s]=m[r+e],e+=o,c[s+1]=m[r+e],e+=o,c[s+2]=m[r+e],e+=o,c[s+3]=m[r+e],s+=4}v--}return c}function R(r,e,n,t){const i=r[e+3],a=Math.pow(2,i-128)/255;n[t+0]=r[e+0]*a,n[t+1]=r[e+1]*a,n[t+2]=r[e+2]*a,n[t+3]=1}function A(r,e,n,t){const i=r[e+3],a=Math.pow(2,i-128)/255;n[t+0]=_(Math.min(r[e+0]*a,65504)),n[t+1]=_(Math.min(r[e+1]*a,65504)),n[t+2]=_(Math.min(r[e+2]*a,65504)),n[t+3]=_(1)}}(await e.arrayBuffer())}function _(r){var e,n,t;Math.abs(r)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),e=r,n=-65504,t=65504,r=Math.max(n,Math.min(t,e)),h.floatView[0]=r;const i=h.uint32View[0],a=i>>23&511;return h.baseTable[a]+((8388607&i)>>h.shiftTable[a])}const h=x();function x(){const r=new ArrayBuffer(4),e=new Float32Array(r),n=new Uint32Array(r),t=new Uint32Array(512),i=new Uint32Array(512);for(let r=0;r<256;++r){const e=r-127;e<-27?(t[r]=0,t[256|r]=32768,i[r]=24,i[256|r]=24):e<-14?(t[r]=1024>>-e-14,t[256|r]=1024>>-e-14|32768,i[r]=-e-1,i[256|r]=-e-1):e<=15?(t[r]=e+15<<10,t[256|r]=e+15<<10|32768,i[r]=13,i[256|r]=13):e<128?(t[r]=31744,t[256|r]=64512,i[r]=24,i[256|r]=24):(t[r]=31744,t[256|r]=64512,i[r]=13,i[256|r]=13)}const a=new Uint32Array(2048),o=new Uint32Array(64),c=new Uint32Array(64);for(let r=1;r<1024;++r){let e=r<<13,n=0;for(;!(8388608&e);)e<<=1,n-=8388608;e&=-8388609,n+=947912704,a[r]=e|n}for(let r=1024;r<2048;++r)a[r]=939524096+(r-1024<<13);for(let r=1;r<31;++r)o[r]=r<<23;o[31]=1199570944,o[32]=2147483648;for(let r=33;r<63;++r)o[r]=2147483648+(r-32<<23);o[63]=3347054592;for(let r=1;r<64;++r)32!==r&&(c[r]=1024);return{floatView:e,uint32View:n,baseTable:t,shiftTable:i,mantissaTable:a,exponentTable:o,offsetTable:c}}function b(r,o,c,s,l=1024){if(!o.getExtension("EXT_color_buffer_float"))throw new Error("EXT_color_buffer_float extension not supported");const u=function(r,e,n,t){const i=r.createTexture();return r.bindTexture(r.TEXTURE_2D,i),r.texImage2D(r.TEXTURE_2D,0,r.RGBA16F,n,t,0,r.RGBA,r.HALF_FLOAT,e),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.LINEAR),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.LINEAR),i}(o,r,c,s),f=function(r,e){const n=r.createTexture();r.bindTexture(r.TEXTURE_CUBE_MAP,n);for(let n=0;n<6;n++)r.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X+n,0,r.RGBA16F,e,e,0,r.RGBA,r.HALF_FLOAT,null);return r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_WRAP_R,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_MIN_FILTER,r.LINEAR_MIPMAP_LINEAR),r.texParameteri(r.TEXTURE_CUBE_MAP,r.TEXTURE_MAG_FILTER,r.LINEAR),n}(o,l),{program:m,vertexArray:v}=function(r){const e="#version 300 es\n\n    #define SHADER_NAME hdrToCubeVertex\n\n    layout(location = 0) in vec2 position;\n    out vec3 localPos;\n    uniform mat4 projectionMatrix;\n    uniform mat4 view;\n\n    void main() {\n        // Use the quad positions directly for rendering\n        gl_Position = vec4(position, 0.0, 1.0);\n        \n        // Create the ray direction for this fragment\n        // Map from [-1,1] to [-1,1] in view space for proper cubemap sampling\n        vec4 viewPos = inverse(projectionMatrix * view) * vec4(position, 1.0, 1.0);\n        localPos = viewPos.xyz / viewPos.w;\n    }",n="#version 300 es\n\n    #define SHADER_NAME hdrToCubeFragment\n\n    precision highp float;\n    in vec3 localPos;\n    out vec4 fragColor;\n    uniform sampler2D equirectangularMap;\n\n    vec2 SampleSphericalMap(vec3 v) {\n        // Convert direction vector to spherical coordinates\n        float phi = atan(v.z, v.x);\n        float theta = asin(v.y);\n        \n        // Map from [-π to π] for phi and [-π/2 to π/2] for theta to [0,1] range\n        vec2 uv = vec2(\n            0.5 + 0.5 * phi / 3.1415926535897932,\n            0.5 - theta / 3.1415926535897932\n        );\n        \n        return uv;\n    }\n\n    void main() {\n        vec3 direction = normalize(localPos);\n        vec2 uv = SampleSphericalMap(direction);\n        fragColor = texture(equirectangularMap, uv);\n    }",t=r.createProgram();if(i(r,t,e,n),r.linkProgram(t),!r.getProgramParameter(t,r.LINK_STATUS))throw console.error("Shader program error:",r.getProgramInfoLog(t)),new Error("Failed to compile shaders");const a=r.createVertexArray();r.bindVertexArray(a);const o=new Float32Array([-1,-1,1,-1,-1,1,1,1]),c=r.createBuffer();return r.bindBuffer(r.ARRAY_BUFFER,c),r.bufferData(r.ARRAY_BUFFER,o,r.STATIC_DRAW),r.enableVertexAttribArray(0),r.vertexAttribPointer(0,2,r.FLOAT,!1,0,0),{program:t,vertexArray:a}}(o),E=o.createFramebuffer();o.bindFramebuffer(o.FRAMEBUFFER,E),o.useProgram(m),o.bindVertexArray(v),o.activeTexture(o.TEXTURE0),o.bindTexture(o.TEXTURE_2D,u),o.uniform1i(o.getUniformLocation(m,"equirectangularMap"),0);const p=a(),d=Math.PI/2,g=1/Math.tan(d/2);p[0]=g/1,p[5]=g,p[10]=10.1/-9.9,p[11]=-1,p[14]=2/-9.9;const T=o.getUniformLocation(m,"projectionMatrix");o.uniformMatrix4fv(T,!1,p);const M=[],_=e();for(let r=0;r<6;r++){const e=n();let i,a;switch(r){case 0:i=[1,0,0],a=[0,-1,0];break;case 1:i=[-1,0,0],a=[0,-1,0];break;case 2:i=[0,1,0],a=[0,0,1];break;case 3:i=[0,-1,0],a=[0,0,-1];break;case 4:i=[0,0,1],a=[0,-1,0];break;case 5:i=[0,0,-1],a=[0,-1,0]}const o=[_[0]+i[0],_[1]+i[1],_[2]+i[2]];t(e,_,o,a),M.push(e)}for(let r=0;r<6;r++){o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_CUBE_MAP_POSITIVE_X+r,f,0);const e=o.checkFramebufferStatus(o.FRAMEBUFFER);e===o.FRAMEBUFFER_COMPLETE?(o.uniformMatrix4fv(o.getUniformLocation(m,"view"),!1,M[r]),o.viewport(0,0,l,l),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT),o.drawArrays(o.TRIANGLE_STRIP,0,4)):console.error("Framebuffer not complete:",e)}return o.bindFramebuffer(o.FRAMEBUFFER,null),o.deleteFramebuffer(E),o.deleteTexture(u),o.bindTexture(o.TEXTURE_CUBE_MAP,f),o.generateMipmap(o.TEXTURE_CUBE_MAP),f}function R(e){return{exposure:`${{exposure:e}.exposure.toLocaleString("en",{minimumFractionDigits:1})}f`,shader:r("${declaration?\r\n`\r\n// tone mapping taken from three.js\r\nfloat toneMappingExposure = ${exposure};\r\n\r\n    // Matrices for rec 2020 <> rec 709 color space conversion\r\n    // matrix provided in row-major order so it has been transposed\r\n    // https://www.itu.int/pub/R-REP-BT.2407-2017\r\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(vec3(1.6605f, -0.1246f, -0.0182f), vec3(-0.5876f, 1.1329f, -0.1006f), vec3(-0.0728f, -0.0083f, 1.1187f));\r\n\r\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(vec3(0.6274f, 0.0691f, 0.0164f), vec3(0.3293f, 0.9195f, 0.0880f), vec3(0.0433f, 0.0113f, 0.8956f));\r\n\r\n    // https://iolite-engine.com/blog_posts/minimal_agx_implementation\r\n    // Mean error^2: 3.6705141e-06\r\nvec3 agxDefaultContrastApprox(vec3 x) {\r\n\r\n    vec3 x2 = x * x;\r\n    vec3 x4 = x2 * x2;\r\n\r\n    return +15.5f * x4 * x2 - 40.14f * x4 * x + 31.96f * x4 - 6.868f * x2 * x + 0.4298f * x2 + 0.1191f * x - 0.00232f;\r\n\r\n}\r\n\r\nvec3 AgXToneMapping(vec3 color) {\r\n\r\n        // AgX constants\r\n    const mat3 AgXInsetMatrix = mat3(vec3(0.856627153315983f, 0.137318972929847f, 0.11189821299995f), vec3(0.0951212405381588f, 0.761241990602591f, 0.0767994186031903f), vec3(0.0482516061458583f, 0.101439036467562f, 0.811302368396859f));\r\n\r\n        // explicit AgXOutsetMatrix generated from Filaments AgXOutsetMatrixInv\r\n    const mat3 AgXOutsetMatrix = mat3(vec3(1.1271005818144368f, -0.1413297634984383f, -0.14132976349843826f), vec3(-0.11060664309660323f, 1.157823702216272f, -0.11060664309660294f), vec3(-0.016493938717834573f, -0.016493938717834257f, 1.2519364065950405f));\r\n\r\n        // LOG2_MIN      = -10.0\r\n        // LOG2_MAX      =  +6.5\r\n        // MIDDLE_GRAY   =  0.18\r\n    const float AgxMinEv = -12.47393f;  // log2( pow( 2, LOG2_MIN ) * MIDDLE_GRAY )\r\n    const float AgxMaxEv = 4.026069f;    // log2( pow( 2, LOG2_MAX ) * MIDDLE_GRAY )\r\n\r\n    color *= toneMappingExposure;\r\n\r\n    color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\r\n\r\n    color = AgXInsetMatrix * color;\r\n\r\n        // Log2 encoding\r\n    color = max(color, 1e-10f); // avoid 0 or negative numbers for log2\r\n    color = log2(color);\r\n    color = (color - AgxMinEv) / (AgxMaxEv - AgxMinEv);\r\n\r\n    color = clamp(color, 0.0f, 1.0f);\r\n\r\n        // Apply sigmoid\r\n    color = agxDefaultContrastApprox(color);\r\n\r\n        // Apply AgX look\r\n        // v = agxLook(v, look);\r\n\r\n    color = AgXOutsetMatrix * color;\r\n\r\n        // Linearize\r\n    color = pow(max(vec3(0.0f), color), vec3(2.2f));\r\n\r\n    color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\r\n\r\n        // Gamut mapping. Simple clamp for now.\r\n    color = clamp(color, 0.0f, 1.0f);\r\n\r\n    return color;\r\n\r\n}\r\n` : ''\r\n}\r\n${color?\r\n`\r\n    fragColor = vec4(AgXToneMapping(fragColor.xyz),1.0f);\r\n` : ''\r\n}",{declaration:!1,exposure:1,color:!1})}}var A="#version 300 es\r\n\r\nprecision mediump float;\r\nprecision mediump int;\r\n\r\nin vec3 position;\r\nin vec2 uv;\r\nin float faceIndex;\r\n\r\nout vec3 vOutputDirection;\r\n\r\n// RH coordinate system; PMREM face-indexing convention\r\nvec3 getDirection(vec2 uv, float face) {\r\n\r\n    uv = 2.0 * uv - 1.0;\r\n\r\n    vec3 direction = vec3(uv, 1.0);\r\n\r\n    if(face == 0.0) {\r\n        // 0 0 0\r\n        // X 0 0\r\n        direction = direction.zyx; // ( 1, v, u ) pos x\r\n\r\n    } else if(face == 1.0) {\r\n        //0 0 0\r\n        //0 X 0\r\n        direction = direction.xzy;\r\n        direction.xz *= -1.0; // ( -u, 1, -v ) pos y\r\n\r\n    } else if(face == 2.0) {\r\n        //0 0 0\r\n        //0 0 X\r\n        direction.x *= -1.0; // ( -u, v, 1 ) pos z\r\n\r\n    } else if(face == 3.0) {\r\n        // X 0 0\r\n        // 0 0 0\r\n        direction = direction.zyx;\r\n        direction.xz *= -1.0; // ( -1, v, -u ) neg x\r\n\r\n    } else if(face == 4.0) {\r\n        //0 X 0\r\n        //0 0 0\r\n        direction = direction.xzy;\r\n        direction.xy *= -1.0; // ( -u, -1, v ) neg y\r\n\r\n    } else if(face == 5.0) {\r\n        //0 0 X\r\n        //0 0 0\r\n        direction.z *= -1.0; // ( u, v, -1 ) neg z\r\n    }\r\n\r\n    return direction;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n    vOutputDirection = getDirection(uv, faceIndex);\r\n    gl_Position = vec4(position, 1.0);\r\n\r\n}",U="#version 300 es\r\n\r\nprecision mediump float;\r\nprecision mediump int;\r\n\r\n#define n 20\r\n#define CUBEUV_TEXEL_WIDTH ${CUBEUV_TEXEL_WIDTH}\r\n#define CUBEUV_TEXEL_HEIGHT ${CUBEUV_TEXEL_HEIGHT}\r\n#define CUBEUV_MAX_MIP ${CUBEUV_MAX_MIP}\r\n#define cubeUV_minMipLevel 4.0\r\n#define cubeUV_minTileSize 16.0\r\n\r\nin vec3 vOutputDirection;\r\n\r\nuniform sampler2D envMap;\r\n\r\nuniform int samples;\r\nuniform float weights[n];\r\nuniform bool latitudinal;\r\nuniform float dTheta;\r\nuniform float mipInt;\r\nuniform vec3 poleAxis;\r\n\r\nout vec4 fragColor;\r\n\r\nfloat getFace(vec3 direction) {\r\n    vec3 absDirection = abs(direction);\r\n    float face = -1.0;\r\n    if(absDirection.x > absDirection.z) {\r\n        if(absDirection.x > absDirection.y)\r\n            face = direction.x > 0.0 ? 0.0 : 3.0;\r\n        else\r\n            face = direction.y > 0.0 ? 1.0 : 4.0;\r\n    } else {\r\n        if(absDirection.z > absDirection.y)\r\n            face = direction.z > 0.0 ? 2.0 : 5.0;\r\n        else\r\n            face = direction.y > 0.0 ? 1.0 : 4.0;\r\n    }\r\n    return face;\r\n}\r\n\r\n// RH coordinate system; PMREM face-indexing convention\r\nvec2 getUV( vec3 direction, float face ) {\r\n    vec2 uv;\r\n    if ( face == 0.0 ) {\r\n        uv = vec2( direction.z, direction.y ) / abs( direction.x );\r\n    }\r\n    else if ( face == 1.0 ) {\r\n        uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\r\n    }\r\n    else if ( face == 2.0 ) {\r\n        uv = vec2( - direction.x, direction.y ) / abs( direction.z );\r\n    }\r\n    else if ( face == 3.0 ) {\r\n        uv = vec2( - direction.z, direction.y ) / abs( direction.x );\r\n    }\r\n    else if ( face == 4.0 ) {\r\n        uv = vec2( - direction.x, direction.z ) / abs( direction.y );\r\n    }\r\n    else {\r\n        uv = vec2( direction.x, direction.y ) / abs( direction.z );\r\n    }\r\n    return 0.5 * ( uv + 1.0 );\r\n}\r\n\r\nvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\r\n    float face = getFace( direction );\r\n    float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\r\n    mipInt = max( mipInt, cubeUV_minMipLevel );\r\n    float faceSize = exp2( mipInt );\r\n    highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\r\n    if ( face > 2.0 ) {\r\n        uv.y += faceSize;\r\n        face -= 3.0;\r\n    }\r\n    uv.x += face * faceSize;\r\n    uv.x += filterInt * 3.0 * cubeUV_minTileSize;\r\n    uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\r\n    uv.x *= CUBEUV_TEXEL_WIDTH;\r\n    uv.y *= CUBEUV_TEXEL_HEIGHT;\r\n    //return texture( envMap, uv).rgb;\r\n    return textureGrad( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\r\n}\r\n\r\nvec3 getSample(float theta, vec3 axis) {\r\n    float cosTheta = cos(theta);\r\n    // Rodrigues' axis-angle rotation\r\n    vec3 sampleDirection = vOutputDirection * cosTheta\r\n    + cross(axis, vOutputDirection) * sin(theta)\r\n    + axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\r\n    return bilinearCubeUV(envMap, sampleDirection, mipInt);\r\n}\r\n\r\nvoid main() {\r\n\r\n    vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\r\n    if(all(equal(axis, vec3(0.0)))) {\r\n        axis = vec3(vOutputDirection.z, 0.0, -vOutputDirection.x);\r\n    }\r\n\r\n    axis = normalize(axis);\r\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n    //fragColor = vec4(mipInt/10.0, mipInt/10.0, mipInt/10.0, 1.0f);\r\n    //fragColor = vec4(dTheta*40.0, dTheta*40.0, dTheta*40.0, 1.0f);\r\n    //fragColor.rgb = dTheta;\r\n    //fragColor.rgb += texture(envMap, vOutputDirection.xy).rgb;\r\n    fragColor.rgb += weights[0] * getSample(0.0, axis);\r\n    for(int i = 1; i < n; i++) {\r\n        if(i >= samples) {\r\n            break;\r\n        }\r\n        float theta = dTheta * float(i);\r\n        fragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\r\n        fragColor.rgb += weights[i] * getSample(theta, axis);\r\n    }\r\n}",I="#version 300 es\r\n\r\nprecision highp float;\r\nprecision highp int;\r\nprecision highp sampler2D;\r\n\r\n#define RECIPROCAL_PI 0.3183098861837907\r\n#define RECIPROCAL_PI2 0.15915494309189535\r\n\r\nuniform float flipEnvMap;\r\n\r\nin vec3 vOutputDirection;\r\n\r\nuniform sampler2D envMap;\r\n\r\nout highp vec4 fragColor;\r\n\r\nvec2 equirectUv( in vec3 dir ) {\r\n    float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\r\n    float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n    return vec2( u, v );\r\n}\r\n\r\nvoid main() {\r\n    vec3 outputDirection = normalize( vOutputDirection );\r\n    vec2 uv = equirectUv( outputDirection );\r\n    fragColor = vec4( texture ( envMap, uv ).rgb, 1.0 );\r\n}";const y=4,P=[.125,.215,.35,.446,.526,.582],L=(1+Math.sqrt(5))/2,D=1/L,C=[[-L,D,0],[L,D,0],[-D,0,L],[D,0,L],[0,L,-D],[0,L,D],[-1,1,-1],[1,1,-1],[-1,1,1],[1,1,1]];function F(r){let e={};e.image=r,e.cubeImageSize=r.width/4,e.lodMax=Math.floor(Math.log2(e.cubeImageSize)),e.cubeSize=Math.pow(2,e.lodMax),e.renderTargetWidth=3*Math.max(e.cubeSize,112),e.renderTargetHeight=4*e.cubeSize,function(r){const e=[],n=[],t=[];let i=r.lodMax;const a=r.lodMax-y+1+P.length;for(let o=0;o<a;o++){const a=Math.pow(2,i);n.push(a);let c=1/a;o>r.lodMax-y?c=P[o-r.lodMax+y-1]:0===o&&(c=0),t.push(c);const s=1/(a-2),l=-s,u=1+s,f=[l,l,u,l,u,u,l,l,u,u,l,u],m=6,v=6,E=3,d=2,g=1,T=new Float32Array(E*v*m),M=new Float32Array(d*v*m),_=new Float32Array(g*v*m);for(let r=0;r<m;r++){const e=r%3*2/3-1,n=r>2?0:-1,t=[e,n,0,e+2/3,n,0,e+2/3,n+1,0,e,n,0,e+2/3,n+1,0,e,n+1,0];T.set(t,E*v*r),M.set(f,d*v*r);const i=[r,r,r,r,r,r];_.set(i,g*v*r)}const h={attributes:{positions:T,uvs:M,faceIndex:{array:_,itemSize:g}},drawMode:p[4]};e.push(h),i>y&&i--}r.lodPlanes=e,r.sizeLods=n,r.sigmas=t}(e);const n={n:20,CUBEUV_TEXEL_WIDTH:1/e.renderTargetWidth,CUBEUV_TEXEL_HEIGHT:1/e.renderTargetHeight,CUBEUV_MAX_MIP:`${e.lodMax}.0`};let t,i,a,u,f;function m(r){t=r}function v(){return t}function E(r){i=r}function d(){return i}function g(r){a=r}function T(){return a}function M(r){u=r}function _(){return u}function h(r){f=r}function x(){return f}const b=(Math.floor((2*(e.lodPlanes.length-1)-1)/2)+1)%2==0?d:_;return{programs:[{createProgram:O(e,r,m),setupProgram:[V,o,c,N(e,g,E)],useProgram:s,selectProgram:l,setupMaterial:[G,H(v)],setupCamera:()=>()=>{},setFrameBuffer:W(T,e,X,!0),meshes:[e.lodPlanes[0]]},...new Array(2*(e.lodPlanes.length-1)).fill(0).map(((r,t)=>{const i=Math.floor(t/2)+1,a=t%2==0,u=a?"latitudinal":"longitudinal",f=a?x:T,p=a?d:_,R=Math.sqrt(e.sigmas[i]*e.sigmas[i]-e.sigmas[i-1]*e.sigmas[i-1]),A=C[(e.lodPlanes.length-i-1)%C.length],U=a?i-1:i,I=i,P=e.sizeLods[U]-1,L=isFinite(R)?Math.PI/(2*P):2*Math.PI/39,D=R/L,F=isFinite(R)?1+Math.floor(3*D):20,X=[];let O=0;for(let r=0;r<20;++r){const e=r/D,n=Math.exp(-e*e/2);X.push(n),0===r?O+=n:r<F&&(O+=2*n)}for(let r=0;r<X.length;r++)X[r]=X[r]/O;const V=e.sizeLods[I],G=3*V*(I>e.lodMax-y?I-e.lodMax+y:0),$=4*(e.cubeSize-V),k=3*V,j=2*V;return{createProgram:Y(0!==t),setupProgram:[...0===t?[z(n),o,c,N(e,h,M)]:[]],setupMaterial:[],useProgram:s,selectProgram:l,setupCamera:()=>()=>{},setFrameBuffer:W(f,e,B(G,$,k,j)),updateProgram:[H(p),w(F,X,"latitudinal"===u,A,L,e.lodMax-U)],meshes:[e.lodPlanes[i]],...t===2*(e.lodPlanes.length-1)-1?{postDraw:S(v,m,d,E,T,g,_,M,x,h,b)}:{}}}))],getTexture:b,order:-1,type:"environmentMap",width:e.renderTargetWidth,height:e.renderTargetHeight,lodMax:e.lodMax}}function S(r,e,n,t,i,a,o,c,s,l,v){return function(){!function(){const{gl:r}=E;r.enable(r.DEPTH_TEST),r.depthMask(!0)}(),function(){const{gl:r}=E;r.disable(r.SCISSOR_TEST),r.scissor(0,0,r.canvas.width,r.canvas.height)}(),function(){const{gl:r}=E;r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL,!1)}(),u();const{gl:p}=E,d=r();d&&(p.deleteTexture(d),e(null));const g=v(),T=n();T&&T!==g&&(p.deleteTexture(T),t(null));const M=o();M&&M!==g&&(p.deleteTexture(M),c(null));const _=i();_&&(p.deleteFramebuffer(_),a(null));const h=s();h&&(p.deleteFramebuffer(h),l(null)),f.set(m(f).filter((r=>"environmentMap"!==r.type)))}}function w(r,e,n,t,i,a){return function(){const{gl:o,program:c}=E,s=o.getUniformLocation(c,"samples");o.uniform1i(s,r);const l=o.getUniformLocation(c,"weights");o.uniform1fv(l,e);const u=o.getUniformLocation(c,"latitudinal");if(o.uniform1i(u,n?1:0),t){const r=o.getUniformLocation(c,"poleAxis");o.uniform3fv(r,t)}const f=o.getUniformLocation(c,"dTheta");o.uniform1f(f,i);const m=o.getUniformLocation(c,"mipInt");o.uniform1f(m,a)}}function X(r){const e=r.cubeSize;return{x:0,y:0,width:3*e,height:2*e}}function B(r,e,n,t){return function(){return{x:r,y:e,width:n,height:t}}}function O(r,e,n){return function(r){return function(){const{gl:t}=E;if(!t.getExtension("EXT_color_buffer_float"))throw new Error("EXT_color_buffer_float extension not supported");!function(r,e){const{gl:n}=E;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,!0),n.pixelStorei(n.UNPACK_ALIGNMENT,1),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1);const t=n.createTexture();e(t),n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,n.RGBA16F,r.width,r.height,0,n.RGBA,n.HALF_FLOAT,r.data),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.LINEAR),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.LINEAR),n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,!0),n.pixelStorei(n.UNPACK_ALIGNMENT,1),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),n.bindTexture(n.TEXTURE_2D,null)}(e,n),v(r)(),function(){const{gl:r}=E;r.disable(r.DEPTH_TEST),r.depthMask(!1)}(),function(){const{gl:r}=E;r.enable(r.SCISSOR_TEST)}()}}}function V(){const{gl:r,program:e}=E;i(r,e,A,I)}function z(e){return function(){const{gl:n,program:t}=E,a=r(U,e)(e);i(n,t,A,a)}}function N(r,e,n){return function(){const{gl:t}=E,{renderTargetWidth:i,renderTargetHeight:a}=r,o=t.createTexture();n(o),t.bindTexture(t.TEXTURE_2D,o),t.texImage2D(t.TEXTURE_2D,0,t.RGBA16F,i,a,0,t.RGBA,t.HALF_FLOAT,null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR);const c=t.createFramebuffer();e(c),t.bindFramebuffer(t.FRAMEBUFFER,c),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,o,0),t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null)}}function G(){return function(){const{gl:r,program:e}=E,n=r.getUniformLocation(e,"flipEnvMap");r.uniform1f(n,-1)}}function H(r){return function(){const{gl:e,program:n}=E,t=e.getUniformLocation(n,"envMap");e.uniform1i(t,0),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_2D,r())}}function W(r=null,e,n,t=!1){return function(){const{gl:i}=E,a=r?r():null,{renderTargetWidth:o,renderTargetHeight:c}=e;if(i.bindFramebuffer(i.FRAMEBUFFER,a),E.fbo!==a&&null!=a){const{x:r,y:a,width:s,height:l}=n(e);i.viewport(r,a,s,l),i.scissor(r,a,s,l),E.frameBufferWidth=o,E.frameBufferHeight=c,t&&(i.clearColor(0,0,0,0),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT|i.STENCIL_BUFFER_BIT))}E.fbo=a}}function Y(r=!1){return function(e){return function(){const{gl:n,programMap:t,vaoMap:i}=E;if(t.has(e)||r)r?(t.set(e,E.program),i.set(e,new Map)):E.program=E.programMap.get(e);else{const r=n.createProgram();t.set(e,r),i.set(e,new Map),E.program=r}}}}var $={},k={};Object.defineProperty(k,"__esModule",{value:!0}),k.setMatrixArrayType=function(r){k.ARRAY_TYPE=q=r},k.toRadian=function(r){return r*Q},k.equals=function(r,e){return Math.abs(r-e)<=j*Math.max(1,Math.abs(r),Math.abs(e))},k.RANDOM=k.ARRAY_TYPE=k.EPSILON=void 0;var j=1e-6;k.EPSILON=j;var q="undefined"!=typeof Float32Array?Float32Array:Array;k.ARRAY_TYPE=q;var K=Math.random;k.RANDOM=K;var Q=Math.PI/180;function Z(r){return Z="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(r){return typeof r}:function(r){return r&&"function"==typeof Symbol&&r.constructor===Symbol&&r!==Symbol.prototype?"symbol":typeof r},Z(r)}Math.hypot||(Math.hypot=function(){for(var r=0,e=arguments.length;e--;)r+=arguments[e]*arguments[e];return Math.sqrt(r)}),Object.defineProperty($,"__esModule",{value:!0}),$.create=function(){var r=new rr.ARRAY_TYPE(9);rr.ARRAY_TYPE!=Float32Array&&(r[1]=0,r[2]=0,r[3]=0,r[5]=0,r[6]=0,r[7]=0);return r[0]=1,r[4]=1,r[8]=1,r},$.fromMat4=function(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[4],r[4]=e[5],r[5]=e[6],r[6]=e[8],r[7]=e[9],r[8]=e[10],r},$.clone=function(r){var e=new rr.ARRAY_TYPE(9);return e[0]=r[0],e[1]=r[1],e[2]=r[2],e[3]=r[3],e[4]=r[4],e[5]=r[5],e[6]=r[6],e[7]=r[7],e[8]=r[8],e},$.copy=function(r,e){return r[0]=e[0],r[1]=e[1],r[2]=e[2],r[3]=e[3],r[4]=e[4],r[5]=e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r},$.fromValues=function(r,e,n,t,i,a,o,c,s){var l=new rr.ARRAY_TYPE(9);return l[0]=r,l[1]=e,l[2]=n,l[3]=t,l[4]=i,l[5]=a,l[6]=o,l[7]=c,l[8]=s,l},$.set=function(r,e,n,t,i,a,o,c,s,l){return r[0]=e,r[1]=n,r[2]=t,r[3]=i,r[4]=a,r[5]=o,r[6]=c,r[7]=s,r[8]=l,r};var J=$.identity=function(r){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=1,r[5]=0,r[6]=0,r[7]=0,r[8]=1,r};$.transpose=function(r,e){if(r===e){var n=e[1],t=e[2],i=e[5];r[1]=e[3],r[2]=e[6],r[3]=n,r[5]=e[7],r[6]=t,r[7]=i}else r[0]=e[0],r[1]=e[3],r[2]=e[6],r[3]=e[1],r[4]=e[4],r[5]=e[7],r[6]=e[2],r[7]=e[5],r[8]=e[8];return r},$.invert=function(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],o=e[4],c=e[5],s=e[6],l=e[7],u=e[8],f=u*o-c*l,m=-u*a+c*s,v=l*a-o*s,E=n*f+t*m+i*v;if(!E)return null;return E=1/E,r[0]=f*E,r[1]=(-u*t+i*l)*E,r[2]=(c*t-i*o)*E,r[3]=m*E,r[4]=(u*n-i*s)*E,r[5]=(-c*n+i*a)*E,r[6]=v*E,r[7]=(-l*n+t*s)*E,r[8]=(o*n-t*a)*E,r},$.adjoint=function(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],o=e[4],c=e[5],s=e[6],l=e[7],u=e[8];return r[0]=o*u-c*l,r[1]=i*l-t*u,r[2]=t*c-i*o,r[3]=c*s-a*u,r[4]=n*u-i*s,r[5]=i*a-n*c,r[6]=a*l-o*s,r[7]=t*s-n*l,r[8]=n*o-t*a,r},$.determinant=function(r){var e=r[0],n=r[1],t=r[2],i=r[3],a=r[4],o=r[5],c=r[6],s=r[7],l=r[8];return e*(l*a-o*s)+n*(-l*i+o*c)+t*(s*i-a*c)},$.multiply=nr,$.translate=function(r,e,n){var t=e[0],i=e[1],a=e[2],o=e[3],c=e[4],s=e[5],l=e[6],u=e[7],f=e[8],m=n[0],v=n[1];return r[0]=t,r[1]=i,r[2]=a,r[3]=o,r[4]=c,r[5]=s,r[6]=m*t+v*o+l,r[7]=m*i+v*c+u,r[8]=m*a+v*s+f,r},$.rotate=function(r,e,n){var t=e[0],i=e[1],a=e[2],o=e[3],c=e[4],s=e[5],l=e[6],u=e[7],f=e[8],m=Math.sin(n),v=Math.cos(n);return r[0]=v*t+m*o,r[1]=v*i+m*c,r[2]=v*a+m*s,r[3]=v*o-m*t,r[4]=v*c-m*i,r[5]=v*s-m*a,r[6]=l,r[7]=u,r[8]=f,r},$.scale=function(r,e,n){var t=n[0],i=n[1];return r[0]=t*e[0],r[1]=t*e[1],r[2]=t*e[2],r[3]=i*e[3],r[4]=i*e[4],r[5]=i*e[5],r[6]=e[6],r[7]=e[7],r[8]=e[8],r},$.fromTranslation=function(r,e){return r[0]=1,r[1]=0,r[2]=0,r[3]=0,r[4]=1,r[5]=0,r[6]=e[0],r[7]=e[1],r[8]=1,r},$.fromRotation=function(r,e){var n=Math.sin(e),t=Math.cos(e);return r[0]=t,r[1]=n,r[2]=0,r[3]=-n,r[4]=t,r[5]=0,r[6]=0,r[7]=0,r[8]=1,r},$.fromScaling=function(r,e){return r[0]=e[0],r[1]=0,r[2]=0,r[3]=0,r[4]=e[1],r[5]=0,r[6]=0,r[7]=0,r[8]=1,r},$.fromMat2d=function(r,e){return r[0]=e[0],r[1]=e[1],r[2]=0,r[3]=e[2],r[4]=e[3],r[5]=0,r[6]=e[4],r[7]=e[5],r[8]=1,r},$.fromQuat=function(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],o=n+n,c=t+t,s=i+i,l=n*o,u=t*o,f=t*c,m=i*o,v=i*c,E=i*s,p=a*o,d=a*c,g=a*s;return r[0]=1-f-E,r[3]=u-g,r[6]=m+d,r[1]=u+g,r[4]=1-l-E,r[7]=v-p,r[2]=m-d,r[5]=v+p,r[8]=1-l-f,r},$.normalFromMat4=function(r,e){var n=e[0],t=e[1],i=e[2],a=e[3],o=e[4],c=e[5],s=e[6],l=e[7],u=e[8],f=e[9],m=e[10],v=e[11],E=e[12],p=e[13],d=e[14],g=e[15],T=n*c-t*o,M=n*s-i*o,_=n*l-a*o,h=t*s-i*c,x=t*l-a*c,b=i*l-a*s,R=u*p-f*E,A=u*d-m*E,U=u*g-v*E,I=f*d-m*p,y=f*g-v*p,P=m*g-v*d,L=T*P-M*y+_*I+h*U-x*A+b*R;if(!L)return null;return L=1/L,r[0]=(c*P-s*y+l*I)*L,r[1]=(s*U-o*P-l*A)*L,r[2]=(o*y-c*U+l*R)*L,r[3]=(i*y-t*P-a*I)*L,r[4]=(n*P-i*U+a*A)*L,r[5]=(t*U-n*y-a*R)*L,r[6]=(p*b-d*x+g*h)*L,r[7]=(d*_-E*b-g*M)*L,r[8]=(E*x-p*_+g*T)*L,r},$.projection=function(r,e,n){return r[0]=2/e,r[1]=0,r[2]=0,r[3]=0,r[4]=-2/n,r[5]=0,r[6]=-1,r[7]=1,r[8]=1,r},$.str=function(r){return"mat3("+r[0]+", "+r[1]+", "+r[2]+", "+r[3]+", "+r[4]+", "+r[5]+", "+r[6]+", "+r[7]+", "+r[8]+")"},$.frob=function(r){return Math.hypot(r[0],r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8])},$.add=function(r,e,n){return r[0]=e[0]+n[0],r[1]=e[1]+n[1],r[2]=e[2]+n[2],r[3]=e[3]+n[3],r[4]=e[4]+n[4],r[5]=e[5]+n[5],r[6]=e[6]+n[6],r[7]=e[7]+n[7],r[8]=e[8]+n[8],r},$.subtract=tr,$.multiplyScalar=function(r,e,n){return r[0]=e[0]*n,r[1]=e[1]*n,r[2]=e[2]*n,r[3]=e[3]*n,r[4]=e[4]*n,r[5]=e[5]*n,r[6]=e[6]*n,r[7]=e[7]*n,r[8]=e[8]*n,r},$.multiplyScalarAndAdd=function(r,e,n,t){return r[0]=e[0]+n[0]*t,r[1]=e[1]+n[1]*t,r[2]=e[2]+n[2]*t,r[3]=e[3]+n[3]*t,r[4]=e[4]+n[4]*t,r[5]=e[5]+n[5]*t,r[6]=e[6]+n[6]*t,r[7]=e[7]+n[7]*t,r[8]=e[8]+n[8]*t,r},$.exactEquals=function(r,e){return r[0]===e[0]&&r[1]===e[1]&&r[2]===e[2]&&r[3]===e[3]&&r[4]===e[4]&&r[5]===e[5]&&r[6]===e[6]&&r[7]===e[7]&&r[8]===e[8]},$.equals=function(r,e){var n=r[0],t=r[1],i=r[2],a=r[3],o=r[4],c=r[5],s=r[6],l=r[7],u=r[8],f=e[0],m=e[1],v=e[2],E=e[3],p=e[4],d=e[5],g=e[6],T=e[7],M=e[8];return Math.abs(n-f)<=rr.EPSILON*Math.max(1,Math.abs(n),Math.abs(f))&&Math.abs(t-m)<=rr.EPSILON*Math.max(1,Math.abs(t),Math.abs(m))&&Math.abs(i-v)<=rr.EPSILON*Math.max(1,Math.abs(i),Math.abs(v))&&Math.abs(a-E)<=rr.EPSILON*Math.max(1,Math.abs(a),Math.abs(E))&&Math.abs(o-p)<=rr.EPSILON*Math.max(1,Math.abs(o),Math.abs(p))&&Math.abs(c-d)<=rr.EPSILON*Math.max(1,Math.abs(c),Math.abs(d))&&Math.abs(s-g)<=rr.EPSILON*Math.max(1,Math.abs(s),Math.abs(g))&&Math.abs(l-T)<=rr.EPSILON*Math.max(1,Math.abs(l),Math.abs(T))&&Math.abs(u-M)<=rr.EPSILON*Math.max(1,Math.abs(u),Math.abs(M))},$.sub=$.mul=void 0;var rr=function(r,e){if(r&&r.__esModule)return r;if(null===r||"object"!==Z(r)&&"function"!=typeof r)return{default:r};var n=er(e);if(n&&n.has(r))return n.get(r);var t={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in r)if("default"!==a&&Object.prototype.hasOwnProperty.call(r,a)){var o=i?Object.getOwnPropertyDescriptor(r,a):null;o&&(o.get||o.set)?Object.defineProperty(t,a,o):t[a]=r[a]}t.default=r,n&&n.set(r,t);return t}(k);function er(r){if("function"!=typeof WeakMap)return null;var e=new WeakMap,n=new WeakMap;return(er=function(r){return r?n:e})(r)}function nr(r,e,n){var t=e[0],i=e[1],a=e[2],o=e[3],c=e[4],s=e[5],l=e[6],u=e[7],f=e[8],m=n[0],v=n[1],E=n[2],p=n[3],d=n[4],g=n[5],T=n[6],M=n[7],_=n[8];return r[0]=m*t+v*o+E*l,r[1]=m*i+v*c+E*u,r[2]=m*a+v*s+E*f,r[3]=p*t+d*o+g*l,r[4]=p*i+d*c+g*u,r[5]=p*a+d*s+g*f,r[6]=T*t+M*o+_*l,r[7]=T*i+M*c+_*u,r[8]=T*a+M*s+_*f,r}function tr(r,e,n){return r[0]=e[0]-n[0],r[1]=e[1]-n[1],r[2]=e[2]-n[2],r[3]=e[3]-n[3],r[4]=e[4]-n[4],r[5]=e[5]-n[5],r[6]=e[6]-n[6],r[7]=e[7]-n[7],r[8]=e[8]-n[8],r}var ir=nr;$.mul=ir;var ar=tr;$.sub=ar;const or="envMap",cr=({envMap:e,width:n,height:t,lodMax:i,envMapIntensity:a=1,envMapRotation:o=J([])})=>{const c={CUBEUV_TEXEL_WIDTH:1/n,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${i}.0`};let s;return{type:or,...a&&{envMapIntensity:a},...o&&{envMapRotation:o},shader:r("${declaration?\r\n`\r\n#define PI 3.141592653589793\r\n\r\n#define CUBEUV_TEXEL_WIDTH ${CUBEUV_TEXEL_WIDTH}\r\n#define CUBEUV_TEXEL_HEIGHT ${CUBEUV_TEXEL_HEIGHT}\r\n#define CUBEUV_MAX_MIP ${CUBEUV_MAX_MIP}\r\n\r\n#define cubeUV_minMipLevel 4.0\r\n#define cubeUV_minTileSize 16.0\r\n\r\nuniform float envMapIntensity;\r\nuniform mat3 envMapRotation;\r\nuniform sampler2D envMap;\r\n\r\nfloat getFace( vec3 direction ) {\r\n    vec3 absDirection = abs( direction );\r\n    float face = - 1.0;\r\n    if ( absDirection.x > absDirection.z ) {\r\n        if ( absDirection.x > absDirection.y )\r\n        face = direction.x > 0.0 ? 0.0 : 3.0;\r\n        else\r\n        face = direction.y > 0.0 ? 1.0 : 4.0;\r\n    }\r\n    else {\r\n        if ( absDirection.z > absDirection.y )\r\n        face = direction.z > 0.0 ? 2.0 : 5.0;\r\n        else\r\n        face = direction.y > 0.0 ? 1.0 : 4.0;\r\n    }\r\n    return face;\r\n}\r\nvec2 getUV( vec3 direction, float face ) {\r\n    vec2 uv;\r\n    if ( face == 0.0 ) {\r\n        uv = vec2( direction.z, direction.y ) / abs( direction.x );\r\n    }\r\n    else if ( face == 1.0 ) {\r\n        uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\r\n    }\r\n    else if ( face == 2.0 ) {\r\n        uv = vec2( - direction.x, direction.y ) / abs( direction.z );\r\n    }\r\n    else if ( face == 3.0 ) {\r\n        uv = vec2( - direction.z, direction.y ) / abs( direction.x );\r\n    }\r\n    else if ( face == 4.0 ) {\r\n        uv = vec2( - direction.x, direction.z ) / abs( direction.y );\r\n    }\r\n    else {\r\n        uv = vec2( direction.x, direction.y ) / abs( direction.z );\r\n    }\r\n    return 0.5 * ( uv + 1.0 );\r\n}\r\n\r\nvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\r\n    float face = getFace( direction );\r\n    float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\r\n    mipInt = max( mipInt, cubeUV_minMipLevel );\r\n    float faceSize = exp2( mipInt );\r\n    highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\r\n    if ( face > 2.0 ) {\r\n        uv.y += faceSize;\r\n        face -= 3.0;\r\n    }\r\n    uv.x += face * faceSize;\r\n    uv.x += filterInt * 3.0 * cubeUV_minTileSize;\r\n    uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\r\n    uv.x *= CUBEUV_TEXEL_WIDTH;\r\n    uv.y *= CUBEUV_TEXEL_HEIGHT;\r\n    //return texture( envMap, uv).rgb;\r\n    return textureGrad( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\r\n}\r\nfloat roughnessToMip( float roughness ) {\r\n    float mip = 0.0;\r\n    if ( roughness >= 0.8 ) {\r\n        mip = ( 1.0 - roughness ) * ( - 1.0 - - 2.0 ) / ( 1.0 - 0.8 ) + - 2.0;\r\n    }\r\n    else if ( roughness >= 0.4 ) {\r\n        mip = ( 0.8 - roughness ) * ( 2.0 - - 1.0 ) / ( 0.8 - 0.4 ) + - 1.0;\r\n    }\r\n    else if ( roughness >= 0.305 ) {\r\n        mip = ( 0.4 - roughness ) * ( 3.0 - 2.0 ) / ( 0.4 - 0.305 ) + 2.0;\r\n    }\r\n    else if ( roughness >= 0.21 ) {\r\n        mip = ( 0.305 - roughness ) * ( 4.0 - 3.0 ) / ( 0.305 - 0.21 ) + 3.0;\r\n    }\r\n    else {\r\n        mip = - 2.0 * log2( 1.16 * roughness );\r\n    }\r\n    return mip;\r\n}\r\nvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\r\n    float mip = clamp( roughnessToMip( roughness ), - 2.0, 8.0 );\r\n    float mipF = fract( mip );\r\n    float mipInt = floor( mip );\r\n    vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\r\n    if ( mipF == 0.0 ) {\r\n        return vec4( color0, 1.0 );\r\n    }\r\n    else {\r\n        vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\r\n        return vec4( mix( color0, color1, mipF ), 1.0 );\r\n    }\r\n}\r\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\r\n    return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\r\n}\r\nvec3 getIBLIrradiance( const in vec3 normal ) {\r\n    vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\r\n    vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\r\n    return PI * envMapColor.rgb * envMapIntensity;\r\n}\r\nvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\r\n    vec3 reflectVec = reflect( - viewDir, normal );\r\n    reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\r\n    reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\r\n    vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\r\n    return envMapColor.rgb * envMapIntensity;\r\n}\r\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\r\n    float dotNV = saturate( dot( normal, viewDir ) );\r\n    const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\r\n    const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\r\n    vec4 r = roughness * c0 + c1;\r\n    float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\r\n    vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\r\n    return fab;\r\n}\r\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\r\n    vec2 fab = DFGApprox( normal, viewDir, roughness );\r\n    vec3 Fr = specularColor;\r\n    vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\r\n    float Ess = fab.x + fab.y;\r\n    float Ems = 1.0 - Ess;\r\n    vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\r\n    vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\r\n    singleScatter += FssEss;\r\n    multiScatter += Fms * Ems;\r\n}\r\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\r\n    vec3 singleScattering = vec3( 0.0 );\r\n    vec3 multiScattering = vec3( 0.0 );\r\n    vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\r\n    computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\r\n    vec3 totalScattering = singleScattering + multiScattering;\r\n    vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\r\n    reflectedLight.indirectSpecular += radiance * singleScattering;\r\n    reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\r\n    reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\r\n}\r\n` : ''\r\n}\r\n${irradiance?\r\n`\r\n    vec3 geometryClearcoatNormal = vec3( 0.0 );\r\n    vec3 clearcoatRadiance = vec3( 0.0 );\r\n    vec3 iblIrradiance = vec3( 0.0 );\r\n    vec3 radiance = vec3( 0.0 );\r\n    iblIrradiance += getIBLIrradiance( geometryNormal );\r\n    radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\r\n    RE_IndirectSpecular_Physical( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\r\n` : ''\r\n}\r\n",{declaration:!1,irradiance:!1,CUBEUV_TEXEL_WIDTH:0,CUBEUV_TEXEL_HEIGHT:0,CUBEUV_MAX_MIP:0}),shaderDefines:c,setupTexture:lr(e,(function(r){s=r}),a,o),bindTexture:sr((function(){return s})),envMap:e}};function sr(r){return function(){const{gl:e,program:n}=E,t=e.getUniformLocation(n,or);e.activeTexture(e.TEXTURE3),e.bindTexture(e.TEXTURE_2D,r()),e.uniform1i(t,3)}}function lr(r,e,n,t){return function(){const{gl:i,program:a}=E;e(r());const o=i.getUniformLocation(a,or);i.activeTexture(i.TEXTURE3),i.bindTexture(i.TEXTURE_2D,r()),i.uniform1i(o,3),i.uniform1f(i.getUniformLocation(a,"envMapIntensity"),n),i.uniformMatrix3fv(i.getUniformLocation(a,"envMapRotation"),!1,t)}}export{F as a,cr as b,d as c,R as g,b as h,M as l};
