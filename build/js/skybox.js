import{av as e,aC as r,r as n,a4 as t,U as o,Z as a,_ as i,a0 as s,a1 as E,aD as c,aE as u,aF as T,T as _,R as l,F as g,aG as p,at as f,y as P,Q as m,P as U,W as d,O as A}from"./engine.js";var v="#version 300 es\r\n\r\n#define SHADER_NAME skyboxVertex\r\n\r\nin vec4 position;\r\nout vec4 v_position;\r\nvoid main() {\r\n    v_position = position;\r\n    gl_Position = position;\r\n    gl_Position.z = 1.0;\r\n}",R="#version 300 es\r\nprecision highp float;\r\n\r\n#define SHADER_NAME skyboxFragment\r\n\r\nuniform samplerCube skybox;\r\nuniform mat4 viewDirectionProjectionInverse;\r\n\r\n${declarations}\r\n  \r\nin vec4 v_position;\r\n  \r\n// we need to declare an output for the fragment shader\r\nout vec4 fragColor;\r\nvec4 sRGBTransferOETF( in vec4 value ) {\r\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\r\n}\r\nvoid main() {\r\n  vec4 t = viewDirectionProjectionInverse * v_position;\r\n  fragColor = texture(skybox, normalize(t.xyz / t.w));\r\n  ${toneMappings}\r\n  ${hdrEncoding ? `\r\n  fragColor = sRGBTransferOETF(fragColor);\r\n  ` : ''}\r\n}";async function M(t){let o;function g(e){o=e}function p(){return o}console.log("createSkyBox",t);const f={createProgram:e,setupProgram:[a,i],setupMaterial:[],bindTextures:[X(p)],setupCamera:C,useProgram:s,selectProgram:E,updateProgram:[c("LEQUAL")],meshes:[{attributes:{positionsSize:2,positions:new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1])},drawMode:l[4]}],setFrameBuffer:u,postDraw:T};let P,m;if(function(e){return"url"in e&&"string"==typeof e.url}(t)){console.log("CubeMap Skybox"),f.setupMaterial=[await t.convertToCube(t.url,g)];const e=t.hdrEncoding??!1;f.setupProgram=[x(null,e),...f.setupProgram],P={url:t.url}}else if(function(e){return"typedArray"in e&&e.typedArray instanceof Uint16Array||"texture"in e&&e.texture instanceof WebGLTexture}(t)){console.log("HDR Skybox");const o=t.typedArray??t.texture;f.createProgram=function(r){return function(n){return function(){null!=r&&r(),e(n)()}}}(function(e,t,o,a,i,s,E){return function(){const{gl:c}=_;if(null==o()){const o=a(e,c,i,s,E);t(o),r(),n.update((e=>e))}}}(o,g,p,t.convertToCube,t.width,t.height,t.cubeSize)),m=t.toneMapping,f.setupProgram=[x(m,!0),...f.setupProgram],f.setupMaterial=[X(p)],P={}}return{...P,order:0,programs:[f],getTexture:p}}function x(e,r){return function(){const{gl:n,program:a}=_;let i="",s="";null!=e&&(i=e.shader({declaration:!0,exposure:e.exposure}),s=e.shader({color:!0}));const E=t(R,{declarations:"",toneMappings:"",hdrEncoding:!1})({declarations:i,toneMappings:s,hdrEncoding:r});o(n,a,v,E)}}function C(e){return function(){const{gl:r,program:n}=_,t=g(e),{projection:o}=e,a=(i=t.position,s=t.target,E=t.up,c=P(),u=m(d(),U(d(),i,s)),T=m(d(),A(d(),E,u)),l=m(d(),A(d(),u,T)),c[0]=T[0],c[1]=T[1],c[2]=T[2],c[3]=0,c[4]=l[0],c[5]=l[1],c[6]=l[2],c[7]=0,c[8]=u[0],c[9]=u[1],c[10]=u[2],c[11]=0,c[12]=i[0],c[13]=i[1],c[14]=i[2],c[15]=1,c);var i,s,E,c,u,T,l;const v=p(P(),a);v[12]=0,v[13]=0,v[14]=0;const R=f(P(),o,v),M=p(P(),R),x=r.getUniformLocation(n,"viewDirectionProjectionInverse");r.uniformMatrix4fv(x,!1,M)}}async function I(e,r){const t=new Image;return await new Promise(((r,n)=>{t.src=e,t.onload=function(){r(t)},t.onerror=n})),function(){const{gl:t}=_,o=t.createTexture();r(o),t.bindTexture(t.TEXTURE_CUBE_MAP,o);const a=new Image;a.src=e,t.bindTexture(t.TEXTURE_CUBE_MAP,o),function(e,r){const n=document.createElement("canvas"),t=n.getContext("2d"),o=e.width/4,a=e.height/3;n.width=o,n.height=a;const i=[[2,1,r.TEXTURE_CUBE_MAP_POSITIVE_X],[0,1,r.TEXTURE_CUBE_MAP_NEGATIVE_X],[1,0,r.TEXTURE_CUBE_MAP_POSITIVE_Y],[1,2,r.TEXTURE_CUBE_MAP_NEGATIVE_Y],[1,1,r.TEXTURE_CUBE_MAP_POSITIVE_Z],[3,1,r.TEXTURE_CUBE_MAP_NEGATIVE_Z]];i.forEach((([i,s,E])=>{t.clearRect(0,0,o,a),t.drawImage(e,i*o,s*a,o,a,0,0,o,a),r.texImage2D(E,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,n)}))}(a,t),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MIN_FILTER,t.LINEAR_MIPMAP_LINEAR),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_R,t.CLAMP_TO_EDGE),t.generateMipmap(t.TEXTURE_CUBE_MAP),n.update((e=>e))}}function X(e){return function(){const{gl:r,program:n}=_,t=r.getUniformLocation(n,"envMap");r.uniform1i(t,0),r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_CUBE_MAP,e())}}export{M as c,I as s};
