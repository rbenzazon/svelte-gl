import { H as drawModes, y as identity, I as cross, J as subtract, K as normalize, S as SvelteComponent, i as init, s as safe_not_equal, M as Menu, e as element, a as space, c as create_component, b as insert, m as mount_component, n as noop, t as transition_in, d as transition_out, f as detach, g as destroy_component, h as component_subscribe, o as onMount, r as renderer, l as lights, j as scene, k as materials, p as camera, q as renderPasses, x as translate, z as set_store_value, A as skyblue, B as createLightStore, C as createPointLight, w as scale, L as rotateY, G as createMaterialStore, D as create3DObject, E as createOrbitControls, F as binding_callbacks } from './Menu-BNuEDtNx.js';
import { c as createPlane } from './plane-DGeL88-p.js';
import { c as createTexture } from './texture-CQ2z1OC_.js';
import { c as createContactShadowPass } from './contact-shadow-EAOCNYT4.js';

async function loadOBJFile(url) {
	try {
		const response = await fetch(url);
		if (!response.ok) {
			throw new Error(`Failed to fetch OBJ file: ${response.statusText}`);
		}
		const content = await response.text();
		return await parseOBJ(content, url);
	} catch (error) {
		console.error("Error loading OBJ file:", error);
	}
}

/**
 *
 * @param {string} content
 * @param {string} url
 * @returns
 */
async function parseOBJ(content, url) {
	const rows = content.split("\n");
	const vertex = [];
	const positions = [];
	const normals = [];
	const uvs = [];
	const indices = [];
	const object = {
		attributes: {},
		drawMode: drawModes[4],
		material: {
			diffuse: [1, 1, 1],
			metalness: 0,
		},
		matrix: identity(new Float32Array(16)),
	};
	for (let i = 0; i < rows.length; i++) {
		const row = rows[i];
		if (row.startsWith("v ")) {
			const [, x, y, z] = row.split(" ");
			vertex.push(parseFloat(x), parseFloat(y), parseFloat(z));
		}
		if (row.startsWith("vn ")) {
			const [, x, y, z] = row.split(" ");
			normals.push(parseFloat(x), parseFloat(y), parseFloat(z));
		}
		if (row.startsWith("vt ")) {
			const [, x, y] = row.split(" ");
			uvs.push(parseFloat(x), parseFloat(y));
		}
		if (row.startsWith("f ")) {
			const [, a, b, c] = row.split(" ");

			//indices.push(parseInt(a)-1, parseInt(b)-1, parseInt(c)-1);
			const aAddress = (parseInt(a) - 1) * 3;
			const bAddress = (parseInt(b) - 1) * 3;
			const cAddress = (parseInt(c) - 1) * 3;

			const v1 = [vertex[aAddress], vertex[aAddress + 1], vertex[aAddress + 2]];
			const v2 = [vertex[bAddress], vertex[bAddress + 1], vertex[bAddress + 2]];
			const v3 = [vertex[cAddress], vertex[cAddress + 1], vertex[cAddress + 2]];

			positions.push(...v1);
			positions.push(...v2);
			positions.push(...v3);

			//add normal
			const normal = cross([], subtract([], v3, v2), subtract([], v1, v2));
			normalize(normal, normal);
			normals.push(...normal, ...normal, ...normal);
		}
	}

	if (positions.length > 0) {
		object.attributes.positions = new Float32Array(positions);
	}
	if (normals.length > 0) {
		object.attributes.normals = new Float32Array(normals);
	}
	if (uvs.length > 0) {
		object.attributes.uvs = new Float32Array(uvs);
	}
	if (indices.length > 0) {
		object.attributes.elements = new Uint16Array(indices);
	}

	return object;
}

/* src\venus.svelte generated by Svelte v4.2.18 */

function create_fragment(ctx) {
	let canvas_1;
	let t;
	let menu;
	let current;
	menu = new Menu({});

	return {
		c() {
			canvas_1 = element("canvas");
			t = space();
			create_component(menu.$$.fragment);
		},
		m(target, anchor) {
			insert(target, canvas_1, anchor);
			/*canvas_1_binding*/ ctx[1](canvas_1);
			insert(target, t, anchor);
			mount_component(menu, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(menu.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(menu.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(canvas_1);
				detach(t);
			}

			/*canvas_1_binding*/ ctx[1](null);
			destroy_component(menu, detaching);
		}
	};
}

function animate() {
	
} // animate here

function instance($$self, $$props, $$invalidate) {
	let $renderer;
	let $lights;
	let $scene;
	let $materials;
	let $camera;
	let $renderPasses;
	component_subscribe($$self, renderer, $$value => $$invalidate(2, $renderer = $$value));
	component_subscribe($$self, lights, $$value => $$invalidate(3, $lights = $$value));
	component_subscribe($$self, scene, $$value => $$invalidate(4, $scene = $$value));
	component_subscribe($$self, materials, $$value => $$invalidate(5, $materials = $$value));
	component_subscribe($$self, camera, $$value => $$invalidate(6, $camera = $$value));
	component_subscribe($$self, renderPasses, $$value => $$invalidate(7, $renderPasses = $$value));
	let canvas;

	onMount(async () => {
		const groundMatrix = identity(new Float32Array(16));
		translate(groundMatrix, groundMatrix, [0, -1.5, 0]);

		set_store_value(
			renderer,
			$renderer = {
				...$renderer,
				canvas,
				backgroundColor: skyblue,
				ambientLightColor: [0xffffff, 0.1]
			},
			$renderer
		);

		const shadowPass = createContactShadowPass(groundMatrix, 1, 10, 10, 1024, 128, 0.5);
		const { getTexture: shadowTexture } = shadowPass;
		set_store_value(renderPasses, $renderPasses = [shadowPass], $renderPasses);

		set_store_value(
			camera,
			$camera = {
				position: [0, 5, -5],
				target: [0, 2, 0],
				fov: 75
			},
			$camera
		);

		const light = createLightStore(createPointLight({
			position: [-2, 3, -3],
			color: [1, 1, 1],
			intensity: 20,
			cutoffDistance: 0,
			decayExponent: 2
		}));

		const light2 = createLightStore(createPointLight({
			position: [2, -1, -1],
			color: [1, 1, 1],
			intensity: 20,
			cutoffDistance: 0,
			decayExponent: 2
		}));

		const secondCubePos = identity(new Float32Array(16));
		translate(secondCubePos, secondCubePos, [3, 0, 0]);
		scale(secondCubePos, secondCubePos, [0.1, 0.1, 0.1]);
		const groundMesh = createPlane(10, 10, 1, 1);

		const groundDiffuseMap = await createTexture({
			textureBuffer: shadowTexture,
			type: "diffuse"
		});

		const groundMaterial = createMaterialStore({
			diffuse: [1, 1, 1],
			metalness: 0,
			diffuseMap: groundDiffuseMap,
			transparent: true
		});

		const venus = await loadOBJFile("venus.obj");
		venus.matrix = rotateY(venus.matrix, venus.matrix, Math.PI);
		venus.matrix = scale(venus.matrix, venus.matrix, [0.003, 0.003, 0.003]);
		venus.matrix = translate(venus.matrix, venus.matrix, [0, -450, 0]);
		const venusMaterial = createMaterialStore(venus.material);
		venus.material = venusMaterial;
		set_store_value(materials, $materials = [...$materials, venusMaterial, groundMaterial], $materials);

		set_store_value(
			scene,
			$scene = [
				...$scene,
				create3DObject({
					...groundMesh,
					matrix: groundMatrix,
					material: groundMaterial
				}),
				create3DObject(venus)
			],
			$scene
		);

		set_store_value(lights, $lights = [...$lights, light, light2], $lights);

		set_store_value(
			renderer,
			$renderer = {
				...$renderer,
				loop: animate,
				enabled: true
			},
			$renderer
		);

		createOrbitControls(canvas, camera);
	});

	function canvas_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvas = $$value;
			$$invalidate(0, canvas);
		});
	}

	return [canvas, canvas_1_binding];
}

class Venus extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export { Venus as default };
