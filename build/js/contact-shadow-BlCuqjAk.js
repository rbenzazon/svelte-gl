import{K as r,F as e,L as n,N as t,O as o,P as a,Q as i,R as c,T as s}from"./Menu-z2xJb2L1.js";var f="#version 300 es\r\n\r\nprecision highp float;\r\n\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\nuniform mat4 world;\r\n\r\nin vec3 position;\r\n\r\nout vec2 vHighPrecisionZW;\r\n\r\nvoid main() {\r\n\tgl_Position = projection * view * world * vec4( position, 1.0 );\r\n\tvHighPrecisionZW = gl_Position.zw;\r\n}",u="#version 300 es\r\n\r\nout highp vec4 fragColor;\r\n\r\nprecision highp float;\r\nprecision highp int;\r\n\r\nuniform float darkness;\r\nin vec2 vHighPrecisionZW;\r\n\r\nvoid main() {\r\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\r\n\tfragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );\r\n\t//fragColor = vec4( vec3( fragCoordZ ), 1.0 );\r\n\t//debug fragColor = vec4( vec3(( 1.0  ) ) ,1.0);\r\n}\r\n\t\t\t\t\t",l="#version 300 es\r\n\r\nin vec4 position;\r\nin vec2 uv;\r\n\r\nout vec2 vTexCoord;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = position;\r\n    vTexCoord = uv;\r\n}",m="#version 300 es\r\n\r\nprecision mediump float;\r\n\r\nuniform sampler2D sampler;\r\nuniform vec2 uvStride;\r\nuniform vec2[128] offsetAndScale; // x=offset, y=scale\r\nuniform int kernelWidth;\r\n\r\nin vec2 vTexCoord;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main()\r\n{\r\n\t//fragColor = vec4(vec3(vTexCoord.y),1.0);\r\n\t//fragColor += vec4(vec3(texture(sampler,vTexCoord).w),1.0);\r\n\tfor (int i = 0; i < kernelWidth; i++) {\r\n\r\n\t\tfragColor += texture(\r\n\t\t\tsampler,\r\n\t\t\tvTexCoord + offsetAndScale[i].x * uvStride\r\n\t\t    //   ^------------------------------------  UV coord for this fragment\r\n\t\t    //              ^-------------------------  Offset to sample (in texel space)\r\n\t\t    //                                  ^-----  Amount to move in UV space per texel (horizontal OR vertical only)\r\n\t\t    //   v------------------------------------  Scale down the sample\r\n\t\t) * offsetAndScale[i].y;\r\n\r\n\t\t//fragColor += vec4(vec3(0.01),1.0);\r\n\t}\r\n\t//float value = offsetAndScale[int(vTexCoord.x)].x;\r\n\t//fragColor = vec4(vec3(offsetAndScale[8].x/12.0),1.0);\r\n\t//fragColor = vec4(offsetAndScale[32].x,offsetAndScale[32].x,offsetAndScale[32].x,1.0);//texture(sampler,vTexCoord);\r\n}";const g=0,d=r=>{if(1&~r)throw new Error("Only odd guassian kernel sizes are accepted");if(r<9)throw new Error("Blur must be at least 9 pixels wide");const e=[],n=r/6,t=(r-1)/2;let o=0;for(let a=0;a<r;a++){const r=a-t,i=-r*r/(n*n*2),c=1/(n*Math.sqrt(2*Math.PI))*Math.exp(i);o+=c,e.push(c)}for(let n=0;n<r;n++)e[n]/=o;return e},p=r=>{if(!(1&r.length))throw new Error("Only odd kernel sizes can be lerped");const e=Math.ceil(r.length/2),n=[];let t=1-e,o=r[0];n.push(t,o);const a=r.reduce(((r,e)=>r+e));for(let i=1;i<r.length;i+=2){const c=r[i],s=r[i+1];t=1-e+i+s/(c+s),o=(c+s)/a,n.push(t,o)}return n};function h(e=!1){return function(n){return function(){const{gl:t,programMap:o,vaoMap:a}=r;if(o.has(n)||e)e?(o.set(n,r.program),a.set(n,new Map)):r.program=r.programMap.get(n);else{const e=t.createProgram();o.set(n,e),a.set(n,new Map),r.program=e}}}}function v(){const{gl:e,program:n}=r,t=e.createShader(e.VERTEX_SHADER);e.shaderSource(t,l),e.compileShader(t),e.getShaderParameter(t,e.COMPILE_STATUS)||console.error("ERROR compiling vertex shader!",e.getShaderInfoLog(t)),e.attachShader(n,t);const o=e.createShader(e.FRAGMENT_SHADER);e.shaderSource(o,m),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)||console.error("ERROR compiling fragment shader!",e.getShaderInfoLog(o)),e.attachShader(n,o)}function T(e){const{gl:n,program:t}=r,o=e===g?[1/r.frameBufferWidth,0]:[0,1/r.frameBufferHeight],a=n.getUniformLocation(t,"uvStride");n.uniform2fv(a,o)}function E(f,u,l,m,E=1024,U=128,w=1){const b=n([],f),D=l/m,L=E*D,B=E/D,O=t(new Float32Array(16),-l/2,l/2,-m/2,m/2,0,u),H=o(new Float32Array(16),b,[b[0],b[1]+1,b[2]],[0,0,1]);let W,X,I,y,k,Z;function z(){return X}function G(){return Z}const j={attributes:{positionsSize:2,positions:new Float32Array([-1,1,-1,-1,1,1,1,-1]),uvs:new Float32Array([0,1,0,0,1,1,1,0])},drawMode:e[5]};return{programs:[{createProgram:_(),setupProgram:[M,a,i,F(L,B,(function(r){k=r}),(function(r){Z=r}))],setupMaterial:[S(w)],useProgram:c,selectProgram:s,bindTextures:[],setupCamera:C(O,H),setFrameBuffer:A((function(){return k}),L,B),allMeshes:!0},{createProgram:h(),setupProgram:[v,a,i,F(L,B,(function(r){W=r}),(function(r){X=r}))],setupMaterial:[(N=U,function(){const e={size:N},n=function(r){const e=d(r);return p(e)}(e.size-1);return function(e){const{gl:n,program:t}=r,o=n.getUniformLocation(t,"offsetAndScale");n.uniform2fv(o,e);const a=n.getUniformLocation(t,"kernelWidth");n.uniform1i(a,e.length/2)}(n),e}),()=>T(g),()=>P(G)],useProgram:c,selectProgram:x(g,G),bindTextures:[],setupCamera:()=>{},setFrameBuffer:A((function(){return W}),L,B),meshes:[j],postDraw:R},{createProgram:h(!0),setupProgram:[F(L,B,(function(r){I=r}),(function(r){y=r}))],setupMaterial:[()=>T(1),()=>P(z)],useProgram:c,selectProgram:x(1,z),bindTextures:[],setupCamera:()=>{},setFrameBuffer:A((function(){return I}),L,B),meshes:[j],postDraw:R}],getTexture:function(){return y},order:-1};var N}function S(e){return function(){const{gl:n,program:t}=r,o=n.getUniformLocation(t,"darkness");n.uniform1f(o,e)}}function R(){const{gl:e}=r;e.bindTexture(e.TEXTURE_2D,null)}function x(r,e){return function(n){return function(){s(n)(),c(),P(e),T(r)}}}function P(e){const{gl:n}=r,t=e();n.bindTexture(n.TEXTURE_2D,t)}function A(e=null,n,t){return function(){const{gl:o}=r,a=e?e():null;o.bindFramebuffer(o.FRAMEBUFFER,a),r.fbo!==a&&null!=a&&(o.viewport(0,0,n,t),r.frameBufferWidth=n,r.frameBufferHeight=t,o.clearColor(0,0,0,0),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT)),r.fbo=a}}function C(e,n){return function(){const{gl:t,program:o}=r,a=t.getUniformLocation(o,"projection");t.uniformMatrix4fv(a,!1,e);const i=t.getUniformLocation(o,"view");t.uniformMatrix4fv(i,!1,n)}}function M(){const{gl:e,program:n}=r,t=e.createShader(e.VERTEX_SHADER);e.shaderSource(t,f),e.compileShader(t),e.getShaderParameter(t,e.COMPILE_STATUS)||console.error(e.getShaderInfoLog(t)),e.attachShader(n,t);const o=e.createShader(e.FRAGMENT_SHADER);e.shaderSource(o,u),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)||console.error(e.getShaderInfoLog(o)),e.attachShader(n,o)}function _(e,n){return function(e){return function(){const{gl:n,programMap:t,vaoMap:o}=r,a=n.createProgram();t.set(e,a),o.set(e,new Map),r.program=a}}}function F(e,n,t,o){return function(){const{gl:a}=r,i=a.createTexture();o(i),a.bindTexture(a.TEXTURE_2D,i),a.texStorage2D(a.TEXTURE_2D,1,a.RGBA8,e,n),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE);const c=a.createFramebuffer();t(c),a.bindFramebuffer(a.FRAMEBUFFER,c),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,i,0),a.bindTexture(a.TEXTURE_2D,null),a.bindFramebuffer(a.FRAMEBUFFER,null)}}export{E as c};
