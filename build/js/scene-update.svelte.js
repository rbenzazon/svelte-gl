import { S as SvelteComponent, i as init, s as safe_not_equal, a9 as append_styles, M as Menu, e as element, a as space, c as create_component, aa as attr, b as insert, m as mount_component, ab as listen, n as noop, t as transition_in, d as transition_out, f as detach, g as destroy_component, ac as run_all, h as component_subscribe, o as onMount, j as scene, k as materials, r as renderer, l as lights, p as camera, A as set_store_value, B as skyblue, C as createLightStore, D as createPointLight, y as identity, z as createZeroMatrix, H as createMaterialStore, E as create3DObject, F as createOrbitControls, P as get_store_value, w as scale, x as translate, G as binding_callbacks } from './Menu-Y5DXEdjv.js';
import { c as createCube } from './cube-BtOAchm2.js';
import { c as createPlane } from './plane-CMa45v2d.js';
import { c as createTexture } from './texture-B-Fl7bgc.js';
import { c as createSpecular } from './specular-BnBuJcJg.js';
import { D as DebugPanel } from './DebugPanel-BAahybW_.js';

/* src\scene-update.svelte generated by Svelte v4.2.18 */

function add_css(target) {
	append_styles(target, "svelte-8du7ma", "button.svelte-8du7ma{position:absolute;left:0}button.add.svelte-8du7ma{top:100px}button.remove.svelte-8du7ma{top:200px}");
}

function create_fragment(ctx) {
	let canvas_1;
	let t0;
	let menu;
	let t1;
	let debugpanel;
	let t2;
	let button0;
	let t4;
	let button1;
	let current;
	let mounted;
	let dispose;
	menu = new Menu({});
	debugpanel = new DebugPanel({});

	return {
		c() {
			canvas_1 = element("canvas");
			t0 = space();
			create_component(menu.$$.fragment);
			t1 = space();
			create_component(debugpanel.$$.fragment);
			t2 = space();
			button0 = element("button");
			button0.textContent = "add mesh";
			t4 = space();
			button1 = element("button");
			button1.textContent = "remove mesh";
			attr(button0, "class", "add svelte-8du7ma");
			attr(button1, "class", "remove svelte-8du7ma");
		},
		m(target, anchor) {
			insert(target, canvas_1, anchor);
			/*canvas_1_binding*/ ctx[3](canvas_1);
			insert(target, t0, anchor);
			mount_component(menu, target, anchor);
			insert(target, t1, anchor);
			mount_component(debugpanel, target, anchor);
			insert(target, t2, anchor);
			insert(target, button0, anchor);
			insert(target, t4, anchor);
			insert(target, button1, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*addMesh*/ ctx[1]),
					listen(button1, "click", /*removeMesh*/ ctx[2])
				];

				mounted = true;
			}
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(menu.$$.fragment, local);
			transition_in(debugpanel.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(menu.$$.fragment, local);
			transition_out(debugpanel.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(canvas_1);
				detach(t0);
				detach(t1);
				detach(t2);
				detach(button0);
				detach(t4);
				detach(button1);
			}

			/*canvas_1_binding*/ ctx[3](null);
			destroy_component(menu, detaching);
			destroy_component(debugpanel, detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $scene;
	let $materials;
	let $renderer;
	let $lights;
	let $camera;
	component_subscribe($$self, scene, $$value => $$invalidate(7, $scene = $$value));
	component_subscribe($$self, materials, $$value => $$invalidate(8, $materials = $$value));
	component_subscribe($$self, renderer, $$value => $$invalidate(9, $renderer = $$value));
	component_subscribe($$self, lights, $$value => $$invalidate(10, $lights = $$value));
	component_subscribe($$self, camera, $$value => $$invalidate(11, $camera = $$value));
	let canvas;
	let light;
	let light2;

	onMount(async () => {
		set_store_value(
			renderer,
			$renderer = {
				...$renderer,
				canvas,
				backgroundColor: skyblue,
				ambientLightColor: [0xffffff, 0.1]
			},
			$renderer
		);

		set_store_value(
			camera,
			$camera = {
				...$camera,
				position: [0, 5, -5],
				target: [0, 1, 0],
				fov: 75
			},
			$camera
		);

		light = createLightStore(createPointLight({
			position: [0, 1, 0],
			color: [1, 1, 1],
			intensity: 5,
			cutoffDistance: 15,
			decayExponent: 0.75
		}));

		light2 = createLightStore(createPointLight({
			position: [0, 1, 0],
			color: [1, 1, 1],
			intensity: 5,
			cutoffDistance: 10,
			decayExponent: 0
		}));

		const groundMesh = createPlane(10, 10, 1, 1);
		const groundMatrix = identity(createZeroMatrix());

		const diffuseMap = await createTexture({
			url: "peeling-painted-metal-diffuse.jpg",
			type: "diffuse"
		});

		const normalMap = await createTexture({
			url: "peeling-painted-metal-normal.jpg",
			type: "normal"
		});

		const roughnessMap = await createTexture({
			url: "peeling-painted-metal-roughness.jpg",
			type: "roughness"
		});

		const groundMaterial = createMaterialStore({
			diffuse: [1, 1, 1],
			metalness: 0,
			specular: createSpecular({
				roughness: 0.8,
				ior: 1.4,
				intensity: 0.5,
				color: [1, 1, 1]
			}),
			diffuseMap,
			normalMap,
			roughnessMap
		});

		set_store_value(materials, $materials = [...$materials, groundMaterial], $materials);

		set_store_value(
			scene,
			$scene = [
				...$scene,
				create3DObject({
					...groundMesh,
					matrix: groundMatrix,
					material: groundMaterial
				})
			],
			$scene
		);

		set_store_value(lights, $lights = [...$lights, light, light2], $lights);

		set_store_value(
			renderer,
			$renderer = {
				...$renderer,
				loop: animate,
				enabled: true
			},
			$renderer
		);

		createOrbitControls(canvas, camera);
	});

	function animate() {
		light.set({
			...get_store_value(light),
			position: [
				Math.sin(performance.now() / 1000) * 3,
				2,
				Math.cos(performance.now() / 1000) * 3
			]
		});

		//animate hue
		const color1 = Math.sin(performance.now() / 1000) * 0.5 + 0.5;

		const color2 = Math.sin(performance.now() / 1000 + 2) * 0.5 + 0.5;
		const color3 = Math.sin(performance.now() / 1000 + 4) * 0.5 + 0.5;

		light2.set({
			...get_store_value(light2),
			color: [color1, color2, color3]
		});
	}

	let meshCount = 1;

	function addMesh() {
		const newMat = identity(createZeroMatrix());
		scale(newMat, newMat, [0.2, 0.2, 0.2]);
		translate(newMat, newMat, [0, 4 * meshCount + 1, 0]);

		const mesh = create3DObject({
			...createCube(),
			matrix: newMat,
			material: $materials[0]
		});

		set_store_value(scene, $scene = [...$scene, mesh], $scene);
		meshCount++;
	}

	function removeMesh() {
		set_store_value(scene, $scene = $scene.slice(0, -1), $scene);
		meshCount--;
	}

	function canvas_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvas = $$value;
			$$invalidate(0, canvas);
		});
	}

	return [canvas, addMesh, removeMesh, canvas_1_binding];
}

class Scene_update extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);
	}
}

export { Scene_update as default };
