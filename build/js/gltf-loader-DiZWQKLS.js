import{A as r,F as e,G as t,H as n,I as o,J as a,K as i,L as s,M as c,l,N as u,O as f}from"./texture-B1gA2w_v.js";function m(){return{attributes:{positions:[-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,-1],normals:[0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,-1,0,0,-1,0,0,-1,0],elements:[0,1,2,0,2,3,5,4,6,6,4,7,8,9,10,8,10,11,13,12,14,15,14,12,16,17,18,16,18,19,21,20,22,22,20,23]},drawMode:r[4]}}function d(e=1,t=1,n=1,o=1,a=!1,i=!1){const s=[],c=[],l=[],u=[],f=e/2,m=t/2,d=e/n,p=t/o,g=n+1,h=o+1;for(let r=0;r<h;r++){const e=r*p-m;for(let t=0;t<g;t++){const a=t*d-f;s.push(a,0,-e),c.push(0,1,0),l.push(t/n,1-r/o)}}for(let r=0;r<o;r++)for(let e=0;e<n;e++){const t=e+g*r,n=e+g*(r+1),o=e+1+g*(r+1),i=e+1+g*r;a?(u.push(t,n,i),u.push(n,o,i)):(u.push(t,i,n),u.push(n,i,o))}return{attributes:{positions:new Float32Array(s),normals:new Float32Array(c),uvs:new Float32Array(l),elements:new Uint16Array(u),...i?{colors:new Float32Array(s.map(((r,e)=>1)))}:{}},drawMode:r[4]}}var p="#version 300 es\r\n\r\nprecision highp float;\r\n\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\nuniform mat4 world;\r\n\r\nin vec3 position;\r\n\r\nout vec2 vHighPrecisionZW;\r\n\r\nvoid main() {\r\n\tgl_Position = projection * view * world * vec4( position, 1.0 );\r\n\tvHighPrecisionZW = gl_Position.zw;\r\n}",g="#version 300 es\r\n\r\nout highp vec4 fragColor;\r\n\r\nprecision highp float;\r\nprecision highp int;\r\n\r\nuniform float darkness;\r\nin vec2 vHighPrecisionZW;\r\n\r\nvoid main() {\r\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\r\n\tfragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );\r\n\t//fragColor = vec4( vec3( fragCoordZ ), 1.0 );\r\n\t//debug fragColor = vec4( vec3(( 1.0  ) ) ,1.0);\r\n}\r\n\t\t\t\t\t",h="#version 300 es\r\n\r\nin vec4 position;\r\nin vec2 uv;\r\n\r\nout vec2 vTexCoord;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = position;\r\n    vTexCoord = uv;\r\n}",v="#version 300 es\r\n\r\nprecision mediump float;\r\n\r\nuniform sampler2D sampler;\r\nuniform vec2 uvStride;\r\nuniform vec2[128] offsetAndScale; // x=offset, y=scale\r\nuniform int kernelWidth;\r\n\r\nin vec2 vTexCoord;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main()\r\n{\r\n\t//fragColor = vec4(vec3(vTexCoord.y),1.0);\r\n\t//fragColor += vec4(vec3(texture(sampler,vTexCoord).w),1.0);\r\n\tfor (int i = 0; i < kernelWidth; i++) {\r\n\r\n\t\tfragColor += texture(\r\n\t\t\tsampler,\r\n\t\t\tvTexCoord + offsetAndScale[i].x * uvStride\r\n\t\t    //   ^------------------------------------  UV coord for this fragment\r\n\t\t    //              ^-------------------------  Offset to sample (in texel space)\r\n\t\t    //                                  ^-----  Amount to move in UV space per texel (horizontal OR vertical only)\r\n\t\t    //   v------------------------------------  Scale down the sample\r\n\t\t) * offsetAndScale[i].y;\r\n\r\n\t\t//fragColor += vec4(vec3(0.01),1.0);\r\n\t}\r\n\t//float value = offsetAndScale[int(vTexCoord.x)].x;\r\n\t//fragColor = vec4(vec3(offsetAndScale[8].x/12.0),1.0);\r\n\t//fragColor = vec4(offsetAndScale[32].x,offsetAndScale[32].x,offsetAndScale[32].x,1.0);//texture(sampler,vTexCoord);\r\n}";const T=0,E=r=>{if(1&~r)throw new Error("Only odd guassian kernel sizes are accepted");if(r<9)throw new Error("Blur must be at least 9 pixels wide");const e=[],t=r/6,n=(r-1)/2;let o=0;for(let a=0;a<r;a++){const r=a-n,i=-r*r/(t*t*2),s=1/(t*Math.sqrt(2*Math.PI))*Math.exp(i);o+=s,e.push(s)}for(let t=0;t<r;t++)e[t]/=o;return e},S=r=>{if(!(1&r.length))throw new Error("Only odd kernel sizes can be lerped");const e=Math.ceil(r.length/2),t=[];let n=1-e,o=r[0];t.push(n,o);const a=r.reduce(((r,e)=>r+e));for(let i=1;i<r.length;i+=2){const s=r[i],c=r[i+1];n=1-e+i+c/(s+c),o=(s+c)/a,t.push(n,o)}return t};function w(r=!1){return function(t){return function(){const{gl:n,programMap:o,vaoMap:a}=e;if(o.has(t)||r)r?(o.set(t,e.program),a.set(t,new Map)):e.program=e.programMap.get(t);else{const r=n.createProgram();o.set(t,r),a.set(t,new Map),e.program=r}}}}function A(){const{gl:r,program:t}=e,n=r.createShader(r.VERTEX_SHADER);r.shaderSource(n,h),r.compileShader(n),r.getShaderParameter(n,r.COMPILE_STATUS)||console.error("ERROR compiling vertex shader!",r.getShaderInfoLog(n)),r.attachShader(t,n);const o=r.createShader(r.FRAGMENT_SHADER);r.shaderSource(o,v),r.compileShader(o),r.getShaderParameter(o,r.COMPILE_STATUS)||console.error("ERROR compiling fragment shader!",r.getShaderInfoLog(o)),r.attachShader(t,o)}function x(r){const{gl:t,program:n}=e,o=r===T?[1/e.frameBufferWidth,0]:[0,1/e.frameBufferHeight],a=t.getUniformLocation(n,"uvStride");t.uniform2fv(a,o)}function y(l,u,f,m,d=1024,p=128,g=1){const h=t([],l),v=f/m,y=d*v,L=d/v,B=n(new Float32Array(16),-f/2,f/2,-m/2,m/2,0,u),D=o(new Float32Array(16),h,[h[0],h[1]+1,h[2]],[0,0,1]);let I,H,X,W,V,k;function z(){return H}function G(){return k}const Z={attributes:{positionsSize:2,positions:new Float32Array([-1,1,-1,-1,1,1,1,-1]),uvs:new Float32Array([0,1,0,0,1,1,1,0])},drawMode:r[5]};return{programs:[{createProgram:U(),setupProgram:[_,a,i,O(y,L,(function(r){V=r}),(function(r){k=r}))],setupMaterial:[b(g)],useProgram:s,selectProgram:c,bindTextures:[],setupCamera:C(B,D),setFrameBuffer:P((function(){return V}),y,L),allMeshes:!0},{createProgram:w(),setupProgram:[A,a,i,O(y,L,(function(r){I=r}),(function(r){H=r}))],setupMaterial:[(N=p,function(){const r={size:N},t=function(r){const e=E(r);return S(e)}(r.size-1);return function(r){const{gl:t,program:n}=e,o=t.getUniformLocation(n,"offsetAndScale");t.uniform2fv(o,r);const a=t.getUniformLocation(n,"kernelWidth");t.uniform1i(a,r.length/2)}(t),r}),()=>x(T),()=>R(G)],useProgram:s,selectProgram:F(T,G),bindTextures:[],setupCamera:()=>{},setFrameBuffer:P((function(){return I}),y,L),meshes:[Z],postDraw:M},{createProgram:w(!0),setupProgram:[O(y,L,(function(r){X=r}),(function(r){W=r}))],setupMaterial:[()=>x(1),()=>R(z)],useProgram:s,selectProgram:F(1,z),bindTextures:[],setupCamera:()=>{},setFrameBuffer:P((function(){return X}),y,L),meshes:[Z],postDraw:M}],getTexture:function(){return W},order:-1};var N}function b(r){return function(){const{gl:t,program:n}=e,o=t.getUniformLocation(n,"darkness");t.uniform1f(o,r)}}function M(){const{gl:r}=e;r.bindTexture(r.TEXTURE_2D,null)}function F(r,e){return function(t){return function(){c(t)(),s(),R(e),x(r)}}}function R(r){const{gl:t}=e,n=r();t.bindTexture(t.TEXTURE_2D,n)}function P(r=null,t,n){return function(){const{gl:o}=e,a=r?r():null;o.bindFramebuffer(o.FRAMEBUFFER,a),e.fbo!==a&&null!=a&&(o.viewport(0,0,t,n),e.frameBufferWidth=t,e.frameBufferHeight=n,o.clearColor(0,0,0,0),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT)),e.fbo=a}}function C(r,t){return function(){const{gl:n,program:o}=e,a=n.getUniformLocation(o,"projection");n.uniformMatrix4fv(a,!1,r);const i=n.getUniformLocation(o,"view");n.uniformMatrix4fv(i,!1,t)}}function _(){const{gl:r,program:t}=e,n=r.createShader(r.VERTEX_SHADER);r.shaderSource(n,p),r.compileShader(n),r.getShaderParameter(n,r.COMPILE_STATUS)||console.error(r.getShaderInfoLog(n)),r.attachShader(t,n);const o=r.createShader(r.FRAGMENT_SHADER);r.shaderSource(o,g),r.compileShader(o),r.getShaderParameter(o,r.COMPILE_STATUS)||console.error(r.getShaderInfoLog(o)),r.attachShader(t,o)}function U(r,t){return function(r){return function(){const{gl:t,programMap:n,vaoMap:o}=e,a=t.createProgram();n.set(r,a),o.set(r,new Map),e.program=a}}}function O(r,t,n,o){return function(){const{gl:a}=e,i=a.createTexture();o(i),a.bindTexture(a.TEXTURE_2D,i),a.texStorage2D(a.TEXTURE_2D,1,a.RGBA8,r,t),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE);const s=a.createFramebuffer();n(s),a.bindFramebuffer(a.FRAMEBUFFER,s),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,i,0),a.bindTexture(a.TEXTURE_2D,null),a.bindFramebuffer(a.FRAMEBUFFER,null)}}const L={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},B={MAT2:4,MAT3:9,MAT4:16,SCALAR:1,VEC2:2,VEC3:3,VEC4:4};async function D(e,t=void 0){try{let n=new Map;t&&n.set(t,I(t));const o=await fetch(e);if(!o.ok)throw new Error(`Failed to fetch GLB file: ${o.statusText}`);const a=await o.json();return await async function(e,t,n){const o=t.substring(0,t.lastIndexOf("/")+1),{buffers:a,bufferViews:i,accessors:s,scenes:c,nodes:u,meshes:f,cameras:m,materials:d,scene:p}=e,g=await Promise.all(a.map((async r=>{const{uri:e}=r,t=o+e;return n.has(t)?n.get(t):I(t)}))),h=await Promise.all(i.map((async r=>{const{buffer:e,byteOffset:t,byteLength:n,byteStride:o}=r;return{dataView:g[e].slice(t,t+n),byteStride:o}}))),v={};function T(r,e){return v[r]&&v[r][e]}function E(r,e,t){v[e]=v[e]||{},v[e][t]=r}function S(r,e){return v[r]&&null!=v[r][e]}const w=s.map((r=>{const{bufferView:e,byteOffset:t}=r,{dataView:n,byteStride:o}=h[e],{type:a,componentType:i,count:s,min:c,max:l}=r,u=B[a],f=L[i],m=f.BYTES_PER_ELEMENT;let d,p,g,v=!1;if(null!=o&&o!==m*u){d=Math.floor(t/o)*o,p=s*o/m,v=!0}else d=t,p=s*u;return v&&S(n,d)?g=T(n,d):(g=new f(n,d,p),v&&E(g,n,d)),{type:a,componentType:i,count:s,min:c,max:l,data:g,interleaved:v,...v?{byteOffset:t,byteStride:o}:{}}})),A=f.map((r=>F(r)));let x=u.map((r=>null!=r.mesh?{...A[r.mesh],matrix:V(r)}:null!=r.camera?R(r):null!=r.children?r:void 0));x=x.map((r=>null!=r.children?C(r):r));const y=c[p];let{nodes:b}=y,M=b.map((r=>x[r]));M.forEach((r=>{P(r)}));return{scene:M,materials:d,lights:{},cameras:m};function F(e){const{primitives:t}=e;return t.map((e=>{const{attributes:t,indices:n}=e,{POSITION:o,NORMAL:a,TEXCOORD_0:i}=t,s=w[o],c=w[a],l=w[i];return{position:s,normal:c,indices:w[n],uv:l,material:e.material,drawMode:r[e.mode]}}))[0]}function R(r){return null!=r.matrix||null==r.scale&&null==r.translation&&null==r.rotation?null==r.matrix&&(r.matrix=l(new Float32Array(16))):r.matrix=V(r),{...r,...m[r.camera]}}function P(r,e=null){const{children:t}=r;if(null!=e&&(r.parent=e),null!=t)return t.map((e=>{P(e,r)}))}function C(r){const{children:e,matrix:t,scale:n,translation:o,rotation:a}=r;let i;return i=null!=t||null==n&&null==o&&null==a?null!=t?t:l(new Float32Array(16)):V(r),{children:e.map((r=>null!=x[r].children?C(x[r]):x[r])),matrix:i}}}(a,e,n)}catch(r){console.error("Error loading GLTF file:",r)}}async function I(r){let e;if(r){if(e=await fetch(r),!e.ok)throw new Error(`Failed to fetch GLTF Binary file: ${e.statusText}`);return await e.arrayBuffer()}}function H(r,e){const t=e,n=r.materials[t.material],o={};if(n.pbrMetallicRoughness){const{baseColorFactor:r,metallicFactor:e,roughnessFactor:t}=n.pbrMetallicRoughness;o.diffuse=r.slice(0,3),o.metalness=0}return{attributes:{positions:t.position.interleaved?{data:t.position.data,interleaved:t.position.interleaved,byteOffset:t.position.byteOffset,byteStride:t.position.byteStride}:t.position.data,normals:t.normal.interleaved?{data:t.normal.data,interleaved:t.normal.interleaved,byteOffset:t.normal.byteOffset,byteStride:t.normal.byteStride}:t.normal.data,elements:t.indices.data},drawMode:t.drawMode,material:o,matrix:t.matrix}}function X(r){const{perspective:e,translation:t}=r;return{position:t,target:[0,0,0],fov:e.yfov/Math.PI*180,near:e.znear,far:e.zfar,up:[0,1,0]}}function W(r){const e=[];let t=r;for(;null!=t.parent;)e.unshift(t.matrix),t=t.parent;return e.reduce(((r,e)=>u(r,r,e)),l(new Float32Array(16)))}function V(r){const{translation:e,rotation:t,scale:n}=r,o=l(new Float32Array(16));return f(o,t||[0,0,0,0],e||[0,0,0],n||[1,1,1]),o}function k(r,e){r.forEach((r=>{e(r),null!=r.children&&k(r.children,e)}))}export{H as a,y as b,X as c,m as d,d as e,W as g,D as l,k as t};
