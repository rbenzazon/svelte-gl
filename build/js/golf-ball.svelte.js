import{P as r,F as t,S as n,i as a,s as o,e,a as i,n as s,d as l,c,o as f,r as u,b as m,f as p,w as d,m as g,p as h,q as v,Q as D,l as w,u as y,v as V,x as N,y as _,z as P}from"./texture-B1gA2w_v.js";const b=n=>({...n,shader:r("${declaration?\r\n`\r\n\r\nuniform float roughness;\r\nuniform float ior;\r\nuniform float specularIntensity;\r\nuniform vec3 specularColor;\r\n\r\n\r\n\r\n#define EPSILON 1e-6\r\n\r\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\r\n\r\n\t// Original approximation by Christophe Schlick '94\r\n\t// float fresnel = pow( 1.0 - dotVH, 5.0 );\r\n\r\n\t// Optimized variant (presented by Epic at SIGGRAPH '13)\r\n\t// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\r\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\r\n\r\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\r\n\r\n} \r\n\r\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\r\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\r\n\r\n\tfloat a2 = pow2( alpha );\r\n\r\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\r\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\r\n\r\n\treturn 0.5 / max( gv + gl, EPSILON );\r\n\r\n}\r\n\r\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\r\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\r\n// alpha is \"roughness squared\" in Disneyâ€™s reparameterization\r\nfloat D_GGX( const in float alpha, const in float dotNH ) {\r\n\r\n\tfloat a2 = pow2( alpha );\r\n\r\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\r\n\r\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\r\n\r\n}\r\n\r\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float specularF90, const in float roughness) {\r\n\r\n\tfloat alpha = pow2( roughness ); // UE4's roughness\r\n\r\n\tvec3 halfDir = normalize( lightDir + viewDir );\r\n\r\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\r\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\r\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\r\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\r\n\r\n\tvec3 F = F_Schlick( specularColor, specularF90, dotVH );\r\n\r\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\r\n\r\n\tfloat D = D_GGX( alpha, dotNH );\r\n\r\n\treturn F * ( V * D );\r\n\r\n}\r\n` : ''\r\n}\r\n${irradiance?\r\n`\r\n\tmaterial.roughness = clamp(roughness, 0.0525, 1.0);\r\n\tmaterial.ior = ior;\r\n\tmaterial.specularF90 = mix(specularIntensity, 1.0, metalness);\r\n\tmaterial.specularColor = mix(min(pow2((material.ior - 1.0) / (material.ior + 1.0)) * specularColor, vec3(1.0)) * specularIntensity, diffuse.rgb, metalness);\r\n\r\n        vec3 geometryViewDir = normalize( cameraPosition - vertex );\r\n        reflectedLight.directSpecular += lightParams.irradiance * BRDF_GGX( lightParams.direction, geometryViewDir, normal, material.specularColor, material.specularF90, material.roughness);//lightParams.irradiance; //* \r\n        //totalIrradiance = -vec3(geometryViewDir.z,geometryViewDir.z,geometryViewDir.z);//BRDF_GGX( lightParams.direction, geometryViewDir, normalize(vNormal), specularColor, specularF90, roughness);\r\n\t\t//totalIrradiance = lightParams.irradiance;//vec3(-lightParams.direction.z,-lightParams.direction.z,-lightParams.direction.z);\r\n` : ''\r\n}",{declaration:!1,irradiance:!1}),setupSpecular:()=>function({roughness:r,ior:n,intensity:a,color:o}){return function(){const{gl:e,program:i}=t,s=e.getUniformLocation(i,"specularColor"),l=e.getUniformLocation(i,"roughness"),c=e.getUniformLocation(i,"ior"),f=e.getUniformLocation(i,"specularIntensity");e.uniform3fv(s,o),e.uniform1f(l,r),e.uniform1f(c,n),e.uniform1f(f,a)}}(n)});function G(r){let t;return{c(){t=e("canvas")},m(n,a){i(n,t,a),r[1](t)},p:s,i:s,o:s,d(n){n&&l(t),r[1](null)}}}function C(){performance.now()}function F(r,t,n){let a,o,e,i;return c(r,u,(r=>n(2,a=r))),c(r,m,(r=>n(3,o=r))),c(r,p,(r=>n(4,e=r))),f((async()=>{const r=await d({url:"golfball-normal.jpg",normalScale:[1,1],type:"normal"});g(u,a={...a,canvas:i,backgroundColor:h,ambientLightColor:[16777215,.1]},a),g(p,e={position:[0,5,-5],target:[0,0,0],fov:75},e);const t=v(1.5,7,P);t.attributes.uvs=D(t.attributes);let n=new Array(16).fill(0);w(n);const s=y(V({position:[-2,3,-3],color:[1,1,1],intensity:20,cutoffDistance:0,decayExponent:2})),l=y(V({position:[2,-1,-1],color:[1,1,1],intensity:20,cutoffDistance:0,decayExponent:2}));g(m,o=[...o,{...t,matrix:n,material:{diffuse:[1,.5,.5],metalness:0,specular:b({roughness:.12,ior:1,intensity:2,color:[1,1,1]}),normalMap:r}},s,l],o),g(u,a={...a,loop:C,enabled:!0},a),N(i,p)})),[i,function(r){_[r?"unshift":"push"]((()=>{i=r,n(0,i)}))}]}class L extends n{constructor(r){super(),a(this,r,F,G,o,{})}}export{L as default};
