import{aw as r,ax as e,r as n,a7 as t,X as o,Y as a,Z as i,_ as s,R as c,L as E,ay as u,az as _,z as T,$ as p,K as g,J as P,U as m,I as d}from"./Menu-BeccOEjd.js";var f="#version 300 es\r\n\r\n#define SHADER_NAME skyboxVertex\r\n\r\nin vec4 position;\r\nout vec4 v_position;\r\nvoid main() {\r\n    v_position = position;\r\n    gl_Position = position;\r\n    gl_Position.z = 1.0;\r\n}",A="#version 300 es\r\nprecision highp float;\r\n\r\n#define SHADER_NAME skyboxFragment\r\n\r\nuniform samplerCube skybox;\r\nuniform mat4 viewDirectionProjectionInverse;\r\n\r\n${declarations}\r\n  \r\nin vec4 v_position;\r\n  \r\n// we need to declare an output for the fragment shader\r\nout vec4 fragColor;\r\n  \r\nvoid main() {\r\n  vec4 t = viewDirectionProjectionInverse * v_position;\r\n  fragColor = texture(skybox, normalize(t.xyz / t.w));\r\n  ${toneMappings}\r\n}";async function U(t){let u,_;function T(r){u=r}function p(){return u}const g={createProgram:r,setupProgram:[o,a],setupMaterial:[],bindTextures:[h(p)],setupCamera:R,useProgram:i,selectProgram:s,updateProgram:[I((function(r){_=r}))],meshes:[{attributes:{positionsSize:2,positions:new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1])},drawMode:E[4]}],postDraw:C((function(){return _}))};let P,m,d;return!function(r){return"url"in r&&"string"==typeof r.url}(t)?function(r){return"typedArray"in r&&r.typedArray instanceof Uint16Array}(t)&&(m=t.typedArray,g.createProgram=function(e){return function(n){return function(){null!=e&&e(),r(n)()}}}(function(r,t,o,a,i,s){return function(){const{gl:E}=c,u=o(r,E,a,i,s);t(u),e(),n.update((r=>r))}}(m,T,t.convertToCube,t.width,t.height,t.cubeSize)),d=t.toneMapping,g.setupProgram=[l(d),...g.setupProgram],g.setupMaterial=[h(p)],P={}):(g.setupMaterial=[await t.convertToCube(t.url,T)],g.setupProgram=[l(),...g.setupProgram],P={url:t.url}),{...P,order:1,programs:[g]}}function l(r){return function(){const{gl:e,program:n}=c,o=e.createShader(e.VERTEX_SHADER);e.shaderSource(o,f),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)||console.error(e.getShaderInfoLog(o)),e.attachShader(n,o);const a=e.createShader(e.FRAGMENT_SHADER);let i="",s="";null!=r&&(i=r.shader({declaration:!0,exposure:r.exposure}),s=r.shader({color:!0}));const E=t(A,{declarations:"",toneMappings:""})({declarations:i,toneMappings:s});e.shaderSource(a,E),e.compileShader(a),e.getShaderParameter(a,e.COMPILE_STATUS)||console.error(e.getShaderInfoLog(a)),e.attachShader(n,a)}}function R(r){return function(){const{gl:e,program:n,canvas:t}=c,{projection:o}=u(r,t.width,t.height),a=(i=r.position,s=r.target,E=r.up,f=T(),A=g(m(),P(m(),i,s)),U=g(m(),d(m(),E,A)),l=g(m(),d(m(),A,U)),f[0]=U[0],f[1]=U[1],f[2]=U[2],f[3]=0,f[4]=l[0],f[5]=l[1],f[6]=l[2],f[7]=0,f[8]=A[0],f[9]=A[1],f[10]=A[2],f[11]=0,f[12]=i[0],f[13]=i[1],f[14]=i[2],f[15]=1,f);var i,s,E,f,A,U,l;const R=_(T(),a);R[12]=0,R[13]=0,R[14]=0;const M=p(T(),o,R),h=_(T(),M),I=e.getUniformLocation(n,"viewDirectionProjectionInverse");e.uniformMatrix4fv(I,!1,h)}}async function M(r,e){const t=new Image;return await new Promise(((e,n)=>{t.src=r,t.onload=function(){e(t)},t.onerror=n})),function(){const{gl:t}=c,o=t.createTexture();e(o),t.bindTexture(t.TEXTURE_CUBE_MAP,o);const a=new Image;a.src=r,t.bindTexture(t.TEXTURE_CUBE_MAP,o),function(r,e){const n=document.createElement("canvas"),t=n.getContext("2d"),o=r.width/4,a=r.height/3;n.width=o,n.height=a;const i=[[2,1,e.TEXTURE_CUBE_MAP_POSITIVE_X],[0,1,e.TEXTURE_CUBE_MAP_NEGATIVE_X],[1,0,e.TEXTURE_CUBE_MAP_POSITIVE_Y],[1,2,e.TEXTURE_CUBE_MAP_NEGATIVE_Y],[1,1,e.TEXTURE_CUBE_MAP_POSITIVE_Z],[3,1,e.TEXTURE_CUBE_MAP_NEGATIVE_Z]];i.forEach((([i,s,c])=>{t.clearRect(0,0,o,a),t.drawImage(r,i*o,s*a,o,a,0,0,o,a),e.texImage2D(c,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n)}))}(a,t),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MIN_FILTER,t.LINEAR_MIPMAP_LINEAR),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_R,t.CLAMP_TO_EDGE),t.generateMipmap(t.TEXTURE_CUBE_MAP),n.update((r=>r))}}function h(r){return function(){const{gl:e,program:n}=c,t=e.getUniformLocation(n,"skybox");e.uniform1i(t,0),e.activeTexture(e.TEXTURE0),e.bindTexture(e.TEXTURE_CUBE_MAP,r())}}function I(r){return function(){const{gl:e}=c;r(e.getParameter(e.DEPTH_FUNC)),e.depthFunc(e.LEQUAL)}}function C(r){return function(){const{gl:e}=c;e.depthFunc(r())}}export{U as c,M as s};
