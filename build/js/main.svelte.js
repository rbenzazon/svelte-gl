import { S as SvelteComponent, i as init, s as safe_not_equal, e as element, a as insert, n as noop, d as detach, c as component_subscribe, o as onMount, r as renderer, b as scene, f as camera, g as renderPasses, t as transformMat4, h as rotateZ, j as scale, k as translate, l as identity, m as set_store_value, p as skyblue, q as createPolyhedron, u as createLightStore, v as createPointLight, w as createTexture, x as createOrbitControls, y as binding_callbacks, z as createSmoothShadedNormals } from './texture-C302gKqD.js';
import { l as loadGLTFFile, t as traverseScene, g as getAbsoluteNodeMatrix, c as createCameraFromGLTF, a as createMeshFromGLTF, b as createContactShadowPass, d as createCube, e as createPlane } from './gltf-loader-DG6nzK4C.js';

/* src\main-refactor.svelte generated by Svelte v4.2.18 */

function create_fragment(ctx) {
	let canvas_1;

	return {
		c() {
			canvas_1 = element("canvas");
		},
		m(target, anchor) {
			insert(target, canvas_1, anchor);
			/*canvas_1_binding*/ ctx[1](canvas_1);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(canvas_1);
			}

			/*canvas_1_binding*/ ctx[1](null);
		}
	};
}

function animate() {
	performance.now() / 1000;
} /*$camera = {
	position: [0, 5, -zpos],
};*/ //console.log("animate", $camera.position);

function instance($$self, $$props, $$invalidate) {
	let $renderer;
	let $scene;
	let $camera;
	let $renderPasses;
	component_subscribe($$self, renderer, $$value => $$invalidate(2, $renderer = $$value));
	component_subscribe($$self, scene, $$value => $$invalidate(3, $scene = $$value));
	component_subscribe($$self, camera, $$value => $$invalidate(4, $camera = $$value));
	component_subscribe($$self, renderPasses, $$value => $$invalidate(5, $renderPasses = $$value));
	let canvas;

	onMount(async () => {
		const file = await loadGLTFFile("models/v2/md-blend6-mdlvw.gltf", "models/v2/md-blend6-mdlvw.bin");
		let meshObject;
		let cameraGLTF;

		traverseScene(file.scene, o => {
			if (o.position != null) {
				meshObject = o;
			} else if (o.camera != null) {
				cameraGLTF = o;
			}
		});

		const cameraAbsoluteMatrix = getAbsoluteNodeMatrix(cameraGLTF);
		const cameraFromFile = createCameraFromGLTF(cameraGLTF);
		transformMat4(cameraFromFile.position, cameraFromFile.position, cameraAbsoluteMatrix);
		const meshAbsoluteMatrix = getAbsoluteNodeMatrix(meshObject);
		rotateZ(meshAbsoluteMatrix, meshAbsoluteMatrix, Math.PI);
		scale(meshAbsoluteMatrix, meshAbsoluteMatrix, [200, 200, 200]);
		translate(meshAbsoluteMatrix, meshAbsoluteMatrix, [0, 0, -500]);
		meshObject.matrix = meshAbsoluteMatrix;
		const loadedMesh = createMeshFromGLTF(file, meshObject);
		loadedMesh.matrix = meshAbsoluteMatrix;
		const groundMatrix = identity(new Float32Array(16));
		translate(groundMatrix, groundMatrix, [0, -1.5, 0]);

		set_store_value(
			renderer,
			$renderer = {
				...$renderer,
				canvas,
				backgroundColor: skyblue,
				ambientLightColor: [0xffffff, 0.1]
			},
			$renderer
		);

		const shadowPass = createContactShadowPass(groundMatrix, 1, 10, 10, 1024, 128, 0.5);
		const { getTexture: shadowTexture } = shadowPass;
		set_store_value(renderPasses, $renderPasses = [shadowPass], $renderPasses);

		set_store_value(
			camera,
			$camera = {
				position: [0, 5, -5],
				target: [0, 2, 0],
				fov: 75
			}, //...cameraFromFile
			$camera
		);

		createCube();
		const sphereMesh = createPolyhedron(1, 5, createSmoothShadedNormals);

		const light = createLightStore(createPointLight({
			position: [-2, 3, -3],
			color: [1, 1, 1],
			intensity: 20,
			cutoffDistance: 0,
			decayExponent: 2
		}));

		const light2 = createLightStore(createPointLight({
			position: [2, -1, -1],
			color: [1, 1, 1],
			intensity: 20,
			cutoffDistance: 0,
			decayExponent: 2
		}));

		const secondCubePos = identity(new Float32Array(16));
		translate(secondCubePos, secondCubePos, [3, 0, 0]);
		scale(secondCubePos, secondCubePos, [0.1, 0.1, 0.1]);
		const groundMesh = createPlane(10, 10, 1, 1);

		const groundDiffuseMap = await createTexture({
			textureBuffer: shadowTexture,
			type: "diffuse"
		});

		await createTexture({
			url: "transparent-texture.png",
			type: "diffuse"
		});

		const groundMaterial = {
			diffuse: [1, 1, 1],
			metalness: 0,
			diffuseMap: groundDiffuseMap,
			transparent: true
		};

		const transparentMaterial = {
			diffuse: [1, 1, 0.5],
			metalness: 0,
			opacity: 0.5
		};

		set_store_value(
			scene,
			$scene = [
				...$scene,
				loadedMesh,
				{
					...sphereMesh,
					matrix: secondCubePos,
					material: transparentMaterial
				},
				/*{
	...cubeMesh,
	matrix: secondCubePos,
	material: sameMaterial,
},*/
				{
					...groundMesh,
					matrix: groundMatrix,
					material: groundMaterial
				},
				light,
				light2
			],
			$scene
		);

		set_store_value(
			renderer,
			$renderer = {
				...$renderer,
				loop: animate,
				enabled: true
			},
			$renderer
		);

		createOrbitControls(canvas, camera);
	}); /*setTimeout(() => {
	$camera = {
		position: [0, 5, -4],
	};
}, 1000);*/

	function canvas_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvas = $$value;
			$$invalidate(0, canvas);
		});
	}

	return [canvas, canvas_1_binding];
}

class Main_refactor extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export { Main_refactor as default };
