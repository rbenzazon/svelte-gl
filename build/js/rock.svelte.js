import { S as SvelteComponent, i as init, s as safe_not_equal, M as Menu, e as element, a as space, c as create_component, b as insert, m as mount_component, n as noop, t as transition_in, d as transition_out, f as detach, g as destroy_component, h as component_subscribe, o as onMount, r as renderer, l as lights, j as scene, k as materials, p as camera, z as set_store_value, A as skyblue, B as createLightStore, C as createPointLight, G as createMaterialStore, y as identity, x as translate, D as create3DObject, E as createOrbitControls, F as binding_callbacks } from './Menu-BNuEDtNx.js';
import { l as loadGLTFFile, t as traverseScene, a as createMeshFromGLTF } from './gltf-loader-BIokrWW_.js';
import { D as DebugPanel } from './DebugPanel-DNCvKKbg.js';
import { c as createTexture } from './texture-CQ2z1OC_.js';

/* src\rock.svelte generated by Svelte v4.2.18 */

function create_fragment(ctx) {
	let canvas_1;
	let t0;
	let menu;
	let t1;
	let debugpanel;
	let current;
	menu = new Menu({});
	debugpanel = new DebugPanel({});

	return {
		c() {
			canvas_1 = element("canvas");
			t0 = space();
			create_component(menu.$$.fragment);
			t1 = space();
			create_component(debugpanel.$$.fragment);
		},
		m(target, anchor) {
			insert(target, canvas_1, anchor);
			/*canvas_1_binding*/ ctx[1](canvas_1);
			insert(target, t0, anchor);
			mount_component(menu, target, anchor);
			insert(target, t1, anchor);
			mount_component(debugpanel, target, anchor);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(menu.$$.fragment, local);
			transition_in(debugpanel.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(menu.$$.fragment, local);
			transition_out(debugpanel.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(canvas_1);
				detach(t0);
				detach(t1);
			}

			/*canvas_1_binding*/ ctx[1](null);
			destroy_component(menu, detaching);
			destroy_component(debugpanel, detaching);
		}
	};
}

function animate() {
	
} // animate here

function instance($$self, $$props, $$invalidate) {
	let $renderer;
	let $lights;
	let $scene;
	let $materials;
	let $camera;
	component_subscribe($$self, renderer, $$value => $$invalidate(2, $renderer = $$value));
	component_subscribe($$self, lights, $$value => $$invalidate(3, $lights = $$value));
	component_subscribe($$self, scene, $$value => $$invalidate(4, $scene = $$value));
	component_subscribe($$self, materials, $$value => $$invalidate(5, $materials = $$value));
	component_subscribe($$self, camera, $$value => $$invalidate(6, $camera = $$value));
	let canvas;

	onMount(async () => {
		const file = await loadGLTFFile("models/rock.gltf", "models/rock.bin");
		let meshObject;

		traverseScene(file.scene, o => {
			if (o.position != null) {
				meshObject = o;
			} else if (o.camera != null) ;
		});

		/*const cameraAbsoluteMatrix = getAbsoluteNodeMatrix(cameraGLTF);
const cameraFromFile = createCameraFromGLTF(cameraGLTF);
transformMat4(cameraFromFile.position, cameraFromFile.position, cameraAbsoluteMatrix);
const meshAbsoluteMatrix = getAbsoluteNodeMatrix(meshObject);

rotateZ(meshAbsoluteMatrix, meshAbsoluteMatrix, Math.PI);
scale(meshAbsoluteMatrix, meshAbsoluteMatrix, [200, 200, 200]);
translate(meshAbsoluteMatrix, meshAbsoluteMatrix, [0, 0, -500]);

meshObject.matrix = identity(new Float32Array(16));*/
		const loadedMesh = createMeshFromGLTF(file, meshObject);

		//loadedMesh.matrix = identity(new Float32Array(16));;
		set_store_value(
			renderer,
			$renderer = {
				...$renderer,
				canvas,
				backgroundColor: skyblue,
				ambientLightColor: [0xffffff, 0.1]
			},
			$renderer
		);

		set_store_value(
			camera,
			$camera = {
				position: [0, 3, -3],
				target: [0, 0, 0],
				fov: 75
			},
			$camera
		);

		const light = createLightStore(createPointLight({
			position: [-6, 7, -3],
			color: [0.996078431372549, 0.9529411764705882, 0.6627450980392157],
			intensity: 7.5,
			cutoffDistance: 0,
			decayExponent: 1
		}));

		const light2 = createLightStore(createPointLight({
			color: [0.6313725490196078, 0.6235294117647059, 0.996078431372549],
			intensity: 3,
			position: [3, -3, -1],
			cutoffDistance: 7.5,
			decayExponent: 0.25
		}));

		const diffuseMap = await createTexture({ url: "rock-diffuse.jpg", type: "diffuse" });
		const normalMap = await createTexture({ url: "rock-normal.png", type: "normal" });

		const meshMaterial = createMaterialStore({
			...loadedMesh.material,
			diffuse: [0.67, 0.68, 0.81],
			diffuseMap,
			normalMap
		});

		loadedMesh.material = meshMaterial;
		set_store_value(materials, $materials = [...$materials, meshMaterial], $materials);
		const numInstances = 5;
		const identityMatrix = new Array(16).fill(0);
		identity(identityMatrix);

		let matrices = new Array(numInstances).fill(0).map((_, index) => {
			/*const count = index - Math.floor(numInstances / 2);*/
			let mat = [...loadedMesh.matrix];

			//transform the model matrix
			translate(mat, mat, [0, index * 2, 0]);

			return new Float32Array(mat);
		});

		loadedMesh.instances = numInstances;
		delete loadedMesh.matrix;
		loadedMesh.matrices = matrices;
		set_store_value(scene, $scene = [...$scene, create3DObject(loadedMesh)], $scene);
		set_store_value(lights, $lights = [...$lights, light, light2], $lights);

		set_store_value(
			renderer,
			$renderer = {
				...$renderer,
				loop: animate,
				enabled: true
			},
			$renderer
		);

		createOrbitControls(canvas, camera);
	});

	function canvas_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			canvas = $$value;
			$$invalidate(0, canvas);
		});
	}

	return [canvas, canvas_1_binding];
}

class Rock extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export { Rock as default };
