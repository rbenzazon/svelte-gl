import{af as r,J as e}from"./Menu-BvT8Tzhv.js";const n={diffuse:"diffuseMap",normal:"normalMap",roughness:"roughnessMap"},t={diffuse:0,normal:1,roughness:2},a=async e=>{let a;var c;let l;e.url?a=await(c=e.url,new Promise(((r,e)=>{const n=new Image;n.onload=()=>{r(n)},n.onerror=e,n.src=c}))):"function"==typeof e.textureBuffer&&(a=e.textureBuffer);let s={type:n[e.type],coordinateSpace:e.coordinateSpace,shader:r("${declaration?\r\n`\r\nuniform sampler2D ${mapType};\r\n` : ''\r\n}\r\n${declarationNormal?\r\n`\r\nuniform vec2 normalScale;\r\nmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\r\n    vec3 q0 = dFdx( eye_pos.xyz );\r\n    vec3 q1 = dFdy( eye_pos.xyz );\r\n    vec2 st0 = dFdx( uv.st );\r\n    vec2 st1 = dFdy( uv.st );\r\n    vec3 N = surf_norm;\r\n    vec3 q1perp = cross( q1, N );\r\n    vec3 q0perp = cross( N, q0 );\r\n    vec3 T = q1perp * st0.x + q0perp * st1.x;\r\n    vec3 B = q1perp * st0.y + q0perp * st1.y;\r\n    float det = max( dot( T, T ), dot( B, B ) );\r\n    float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\r\n    return mat3( T * scale, B * scale, N );\r\n}\r\n` : ''\r\n}\r\n${diffuseMapSample?\r\n`\r\n    //atan(uv.y, uv.x)\r\n    ${coordinateSpace === 'circular' ?\r\n`   vec2 uv = vec2(vUv.x/vUv.y, vUv.y);\r\n` :\r\n`   vec2 uv = vUv;\r\n`}\r\n    vec4 textureColor = texture( ${mapType}, uv );\r\n    material.diffuseColor *= textureColor.rgb;\r\n    material.diffuseAlpha = textureColor.a;\r\n    \r\n` : ''\r\n}\r\n${normalMapSample?\r\n`\r\n    mat3 tbn =  getTangentFrame( -vViewPosition, vNormal, vUv );\r\n    normal = texture( normalMap, vUv ).xyz * 2.0 - 1.0;\r\n    normal.xy *= normalScale;\r\n    normal = normalize(tbn * normal);\r\n\t//normal = normalize( normalMatrix * normal );\r\n` : ''\r\n}\r\n${roughnessMapSample?\r\n`\r\n    //atan(uv.y, uv.x)\r\n    ${coordinateSpace === 'circular' ?\r\n`   vec2 roughnessUv = vec2(vUv.x/vUv.y, vUv.y);\r\n` :\r\n`   vec2 roughnessUv = vUv;\r\n`}\r\n    vec4 texelRoughness = texture( ${mapType}, roughnessUv );\r\n    roughnessFactor = texelRoughness.g;\r\n` : ''\r\n}\r\n",{declaration:!1,declarationNormal:!1,diffuseMapSample:!1,normalMapSample:!1,roughnessMapSample:!1,mapType:void 0,coordinateSpace:void 0}),setupTexture:u(a,n[e.type],t[e.type],e.normalScale,(function(r){l=r})),bindTexture:o(t[e.type],(function(){return l}),n[e.type]),...e.url?{url:e.url}:{}};return s="function"==typeof a?{...s,get textureBuffer(){return a()}}:{...s,texture:a},s};function o(r,n,t){return function(){const{gl:a,program:o}=e,u=a.getUniformLocation(o,t);a.activeTexture(a["TEXTURE"+r]),a.bindTexture(a.TEXTURE_2D,n()),a.uniform1i(u,r)}}function u(r,n,t,a=[1,1],o){return function(){const{gl:u,program:c}=e;let l;l="function"==typeof r?r():u.createTexture(),o(l);const s=u.getUniformLocation(c,n);if(u.activeTexture(u["TEXTURE"+t]),u.bindTexture(u.TEXTURE_2D,l),u.uniform1i(s,t),"function"!=typeof r&&u.texImage2D(u.TEXTURE_2D,0,u.RGBA,u.RGBA,u.UNSIGNED_BYTE,r),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_MIN_FILTER,u.LINEAR_MIPMAP_LINEAR),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_S,u.CLAMP_TO_EDGE),u.texParameteri(u.TEXTURE_2D,u.TEXTURE_WRAP_T,u.CLAMP_TO_EDGE),u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL,!0),u.generateMipmap(u.TEXTURE_2D),null!=a){const r=u.getUniformLocation(c,"normalScale");u.uniform2fv(r,a)}}}export{a as c};
