import{Y as r,L as e,Z as n,_ as t,$ as o,z as a,R as i,T as c,U as s,V as f}from"./Menu-C4XSDfXF.js";var u="#version 300 es\r\n\r\nprecision highp float;\r\n\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\nuniform mat4 world;\r\n\r\nin vec3 position;\r\n\r\nout vec2 vHighPrecisionZW;\r\n\r\nvoid main() {\r\n\tgl_Position = projection * view * world * vec4( position, 1.0 );\r\n\tvHighPrecisionZW = gl_Position.zw;\r\n}",l="#version 300 es\r\n\r\nout highp vec4 fragColor;\r\n\r\nprecision highp float;\r\nprecision highp int;\r\n\r\nuniform float darkness;\r\nin vec2 vHighPrecisionZW;\r\n\r\nvoid main() {\r\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\r\n\tfragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );\r\n\t//fragColor = vec4( vec3( fragCoordZ ), 1.0 );\r\n\t//debug fragColor = vec4( vec3(( 1.0  ) ) ,1.0);\r\n}\r\n\t\t\t\t\t",m="#version 300 es\r\n\r\nin vec4 position;\r\nin vec2 uv;\r\n\r\nout vec2 vTexCoord;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = position;\r\n    vTexCoord = uv;\r\n}",g="#version 300 es\r\n\r\nprecision mediump float;\r\n\r\nuniform sampler2D sampler;\r\nuniform vec2 uvStride;\r\nuniform vec2[128] offsetAndScale; // x=offset, y=scale\r\nuniform int kernelWidth;\r\n\r\nin vec2 vTexCoord;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main()\r\n{\r\n\t//fragColor = vec4(vec3(vTexCoord.y),1.0);\r\n\t//fragColor += vec4(vec3(texture(sampler,vTexCoord).w),1.0);\r\n\tfor (int i = 0; i < kernelWidth; i++) {\r\n\r\n\t\tfragColor += texture(\r\n\t\t\tsampler,\r\n\t\t\tvTexCoord + offsetAndScale[i].x * uvStride\r\n\t\t    //   ^------------------------------------  UV coord for this fragment\r\n\t\t    //              ^-------------------------  Offset to sample (in texel space)\r\n\t\t    //                                  ^-----  Amount to move in UV space per texel (horizontal OR vertical only)\r\n\t\t    //   v------------------------------------  Scale down the sample\r\n\t\t) * offsetAndScale[i].y;\r\n\r\n\t\t//fragColor += vec4(vec3(0.01),1.0);\r\n\t}\r\n\t//float value = offsetAndScale[int(vTexCoord.x)].x;\r\n\t//fragColor = vec4(vec3(offsetAndScale[8].x/12.0),1.0);\r\n\t//fragColor = vec4(offsetAndScale[32].x,offsetAndScale[32].x,offsetAndScale[32].x,1.0);//texture(sampler,vTexCoord);\r\n}";const d=0,p=r=>{if(1&~r)throw new Error("Only odd guassian kernel sizes are accepted");if(r<9)throw new Error("Blur must be at least 9 pixels wide");const e=[],n=r/6,t=(r-1)/2;let o=0;for(let a=0;a<r;a++){const r=a-t,i=-r*r/(n*n*2),c=1/(n*Math.sqrt(2*Math.PI))*Math.exp(i);o+=c,e.push(c)}for(let n=0;n<r;n++)e[n]/=o;return e},h=r=>{if(!(1&r.length))throw new Error("Only odd kernel sizes can be lerped");const e=Math.ceil(r.length/2),n=[];let t=1-e,o=r[0];n.push(t,o);const a=r.reduce(((r,e)=>r+e));for(let i=1;i<r.length;i+=2){const c=r[i],s=r[i+1];t=1-e+i+s/(c+s),o=(c+s)/a,n.push(t,o)}return n};function v(e=!1){return function(n){return function(){const{gl:t,programMap:o,vaoMap:a}=r;if(o.has(n)||e)e?(o.set(n,r.program),a.set(n,new Map)):r.program=r.programMap.get(n);else{const e=t.createProgram();o.set(n,e),a.set(n,new Map),r.program=e}}}}function T(){const{gl:e,program:n}=r,t=e.createShader(e.VERTEX_SHADER);e.shaderSource(t,m),e.compileShader(t),e.getShaderParameter(t,e.COMPILE_STATUS)||console.error("ERROR compiling vertex shader!",e.getShaderInfoLog(t)),e.attachShader(n,t);const o=e.createShader(e.FRAGMENT_SHADER);e.shaderSource(o,g),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)||console.error("ERROR compiling fragment shader!",e.getShaderInfoLog(o)),e.attachShader(n,o)}function E(e){const{gl:n,program:t}=r,o=e===d?[1/r.frameBufferWidth,0]:[0,1/r.frameBufferHeight],a=n.getUniformLocation(t,"uvStride");n.uniform2fv(a,o)}function S(u,l,m,g,S=1024,F=128,w=1){const D=n([],u),L=m/g,b=S*L,B=S/L,O=t(a(),-m/2,m/2,-g/2,g/2,0,l),H=o(a(),D,[D[0],D[1]+1,D[2]],[0,0,1]);let W,X,I,Z,k,y;function z(){return X}function G(){return y}const V={attributes:{positionsSize:2,positions:new Float32Array([-1,1,-1,-1,1,1,1,-1]),uvs:new Float32Array([0,1,0,0,1,1,1,0])},drawMode:e[5]};return{programs:[{createProgram:function(e){return function(){const{gl:n,programMap:t,vaoMap:o}=r,a=n.createProgram();t.set(e,a),o.set(e,new Map),r.program=a}},setupProgram:[_,i,c,U(b,B,(function(r){k=r}),(function(r){y=r}))],setupMaterial:[R(w)],useProgram:s,selectProgram:f,setupCamera:M(O,H),setFrameBuffer:A((function(){return k}),b,B),allMeshes:!0},{createProgram:v(),setupProgram:[T,i,c,U(b,B,(function(r){W=r}),(function(r){X=r}))],setupMaterial:[(j=F,function(){const e={size:j},n=function(r){const e=p(r);return h(e)}(e.size-1);return function(e){const{gl:n,program:t}=r,o=n.getUniformLocation(t,"offsetAndScale");n.uniform2fv(o,e);const a=n.getUniformLocation(t,"kernelWidth");n.uniform1i(a,e.length/2)}(n),e}),()=>E(d),()=>C(G)],useProgram:s,selectProgram:x(d,G),setupCamera:()=>{},setFrameBuffer:A((function(){return W}),b,B),meshes:[V],postDraw:P},{createProgram:v(!0),setupProgram:[U(b,B,(function(r){I=r}),(function(r){Z=r}))],setupMaterial:[()=>E(1),()=>C(z)],useProgram:s,selectProgram:x(1,z),setupCamera:()=>{},setFrameBuffer:A((function(){return I}),b,B),meshes:[V],postDraw:P}],getTexture:function(){return Z},order:-1};var j}function R(e){return function(){const{gl:n,program:t}=r,o=n.getUniformLocation(t,"darkness");n.uniform1f(o,e)}}function P(){const{gl:e}=r;e.bindTexture(e.TEXTURE_2D,null)}function x(r,e){return function(n){return function(){f(n)(),s(),C(e),E(r)}}}function C(e){const{gl:n}=r,t=e();n.bindTexture(n.TEXTURE_2D,t)}function A(e=null,n,t){return function(){const{gl:o}=r,a=e?e():null;o.bindFramebuffer(o.FRAMEBUFFER,a),r.fbo!==a&&null!=a&&(o.viewport(0,0,n,t),r.frameBufferWidth=n,r.frameBufferHeight=t,o.clearColor(0,0,0,0),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_BUFFER_BIT)),r.fbo=a}}function M(e,n){return function(){const{gl:t,program:o}=r,a=t.getUniformLocation(o,"projection");t.uniformMatrix4fv(a,!1,e);const i=t.getUniformLocation(o,"view");t.uniformMatrix4fv(i,!1,n)}}function _(){const{gl:e,program:n}=r,t=e.createShader(e.VERTEX_SHADER);e.shaderSource(t,u),e.compileShader(t),e.getShaderParameter(t,e.COMPILE_STATUS)||console.error(e.getShaderInfoLog(t)),e.attachShader(n,t);const o=e.createShader(e.FRAGMENT_SHADER);e.shaderSource(o,l),e.compileShader(o),e.getShaderParameter(o,e.COMPILE_STATUS)||console.error(e.getShaderInfoLog(o)),e.attachShader(n,o)}function U(e,n,t,o){return function(){const{gl:a}=r,i=a.createTexture();o(i),a.bindTexture(a.TEXTURE_2D,i),a.texStorage2D(a.TEXTURE_2D,1,a.RGBA8,e,n),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE);const c=a.createFramebuffer();t(c),a.bindFramebuffer(a.FRAMEBUFFER,c),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,i,0),a.bindTexture(a.TEXTURE_2D,null),a.bindFramebuffer(a.FRAMEBUFFER,null)}}export{S as c};
