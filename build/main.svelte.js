function t(){}function n(t){return t()}function e(){return Object.create(null)}function r(t){t.forEach(n)}function o(t){return"function"==typeof t}function a(t,n){return t!=t?n==n:t!==n||t&&"object"==typeof t||"function"==typeof t}function i(n,...e){if(null==n){for(const t of e)t(void 0);return t}const r=n.subscribe(...e);return r.unsubscribe?()=>r.unsubscribe():r}function s(t){let n;return i(t,(t=>n=t))(),n}function c(t,n,e){t.$$.on_destroy.push(i(n,e))}function u(t,n,e){return t.set(e),n}function l(t){t.parentNode&&t.parentNode.removeChild(t)}let f;function d(t){f=t}function p(t){(function(){if(!f)throw new Error("Function called outside component initialization");return f})().$$.on_mount.push(t)}const m=[],g=[];let h=[];const v=[],b=Promise.resolve();let A=!1;function M(t){h.push(t)}const L=new Set;let y=0;function R(){if(0!==y)return;const t=f;do{try{for(;y<m.length;){const t=m[y];y++,d(t),x(t.$$)}}catch(t){throw m.length=0,y=0,t}for(d(null),m.length=0,y=0;g.length;)g.pop()();for(let t=0;t<h.length;t+=1){const n=h[t];L.has(n)||(L.add(n),n())}h.length=0}while(m.length);for(;v.length;)v.pop()();A=!1,L.clear(),d(t)}function x(t){if(null!==t.fragment){t.update(),r(t.before_update);const n=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,n),t.after_update.forEach(M)}}const E=new Set;function _(t,n){const e=t.$$;null!==e.fragment&&(!function(t){const n=[],e=[];h.forEach((r=>-1===t.indexOf(r)?n.push(r):e.push(r))),e.forEach((t=>t())),h=n}(e.after_update),r(e.on_destroy),e.fragment&&e.fragment.d(n),e.on_destroy=e.fragment=null,e.ctx=[])}function P(t,n){-1===t.$$.dirty[0]&&(m.push(t),A||(A=!0,b.then(R)),t.$$.dirty.fill(0)),t.$$.dirty[n/31|0]|=1<<n%31}function w(a,i,s,c,u,p,m=null,g=[-1]){const h=f;d(a);const v=a.$$={fragment:null,ctx:[],props:p,update:t,not_equal:u,bound:e(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(i.context||(h?h.$$.context:[])),callbacks:e(),dirty:g,skip_bound:!1,root:i.target||h.$$.root};m&&m(v.root);let b=!1;if(v.ctx=s?s(a,i.props||{},((t,n,...e)=>{const r=e.length?e[0]:n;return v.ctx&&u(v.ctx[t],v.ctx[t]=r)&&(!v.skip_bound&&v.bound[t]&&v.bound[t](r),b&&P(a,t)),n})):[],v.update(),b=!0,r(v.before_update),v.fragment=!!c&&c(v.ctx),i.target){if(i.hydrate){const t=function(t){return Array.from(t.childNodes)}(i.target);v.fragment&&v.fragment.l(t),t.forEach(l)}else v.fragment&&v.fragment.c();i.intro&&((A=a.$$.fragment)&&A.i&&(E.delete(A),A.i(L))),function(t,e,a){const{fragment:i,after_update:s}=t.$$;i&&i.m(e,a),M((()=>{const e=t.$$.on_mount.map(n).filter(o);t.$$.on_destroy?t.$$.on_destroy.push(...e):r(e),t.$$.on_mount=[]})),s.forEach(M)}(a,i.target,i.anchor),R()}var A,L;d(h)}class F{$$=void 0;$$set=void 0;$destroy(){_(this,1),this.$destroy=t}$on(n,e){if(!o(e))return t;const r=this.$$.callbacks[n]||(this.$$.callbacks[n]=[]);return r.push(e),()=>{const t=r.indexOf(e);-1!==t&&r.splice(t,1)}}$set(t){var n;this.$$set&&(n=t,0!==Object.keys(n).length)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}"undefined"!=typeof window&&(window.__svelte||(window.__svelte={v:new Set})).v.add("4");const S=[];function $(n,e=t){let r;const o=new Set;function i(t){if(a(n,t)&&(n=t,r)){const t=!S.length;for(const t of o)t[1](),S.push(t,n);if(t){for(let t=0;t<S.length;t+=2)S[t][0](S[t+1]);S.length=0}}}function s(t){i(t(n))}return{set:i,update:s,subscribe:function(a,c=t){const u=[a,c];return o.add(u),1===o.size&&(r=e(i,s)||t),a(n),()=>{o.delete(u),0===o.size&&r&&(r(),r=null)}}}}function T(n,e,a){const s=!Array.isArray(n),c=s?[n]:n;if(!c.every(Boolean))throw new Error("derived() expects stores as input, got a falsy value");const u=e.length<2;return l=(n,a)=>{let l=!1;const f=[];let d=0,p=t;const m=()=>{if(d)return;p();const r=e(s?f[0]:f,n,a);u?n(r):p=o(r)?r:t},g=c.map(((t,n)=>i(t,(t=>{f[n]=t,d&=~(1<<n),l&&m()}),(()=>{d|=1<<n}))));return l=!0,m(),function(){r(g),p(),l=!1}},{subscribe:$(a,l).subscribe};var l}var B=1e-6,C="undefined"!=typeof Float32Array?Float32Array:Array;function D(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}Math.hypot||(Math.hypot=function(){for(var t=0,n=arguments.length;n--;)t+=arguments[n]*arguments[n];return Math.sqrt(t)});var I=function(t,n,e,r,o){var a,i=1/Math.tan(n/2);return t[0]=i/e,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=i,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,null!=o&&o!==1/0?(a=1/(r-o),t[10]=(o+r)*a,t[14]=2*o*r*a):(t[10]=-1,t[14]=-2*r),t};const U=(t,n)=>{const e=Function.constructor(...Object.entries(n).map((([t,n])=>(""===n&&(n='""'),`${t}${null!=n?`=${n}`:""}`))),`return \`${t}\``);return t=>e(...Object.keys(n).map((n=>null!=t[n]?t[n]:void 0)))};function O(t){return Array.isArray(t)?[...t]:"number"==typeof t?N(t):"string"==typeof t&&t.startsWith("#")?N(parseInt(t.replace("#","0x"))):t}function N(t){return[(t>>16&255)/255,(t>>8&255)/255,(255&t)/255]}function Y(t,n){return 3===n?t:t<.04045?.0773993808*t:Math.pow(.9478672986*t+.0521327014,2.4)}const k=0,V=Math.PI/180;function j(t){return function(){const n=s(t),e=n.gl,r=n.program,o=e.getUniformLocation(r,"time");e.uniform1f(o,performance.now())}}function W(t){return function(){const n=s(t),{gl:e}=n;e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT)}}function z(t,n,e){return function(){const r=s(t),{gl:o,attributeLength:a,hasElements:i}=r;n?o.drawArraysInstanced(o[e],0,a,n):i?o.drawElements(o[e],a,o.UNSIGNED_SHORT,0):o.drawArrays(o[e],0,a),o.bindVertexArray(null)}}function q(t,n){return function(){const n=s(t),e=n.gl;n.vao,e.bindVertexArray(n.vao)}}function G(t,n){return function(){const e=s(t),r=e.gl.createProgram();e.programMap.set(n,r),t.update((t=>({...e,program:r})))}}function H(t){return function(){const n=s(t),e=n.gl,r=n.program;e.linkProgram(r),e.getProgramParameter(r,e.LINK_STATUS)||console.error("ERROR linking program!",e.getProgramInfoLog(r))}}function X(t){return function(){const n=s(t),e=n.gl,r=n.program;e.validateProgram(r),e.getProgramParameter(r,e.VALIDATE_STATUS)||console.error("ERROR validating program!",e.getProgramInfoLog(r))}}function K(t){return function(){const n=s(t),e=n.gl,r=n.program;e.useProgram(r)}}function J(t,{diffuse:n,metalness:e}){return function(){const r=s(t),o=r.gl,a=r.program,i=o.getUniformLocation(a,"diffuse");o.uniform3fv(i,new Float32Array(n.map(Y)));const c=o.getUniformLocation(a,"metalness");o.uniform1f(c,e)}}function Q(t,n){return function(){const e=s(t),{gl:r,program:o}=e,a=r.getUniformLocation(o,"ambientLightColor");r.uniform3fv(a,new Float32Array(n))}}function Z(t,n){return function(){const e=s(t),r=e.gl,o=e.program,a=r.getUniformLocation(o,"projection"),i=n.fov*V;const c=e.canvas.width/e.canvas.height,u=n.near,l=n.far;let f=new Float32Array(16);f=I(f,i,c,u,l),r.uniformMatrix4fv(a,!1,f);const d=r.getUniformLocation(o,"view"),p=new Float32Array(16);var m,g,h,v,b,A,M,L,y,R,x,E,_,P,w,F,S,$,T,C,U,O,N;m=p,g=n.position,h=n.target,v=n.up,w=g[0],F=g[1],S=g[2],$=v[0],T=v[1],C=v[2],U=h[0],O=h[1],N=h[2],Math.abs(w-U)<B&&Math.abs(F-O)<B&&Math.abs(S-N)<B?D(m):(x=w-U,E=F-O,_=S-N,b=T*(_*=P=1/Math.hypot(x,E,_))-C*(E*=P),A=C*(x*=P)-$*_,M=$*E-T*x,(P=Math.hypot(b,A,M))?(b*=P=1/P,A*=P,M*=P):(b=0,A=0,M=0),L=E*M-_*A,y=_*b-x*M,R=x*A-E*b,(P=Math.hypot(L,y,R))?(L*=P=1/P,y*=P,R*=P):(L=0,y=0,R=0),m[0]=b,m[1]=L,m[2]=x,m[3]=0,m[4]=A,m[5]=y,m[6]=E,m[7]=0,m[8]=M,m[9]=R,m[10]=_,m[11]=0,m[12]=-(b*w+A*F+M*S),m[13]=-(L*w+y*F+R*S),m[14]=-(x*w+E*F+_*S),m[15]=1),r.uniformMatrix4fv(d,!1,p);const Y=r.getUniformLocation(o,"cameraPosition");r.uniform3fv(Y,n.position)}}function tt(t,n,e){return null==e?function(){const e=s(t),r=e.gl,o=e.program;n||D(n=new Float32Array(16)),t.update((t=>({...t,transformMatrix:n})));const a=r.getUniformLocation(o,"world");r.uniformMatrix4fv(a,!1,n)}:function(){const r=s(t),{gl:o,program:a,vao:i}=r;let c;c=(r.transformMatricesWindows=null)?[]:r.transformMatricesWindows;const u=n.reduce(((t,n)=>[...t,...s(n)]),[]),l=new Float32Array(u);for(let t=0;t<e;++t){const n=16*t*4,e=16;c.push(new Float32Array(l.buffer,n,e))}o.bindVertexArray(i);const f=o.createBuffer();t.update((t=>({...t,matrixBuffer:f,transformMatricesWindows:c})));const d=o.getAttribLocation(a,"world");o.bindBuffer(o.ARRAY_BUFFER,f),o.bufferData(o.ARRAY_BUFFER,l.byteLength,o.DYNAMIC_DRAW);for(let t=0;t<4;++t){const n=d+t;o.enableVertexAttribArray(n);const e=16*t;o.vertexAttribPointer(n,4,o.FLOAT,!1,64,e),o.vertexAttribDivisor(n,1)}o.bufferSubData(o.ARRAY_BUFFER,0,l),o.bindVertexArray(null)}}function nt(t,n){return null==n?function(){const{gl:n,program:e,transformMatrix:r}=s(t),o=n.getUniformLocation(e,"normalMatrix");n.uniformMatrix4fv(o,!1,et(r))}:function(){const e=s(t),{gl:r,program:o,transformMatrix:a,vao:i,transformMatricesWindows:c}=e;r.bindVertexArray(i);const u=r.getAttribLocation(o,"normalMatrix"),l=[];for(let t=0;t<n;t++)l.push(...et(c[t]));const f=new Float32Array(l),d=r.createBuffer();t.update((t=>({...t,normalMatrixBuffer:d}))),r.bindBuffer(r.ARRAY_BUFFER,d),r.bufferData(r.ARRAY_BUFFER,f.byteLength,r.DYNAMIC_DRAW),r.bufferSubData(r.ARRAY_BUFFER,0,f);for(let t=0;t<4;++t){const n=u+t;r.enableVertexAttribArray(n);const e=16*t;r.vertexAttribPointer(n,4,r.FLOAT,!1,64,e),r.vertexAttribDivisor(n,1)}r.bindVertexArray(null)}}function et(t){const n=(e=new C(16),C!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e);var e;return function(t,n){var e=n[0],r=n[1],o=n[2],a=n[3],i=n[4],s=n[5],c=n[6],u=n[7],l=n[8],f=n[9],d=n[10],p=n[11],m=n[12],g=n[13],h=n[14],v=n[15],b=e*s-r*i,A=e*c-o*i,M=e*u-a*i,L=r*c-o*s,y=r*u-a*s,R=o*u-a*c,x=l*g-f*m,E=l*h-d*m,_=l*v-p*m,P=f*h-d*g,w=f*v-p*g,F=d*v-p*h,S=b*F-A*w+M*P+L*_-y*E+R*x;S&&(S=1/S,t[0]=(s*F-c*w+u*P)*S,t[1]=(o*w-r*F-a*P)*S,t[2]=(g*R-h*y+v*L)*S,t[3]=(d*y-f*R-p*L)*S,t[4]=(c*_-i*F-u*E)*S,t[5]=(e*F-o*_+a*E)*S,t[6]=(h*M-m*R-v*A)*S,t[7]=(l*R-d*M+p*A)*S,t[8]=(i*w-s*_+u*x)*S,t[9]=(r*_-e*w-a*x)*S,t[10]=(m*y-g*M+v*b)*S,t[11]=(f*M-l*y-p*b)*S,t[12]=(s*E-i*P-c*x)*S,t[13]=(e*P-r*E+o*x)*S,t[14]=(g*A-m*L-h*b)*S,t[15]=(l*L-f*A+d*b)*S)}(n,t),function(t,n){if(t===n){var e=n[1],r=n[2],o=n[3],a=n[6],i=n[7],s=n[11];t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=e,t[6]=n[9],t[7]=n[13],t[8]=r,t[9]=a,t[11]=n[14],t[12]=o,t[13]=i,t[14]=s}else t[0]=n[0],t[1]=n[4],t[2]=n[8],t[3]=n[12],t[4]=n[1],t[5]=n[5],t[6]=n[9],t[7]=n[13],t[8]=n[2],t[9]=n[6],t[10]=n[10],t[11]=n[14],t[12]=n[3],t[13]=n[7],t[14]=n[11],t[15]=n[15]}(n,n),n}function rt(t){let n,e;t.data?(n=t.data,e=t.interleaved):n=t;return{data:n.buffer&&n.buffer instanceof ArrayBuffer?n:new Float32Array(n),interleaved:e,...e?{byteStride:t.byteStride,byteOffset:t.byteOffset}:{}}}function ot(t,n){return function(){const e=s(t),r=e.gl,o=e.program,a={...e};a.attributeLength=n.attributes.elements?n.attributes.elements.length:n.attributes.positions.length/3;const{positions:i,normals:c,elements:u,uvs:l}=n.attributes;let f;e.vao?f=e.vao:(f=r.createVertexArray(),a.vao=f),a.meshMap.set(n,f),r.bindVertexArray(f);const{data:d,interleaved:p,byteStride:m,byteOffset:g}=rt(i),h=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,h),r.bufferData(r.ARRAY_BUFFER,d,r.STATIC_DRAW);const v=r.getAttribLocation(o,"position");r.bindBuffer(r.ARRAY_BUFFER,h),r.vertexAttribPointer(v,3,r.FLOAT,!1,m,g),r.enableVertexAttribArray(v);const{data:b,interleaved:A,byteStride:M,byteOffset:L}=rt(c);if(!A){const t=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,t),r.bufferData(r.ARRAY_BUFFER,b,r.STATIC_DRAW),r.bindBuffer(r.ARRAY_BUFFER,t)}const y=r.getAttribLocation(o,"normal");if(r.vertexAttribPointer(y,3,r.FLOAT,!1,M,L),r.enableVertexAttribArray(y),n.attributes.elements){a.hasElements=!0;const t=new Uint16Array(n.attributes.elements),e=r.createBuffer();r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e),r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW)}if(n.attributes.uvs){const t=new Float32Array(n.attributes.uvs),e=r.createBuffer();r.bindBuffer(r.ARRAY_BUFFER,e),r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW);const a=r.getAttribLocation(o,"uv");r.bindBuffer(r.ARRAY_BUFFER,e),r.vertexAttribPointer(a,2,r.FLOAT,!1,0,0),r.enableVertexAttribArray(a)}r.bindVertexArray(null),t.set(a)}}function at(t,n){if(null==t||null==n||t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function it(t){return(t=s(t)).shader instanceof Function&&t.setupLights instanceof Function&&t.updateOneLight instanceof Function}const st=function(){const t=$({position:[0,0,-1],target:[0,0,0],fov:80,near:.1,far:1e3,up:[0,1,0],matrix:null}),{subscribe:n,update:e}=t,r=$(0);function o(t){e((n=>{const e={...n,...t(n)};return r.update((t=>t+1)),e}))}return{subscribe:n,set:function(t){o((n=>t))},update:o,get revision(){return s(r)}}}(),ct=function(){const t={canvas:null,loop:null,backgroundColor:16777215,ambientLightColor:[16777215,0],toneMappings:[],enabled:!1};let n=t,e=new Map;const r=$(t),{subscribe:o,update:a}=r,i=$(0);function c(t){a((r=>{const o=t(r);var a;return i.update((t=>t+1)),null!=n.canvas&&o.canvas!==n.canvas&&o.canvas,null!=n.loop&&o.loop!==n.loop&&o.loop,o.backgroundColor!==n.backgroundColor&&(a=o.backgroundColor,e.set("backgroundColor",[...O(a),1])),at(o.ambientLightColor,n.ambientLightColor)||function([t,n]){e.set("ambientLightColor",O(t).map((t=>t*n)))}(o.ambientLightColor),at(o.toneMappings,n.toneMappings)||o.toneMappings,o.enabled!==n.enabled&&o.enabled,n=o,o}))}return{subscribe:o,set:function(t){c((n=>t))},update:c,get processed(){const t=s(r);return Object.entries(t).map((([t,n])=>e.has(t)?[t,e.get(t)]:[t,n])).reduce(((t,[n,e])=>(t[n]=e,t)),{})},get revision(){return s(i)}}}();const ut=function(){const t=$([]),n=$(0),{subscribe:e,update:r}=t;function o(t){r((e=>{const r=t(e);return n.update((t=>t+1)),r}))}return{subscribe:e,set:function(t){o((n=>t))},update:o,get revision(){return s(n)}}}();let lt;const ft=T([ut],(([t])=>{const n=t.filter((t=>null!=t.attributes));if(at(lt,n))throw new Error("meshes unchanged");return lt=n,n}));let dt;const pt=T([ft],(([t])=>{const n=new Set;if(t.forEach((t=>{n.add(t.material)})),function(t,n){if(null==t||null==n||t.size!==n.size)return!1;for(let e of t)if(!n.has(e))return!1;return!0}(dt,n))throw new Error("materials unchanged");return dt=n,n})),mt=T([ft,pt],(([t,n])=>{let e=Array.from(n);const r=new Set(t.filter((t=>t.instances>1||t.animations?.some((t=>"vertex"===t.type)))));return e=e.reduce(((n,e)=>{const o=t.filter((t=>t.material===e)),{currentNormalMeshes:a,currentSpecialMeshes:i}=o.reduce(((t,n)=>(r.has(n)?t.currentSpecialMeshes.push(n):t.currentNormalMeshes.push(n),t)),{currentNormalMeshes:[],currentSpecialMeshes:[]});return a.length>0&&n.push({material:e,meshes:a}),i.forEach((t=>{const r=t.animations?.some((t=>t.requireTime));n.push({requireTime:r,material:e,meshes:[t]})})),n}),[]),e.map((t=>({...t,createProgram:G,createShaders:function(t,n,e){return function(){const r=s(t),o=r.gl,a=r.program;let i="",c="",u="",l="";const[f]=e,d=f.animations?.filter((({type:t})=>"vertex"===t));d?.length>0&&(u+=d.reduce(((t,n)=>t+n.shader({declaration:!0})),""),l+=d.reduce(((t,n)=>t+n.shader({position:!0})),""),i+=u,c+=l);const p=U("#version 300 es\r\nprecision mediump float;\r\n    \r\nin vec3 position;\r\nin vec3 normal;\r\nin vec2 uv;\r\n${instances ?\r\n`\r\nin mat4 world;\r\nin mat4 normalMatrix;\r\n` : `\r\nuniform mat4 world;\r\nuniform mat4 normalMatrix;\r\n`}\r\n\r\n\r\nuniform float time;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\n\r\n// Pass the color attribute down to the fragment shader\r\nout vec3 vertexColor;\r\nout vec3 vNormal;\r\nout vec3 vertex;\r\nout vec3 vViewPosition;\r\nout highp vec2 vUv;\r\n\r\n${declarations}\r\n\r\nvoid main() {\r\n    vec3 modifiedNormal = normal;\r\n    vec3 animatedPosition = position;\r\n    ${positionModifier}\r\n\r\n    vUv = vec3( uv, 1 ).xy;\r\n    // Pass the color down to the fragment shader\r\n    vertexColor = vec3(1.27,1.27,1.27);\r\n    // Pass the vertex down to the fragment shader\r\n    //vertex = vec3(world * vec4(position, 1.0));\r\n    vertex = vec3(world * vec4(animatedPosition, 1.0));\r\n    // Pass the normal down to the fragment shader\r\n    // todo : use modifiedNormal when effect is done\r\n    vNormal = vec3(normalMatrix * vec4(modifiedNormal , 1.0));\r\n    //vNormal = normal;\r\n    \r\n    // Pass the position down to the fragment shader\r\n    gl_Position = projection * view * world * vec4(animatedPosition, 1.0);\r\n    vViewPosition = -gl_Position.xyz;\r\n}",{instances:!1,declarations:"",positionModifier:""})({instances:f.instances>1,declarations:i,positionModifier:c}),m=o.createShader(o.VERTEX_SHADER);o.shaderSource(m,p),o.compileShader(m),o.getShaderParameter(m,o.COMPILE_STATUS)||console.error("ERROR compiling vertex shader!",o.getShaderInfoLog(m));let g="",h="";n.specular&&(h=n.specular.shader({declaration:!0}),g=n.specular.shader({irradiance:!0}));let v="",b="";n.diffuseMap&&(v=n.diffuseMap.shader({declaration:!0,mapType:n.diffuseMap.type}),b=n.diffuseMap.shader({diffuseMapSample:!0,mapType:n.diffuseMap.type,coordinateSpace:n.diffuseMap.coordinateSpace}));let A="",M="";n.normalMap&&(A=n.normalMap.shader({declaration:!0,mapType:n.normalMap.type}),M=n.normalMap.shader({normalMapSample:!0,mapType:n.normalMap.type}));const L=U("#version 300 es\r\nprecision mediump float;\r\n\r\n${defines}\r\n\r\n#define RECIPROCAL_PI 0.3183098861837907\r\n\r\nuniform vec3 diffuse;\r\nuniform float metalness;\r\nuniform vec3 ambientLightColor;\r\nuniform vec3 cameraPosition;\r\n//uniform mat3 normalMatrix;\r\n\r\nin vec3 vertex;\r\nin vec3 vNormal;\r\nin highp vec2 vUv;\r\nin vec3 vViewPosition;\r\n\r\nout vec4 fragColor;\r\n\r\nstruct ReflectedLight {\r\n\tvec3 directDiffuse;\r\n\tvec3 directSpecular;\r\n\tvec3 indirectDiffuse;\r\n\tvec3 indirectSpecular;\r\n};\r\n\r\nstruct PhysicalMaterial {\r\n\tvec3 diffuseColor;\r\n\tfloat roughness;\r\n\tvec3 specularColor;\r\n\tfloat specularF90;\r\n\tfloat ior;\r\n};\r\n\r\nvec3 BRDF_Lambert(const in vec3 diffuseColor) {\r\n\treturn RECIPROCAL_PI * diffuseColor;\r\n}\r\n\r\n\r\n${declarations}\r\n\r\nvec4 sRGBTransferOETF(in vec4 value) {\r\n\treturn vec4(mix(pow(value.rgb, vec3(0.41666)) * 1.055 - vec3(0.055), value.rgb * 12.92, vec3(lessThanEqual(value.rgb, vec3(0.0031308)))), value.a);\r\n}\r\n\r\nvec4 linearToOutputTexel(vec4 value) {\r\n\treturn (sRGBTransferOETF(value));\r\n}\r\n\r\nvoid main() {\r\n    PhysicalMaterial material;\r\n\tmaterial.diffuseColor = diffuse.rgb * (1.0 - metalness);\r\n\t${diffuseMapSample}\r\n\t\r\n\r\n\tvec3 normal = normalize( vNormal );\r\n\t${normalMapSample}\r\n\r\n    ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\r\n\r\n    reflectedLight.indirectDiffuse += ambientLightColor * BRDF_Lambert(material.diffuseColor);\r\n\r\n    vec3 totalIrradiance = vec3(0.0f);\r\n    ${irradiance}\r\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse + reflectedLight.directDiffuse + reflectedLight.directSpecular;\r\n    fragColor = vec4(outgoingLight, 1.0f);\r\n    //fragColor = vec4(totalIrradiance, 1.0f);\r\n    ${toneMapping}\r\n\tfragColor = linearToOutputTexel(fragColor);\r\n}",{defines:"",declarations:"",diffuseMapSample:"",normalMapSample:"",irradiance:"",toneMapping:"",numPointLights:0})({defines:(y={...r.numPointLights?{NUM_POINT_LIGHTS:r.numPointLights}:void 0},["",...Object.entries(y).map((([t,n])=>`#define ${t} ${n}`))].join("\n")),declarations:[...r.numPointLights?[r.pointLightShader({declaration:!0,irradiance:!1})]:[],...r.toneMappings?.length>0?[...r.toneMappings.map((t=>t.shader({declaration:!0,exposure:t.exposure})))]:[],...n.specular?[h]:[],...n.diffuseMap?[v]:[],...n.normalMap?[A]:[]].join("\n"),diffuseMapSample:b,normalMapSample:M,irradiance:[...r.numPointLights?[r.pointLightShader({declaration:!1,irradiance:!0,specularIrradiance:g})]:[]].join("\n"),toneMapping:[...r.toneMappings?.length>0?[...r.toneMappings.map((t=>t.shader({color:!0})))]:[]].join("\n"),numPointLights:r.numPointLights});var y;const R=o.createShader(o.FRAGMENT_SHADER);o.shaderSource(R,L),o.compileShader(R),o.getShaderParameter(R,o.COMPILE_STATUS)||console.error("ERROR compiling fragment shader!",o.getShaderInfoLog(R)),o.attachShader(a,m),o.attachShader(a,R)}},linkProgram:H,validateProgram:X,useProgram:K})))})),gt=$({init:!1});function ht(t){return null!=t&&null!=t.subscribe}function vt(t,n){return function(){const{programMap:e}=s(t),r=e.get(n);t.update((t=>({...t,program:r})))}}function bt(t,n){return function(){const{meshMap:e}=s(t),r=e.get(n);t.update((t=>({...t,vao:r})))}}const At=$({programMap:new Map,meshMap:new Map}),Mt=[],Lt=new Map;Lt.set(ct,0),Lt.set(ut,0),Lt.set(st,0);const yt=$(0),Rt=T([ct,mt,ut,st,yt],(([t,n,e,r,o])=>{if(!t.enabled||4===o||1===o)return Mt;const a=function(){const t=new Set;return Lt.get(ct)!==ct.revision&&t.add(ct),Lt.get(ut)!==ut.revision&&t.add(ut),Lt.get(st)!==st.revision&&t.add(st),Lt.set(ct,ct.revision),Lt.set(ut,ut.revision),Lt.set(st,st.revision),t}();if(0===a.length)return Mt;const i=e.filter(ht).filter(it),c=i.filter((t=>"point"===s(t).type)),u=c.length;let l;u>0&&(l=s(c[0]).shader);const f=ct.processed;let d={canvas:t.canvas,backgroundColor:f.backgroundColor,...t.toneMappings.length>0?{toneMappings:t.toneMappings}:void 0,...u>0?{numPointLights:u,pointLightShader:l}:void 0};const p=[];At.update((t=>({...t,...d})));var m;return s(gt).init||p.push((m=At,function(){const t=s(m),n=t.canvas.getBoundingClientRect();t.canvas.width=n.width,t.canvas.height=n.height;const e=t.canvas.getContext("webgl2");m.update((n=>({...n,...t,gl:e}))),e.viewportWidth=n.width,e.viewportHeight=n.height,e.clearColor(...t.backgroundColor),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_COLOR_BIT),e.enable(e.DEPTH_TEST),e.enable(e.CULL_FACE),e.frontFace(e.CCW),e.cullFace(e.BACK)}))
/*!init &&*/,p.push(W(At),...n.reduce(((t,n)=>[...t,...s(At).programMap.has(n)?[vt(At,n),n.useProgram(At),...a.has(st)?[Z(At,r)]:[]]:[n.createProgram(At,n),n.createShaders(At,n.material,n.meshes),n.linkProgram(At),n.validateProgram(At),n.useProgram(At),Z(At,r),Q(At,f.ambientLightColor),...[...i.reduce(((t,n)=>{const e=s(n);return t.set(e.type,e.setupLights),t}),new Map)].map((([t,n])=>n(At,i))),...n.material?.specular?[n.material.specular.setupSpecular(At)]:[],...n.material?.diffuseMap?[n.mesh.material?.diffuseMap.setupTexture(At)]:[],...n.material?.normalMap?[n.material?.normalMap.setupTexture(At)]:[],...n.requireTime?[j(At)]:[]],...n.meshes.reduce(((t,e)=>[...t,...s(At).meshMap.has(e)?[bt(At,e),...null==e.instances?[tt(At,e.matrix),nt(At)]:[]]:[ot(At,e),J(At,n.material),tt(At,null==e.instances?e.matrix:e.matrices,e.instances),nt(At,e.instances),...e.animations?.map((t=>t.setupAnimation(At)))||[]],q(At),z(At,e.instances,e.drawMode)]),[])]),[])),p}),Mt);T([Rt],(([t])=>{if(0===t.length)return 0;if(!s(gt).init&&0===s(yt))return yt.set(1),t.forEach((t=>t())),gt.set({init:!0}),yt.set(2),1;if(2===s(yt))return yt.set(3),requestAnimationFrame((async function t(){yt.set(4),s(ct).loop&&s(ct).loop(),yt.set(3),s(Rt).forEach((t=>t())),yt.set(4),requestAnimationFrame(t)})),2})).subscribe((t=>{}));let xt=null;const Et=t=>{xt=t},_t=()=>xt;function Pt(t,n,e){var r,o;n.preMultipliedColor=[...n.color],r=n.preMultipliedColor,o=n.intensity,r[0]*=o,r[1]*=o,r[2]*=o,t[e]=n.position[0],t[e+1]=n.position[1],t[e+2]=n.position[2],t[e+4]=n.preMultipliedColor[0],t[e+5]=n.preMultipliedColor[1],t[e+6]=n.preMultipliedColor[2],t[e+7]=n.cutoffDistance,t[e+8]=n.decayExponent,t[e+9]=0,t[e+10]=0,t[e+11]=0,t[e+12]=0}function wt(t,n){return function(){const e=(t=s(t)).gl,r=t.program;_t()||function({gl:t},n){const e=n.filter((t=>"point"===s(t).type)),r=e.length,o=new Float32Array(12*r);for(let t=0;t<r;t++)Pt(o,s(e[t]),12*t);const a=t.createBuffer();Et(a),t.bindBufferBase(t.UNIFORM_BUFFER,k,a),t.bufferData(t.UNIFORM_BUFFER,o,t.DYNAMIC_DRAW)}(t,n);const o=e.getUniformBlockIndex(r,"PointLights");e.uniformBlockBinding(r,o,k)}}function Ft(t,n,e){const r=(t=s(t)).gl,o=n.filter((t=>"point"===s(t).type)).findIndex((t=>t===e)),a=_t();if(-1!==o){const t=new Float32Array(12),n=12*o;Pt(t,s(e),n),r.bindBuffer(r.UNIFORM_BUFFER,a),r.bufferSubData(r.UNIFORM_BUFFER,n*Float32Array.BYTES_PER_ELEMENT,t)}}const St={0:"POINTS",1:"LINES",2:"LINE_LOOP",3:"LINE_STRIP",4:"TRIANGLES",5:"TRIANGLE_STRIP",6:"TRIANGLE_FAN"};function $t(n){let e;return{c(){var t;t="canvas",e=document.createElement(t)},m(t,r){!function(t,n,e){t.insertBefore(n,e||null)}(t,e,r),n[1](e)},p:t,i:t,o:t,d(t){t&&l(e),n[1](null)}}}function Tt(){performance.now()}function Bt(t,n,e){let r,o,a,i;return c(t,ct,(t=>e(2,r=t))),c(t,ut,(t=>e(3,o=t))),c(t,st,(t=>e(4,a=t))),p((async()=>{u(ct,r={...r,canvas:i,backgroundColor:8900331,ambientLightColor:[16777215,.5]},r),u(st,a={position:[0,5,-5],target:[0,0,0],fov:75},a);const t={attributes:{positions:[-1,1,-1,-1,1,1,1,1,1,1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,-1],normals:[0,1,0,0,1,0,0,1,0,0,1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,-1,0,0,-1,0,0,-1,0],elements:[0,1,2,0,2,3,5,4,6,6,4,7,8,9,10,8,10,11,13,12,14,15,14,12,16,17,18,16,18,19,21,20,22,22,20,23]},drawMode:St[4]},n=(t=>{const{subscribe:n,set:e}=$(t);return{subscribe:n,set:t=>{e(t)}}})((e={position:[-2,3,0],color:[1,1,1],intensity:20,cutoffDistance:0,decayExponent:2},{type:"point",position:[0,0,0],color:[1,1,1],intensity:3,cutoffDistance:5,decayExponent:1,...e,shader:U("${declaration?\r\n`\r\n\r\nfloat pow4(const in float x) {\r\n    float x2 = x * x;\r\n    return x2 * x2;\r\n}\r\nfloat pow2(const in float x) {\r\n    return x * x;\r\n}\r\n\r\nfloat saturate(const in float a) {\r\n    return clamp(a, 0.0f, 1.0f);\r\n}\r\n\r\nstruct LightParams {\r\n    vec3 irradiance;\r\n    vec3 direction;\r\n    vec3 color;\r\n    float distance;\r\n};\r\n\r\nstruct PointLight {\r\n    vec3 position;\r\n    vec3 color;\r\n    float cutoffDistance;\r\n    float decayExponent;\r\n};\r\n\r\nlayout(std140) uniform PointLights {\r\n    PointLight pointLights[NUM_POINT_LIGHTS];\r\n};\r\n\r\nfloat getDistanceAttenuation(const in float lightDistance, const in float cutoffDistance, const in float decayExponent) {\r\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\r\n\t// page 32, equation 26: E[window1]\r\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n    float distanceFalloff = 1.0f / max(pow(lightDistance, decayExponent), 0.01f);\r\n    if(cutoffDistance > 0.0f) {\r\n        distanceFalloff *= pow2(saturate(1.0f - pow4(lightDistance / cutoffDistance)));\r\n    }\r\n    return distanceFalloff;\r\n\r\n}\r\n\r\nLightParams getDirectDiffuse(const in PointLight pointLight,const in vec3 vertexPosition, const in vec3 normal,const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\r\n    LightParams lightParams = LightParams(vec3(0.0f), vec3(0.0f), vec3(0.0f), 0.0f);\r\n    vec3 lVector = pointLight.position - vertexPosition;\r\n    lightParams.distance = length(lVector);\r\n    lightParams.direction = normalize(lVector);\r\n    float dotNL = saturate(dot(normal, lightParams.direction));\r\n    lightParams.color = pointLight.color;\r\n    lightParams.color *= getDistanceAttenuation(lightParams.distance, pointLight.cutoffDistance, pointLight.decayExponent);\r\n    lightParams.irradiance = dotNL * lightParams.color;\r\n    \r\n    reflectedLight.directDiffuse += lightParams.irradiance * BRDF_Lambert(material.diffuseColor);\r\n    return lightParams;\r\n}\r\n\r\nfloat calculatePointLightBrightness(float lightDistance, float cutoffDistance, float decayExponent) {\r\n    return getDistanceAttenuation(lightDistance, cutoffDistance, decayExponent);\r\n}\r\n` : ''\r\n}\r\n${irradiance?\r\n`\r\n    vec3 irradiance = vec3(0.0f);\r\n    vec3 direction = vec3(0.0f);\r\n    for(int i = 0; i < NUM_POINT_LIGHTS; i++) {\r\n        PointLight pointLight = pointLights[i];\r\n        \r\n\r\n        LightParams lightParams = getDirectDiffuse(pointLight, vertex, normal, material, reflectedLight);\r\n        totalIrradiance += reflectedLight.directDiffuse;\r\n        ${specularIrradiance}\r\n    }\r\n` : ''\r\n}\r\n",{declaration:!1,irradiance:!1,specularIrradiance:""}),setupLights:wt,updateOneLight:Ft}));var e;const c=D(new Float32Array(16));var l,f,d,p,m,g,h,v,b,A,M,L,y,R,x,E,_,P;l=c,f=c,E=(d=[3,0,0])[0],_=d[1],P=d[2],f===l?(l[12]=f[0]*E+f[4]*_+f[8]*P+f[12],l[13]=f[1]*E+f[5]*_+f[9]*P+f[13],l[14]=f[2]*E+f[6]*_+f[10]*P+f[14],l[15]=f[3]*E+f[7]*_+f[11]*P+f[15]):(p=f[0],m=f[1],g=f[2],h=f[3],v=f[4],b=f[5],A=f[6],M=f[7],L=f[8],y=f[9],R=f[10],x=f[11],l[0]=p,l[1]=m,l[2]=g,l[3]=h,l[4]=v,l[5]=b,l[6]=A,l[7]=M,l[8]=L,l[9]=y,l[10]=R,l[11]=x,l[12]=p*E+v*_+L*P+f[12],l[13]=m*E+b*_+y*P+f[13],l[14]=g*E+A*_+R*P+f[14],l[15]=h*E+M*_+x*P+f[15]);u(ut,o=[...o,{...t,matrix:c,material:{diffuse:[1,.5,.5],metalness:0}},{...t,matrix:D(new Float32Array(16)),material:{diffuse:[1,1,.5],metalness:0}},n],o),u(ct,r={...r,loop:Tt,enabled:!0},r),function(t,n){let e,r;function o(n){let o="mousemove",a="mouseup",s=n;"touchstart"===n.type&&(o="touchmove",a="touchend",s=n.touches[0]),t.addEventListener(o,i),e=s.clientX,r=s.clientY,t.addEventListener(a,u)}function a(t,n){const e=Math.sqrt(Math.pow(t[0]-n[0],2)+Math.pow(t[1]-n[1],2)+Math.pow(t[2]-n[2],2));return{radius:e,polar:Math.acos(Math.max(-1,Math.min(1,(t[1]-n[1])/e))),azimuth:Math.atan2(t[0]-n[0],t[2]-n[2])}}function i(t){let o=t;"touchmove"===t.type&&(o=t.touches[0]);const i=o.clientX-e,u=o.clientY-r,l=s(n),{position:f,target:d,fov:p}=l,{radius:m,polar:g,azimuth:h}=a(f,d),v=c(m,g-u/100,h-i/100);v[0]=v[0]+d[0],v[1]=v[1]+d[1],v[2]=v[2]+d[2],n.set({position:v,target:d,fov:p}),e=o.clientX,r=o.clientY}function c(t,n,e){const r=Math.sin(n)*t;return[r*Math.sin(e),Math.cos(n)*t,r*Math.cos(e)]}function u(n){t.removeEventListener("mousemove",i),t.removeEventListener("mouseup",u)}t.addEventListener("touchstart",o),t.addEventListener("mousedown",o),t.addEventListener("wheel",(function(t){const e=s(n),{position:r,target:o,fov:i}=e,{radius:u,polar:l,azimuth:f}=a(r,o);console.log("radius",u);const d=c(u+.001*t.deltaY*u,l,f);d[0]=d[0]+o[0],d[1]=d[1]+o[1],d[2]=d[2]+o[2],n.set({position:d,target:o,fov:i})}))}(i,st)})),[i,function(t){g[t?"unshift":"push"]((()=>{i=t,e(0,i)}))}]}class Ct extends F{constructor(t){super(),w(this,t,Bt,$t,a,{})}}export{Ct as default};
