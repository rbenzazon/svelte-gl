function n(){}function t(n){return n()}function r(){return Object.create(null)}function o(n){n.forEach(t)}function e(n){return"function"==typeof n}function i(n,t){return n!=n?t==t:n!==t||n&&"object"==typeof n||"function"==typeof n}function a(t,...r){if(null==t){for(const n of r)n(void 0);return n}const o=t.subscribe(...r);return o.unsubscribe?()=>o.unsubscribe():o}function c(n){let t;return a(n,(n=>t=n))(),t}function s(n,t,r){n.$$.on_destroy.push(a(t,r))}function l(n){n.parentNode&&n.parentNode.removeChild(n)}let f;function u(n){f=n}function p(n){(function(){if(!f)throw new Error("Function called outside component initialization");return f})().$$.on_mount.push(n)}const g=[],d=[];let h=[];const m=[],v=Promise.resolve();let x=!1;function b(n){h.push(n)}const M=new Set;let A=0;function _(){if(0!==A)return;const n=f;do{try{for(;A<g.length;){const n=g[A];A++,u(n),E(n.$$)}}catch(n){throw g.length=0,A=0,n}for(u(null),g.length=0,A=0;d.length;)d.pop()();for(let n=0;n<h.length;n+=1){const t=h[n];M.has(t)||(M.add(t),t())}h.length=0}while(g.length);for(;m.length;)m.pop()();x=!1,M.clear(),u(n)}function E(n){if(null!==n.fragment){n.update(),o(n.before_update);const t=n.dirty;n.dirty=[-1],n.fragment&&n.fragment.p(n.ctx,t),n.after_update.forEach(b)}}const L=new Set;function R(n,t){const r=n.$$;null!==r.fragment&&(!function(n){const t=[],r=[];h.forEach((o=>-1===n.indexOf(o)?t.push(o):r.push(o))),r.forEach((n=>n())),h=t}(r.after_update),o(r.on_destroy),r.fragment&&r.fragment.d(t),r.on_destroy=r.fragment=null,r.ctx=[])}function y(n,t){-1===n.$$.dirty[0]&&(g.push(n),x||(x=!0,v.then(_)),n.$$.dirty.fill(0)),n.$$.dirty[t/31|0]|=1<<t%31}function w(i,a,c,s,p,g,d=null,h=[-1]){const m=f;u(i);const v=i.$$={fragment:null,ctx:[],props:g,update:n,not_equal:p,bound:r(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(a.context||(m?m.$$.context:[])),callbacks:r(),dirty:h,skip_bound:!1,root:a.target||m.$$.root};d&&d(v.root);let x=!1;if(v.ctx=c?c(i,a.props||{},((n,t,...r)=>{const o=r.length?r[0]:t;return v.ctx&&p(v.ctx[n],v.ctx[n]=o)&&(!v.skip_bound&&v.bound[n]&&v.bound[n](o),x&&y(i,n)),t})):[],v.update(),x=!0,o(v.before_update),v.fragment=!!s&&s(v.ctx),a.target){if(a.hydrate){const n=function(n){return Array.from(n.childNodes)}(a.target);v.fragment&&v.fragment.l(n),n.forEach(l)}else v.fragment&&v.fragment.c();a.intro&&((M=i.$$.fragment)&&M.i&&(L.delete(M),M.i(A))),function(n,r,i){const{fragment:a,after_update:c}=n.$$;a&&a.m(r,i),b((()=>{const r=n.$$.on_mount.map(t).filter(e);n.$$.on_destroy?n.$$.on_destroy.push(...r):o(r),n.$$.on_mount=[]})),c.forEach(b)}(i,a.target,a.anchor),_()}var M,A;u(m)}class F{$$=void 0;$$set=void 0;$destroy(){R(this,1),this.$destroy=n}$on(t,r){if(!e(r))return n;const o=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return o.push(r),()=>{const n=o.indexOf(r);-1!==n&&o.splice(n,1)}}$set(n){var t;this.$$set&&(t=n,0!==Object.keys(t).length)&&(this.$$.skip_bound=!0,this.$$set(n),this.$$.skip_bound=!1)}}"undefined"!=typeof window&&(window.__svelte||(window.__svelte={v:new Set})).v.add("4");var $=1e-6,C="undefined"!=typeof Float32Array?Float32Array:Array;function P(){var n=new C(16);return C!=Float32Array&&(n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0),n[0]=1,n[5]=1,n[10]=1,n[15]=1,n}function I(n){return n[0]=1,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=1,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[10]=1,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,n}function B(n,t){if(n===t){var r=t[1],o=t[2],e=t[3],i=t[6],a=t[7],c=t[11];n[1]=t[4],n[2]=t[8],n[3]=t[12],n[4]=r,n[6]=t[9],n[7]=t[13],n[8]=o,n[9]=i,n[11]=t[14],n[12]=e,n[13]=a,n[14]=c}else n[0]=t[0],n[1]=t[4],n[2]=t[8],n[3]=t[12],n[4]=t[1],n[5]=t[5],n[6]=t[9],n[7]=t[13],n[8]=t[2],n[9]=t[6],n[10]=t[10],n[11]=t[14],n[12]=t[3],n[13]=t[7],n[14]=t[11],n[15]=t[15];return n}function T(n,t){var r=t[0],o=t[1],e=t[2],i=t[3],a=t[4],c=t[5],s=t[6],l=t[7],f=t[8],u=t[9],p=t[10],g=t[11],d=t[12],h=t[13],m=t[14],v=t[15],x=r*c-o*a,b=r*s-e*a,M=r*l-i*a,A=o*s-e*c,_=o*l-i*c,E=e*l-i*s,L=f*h-u*d,R=f*m-p*d,y=f*v-g*d,w=u*m-p*h,F=u*v-g*h,$=p*v-g*m,C=x*$-b*F+M*w+A*y-_*R+E*L;return C?(C=1/C,n[0]=(c*$-s*F+l*w)*C,n[1]=(e*F-o*$-i*w)*C,n[2]=(h*E-m*_+v*A)*C,n[3]=(p*_-u*E-g*A)*C,n[4]=(s*y-a*$-l*R)*C,n[5]=(r*$-e*y+i*R)*C,n[6]=(m*M-d*E-v*b)*C,n[7]=(f*E-p*M+g*b)*C,n[8]=(a*F-c*y+l*L)*C,n[9]=(o*y-r*F-i*L)*C,n[10]=(d*_-h*M+v*x)*C,n[11]=(u*M-f*_-g*x)*C,n[12]=(c*R-a*w-s*L)*C,n[13]=(r*w-o*R+e*L)*C,n[14]=(h*b-d*A-m*x)*C,n[15]=(f*A-u*b+p*x)*C,n):null}Math.hypot||(Math.hypot=function(){for(var n=0,t=arguments.length;t--;)n+=arguments[t]*arguments[t];return Math.sqrt(n)});var D=function(n,t,r,o,e){var i,a=1/Math.tan(t/2);return n[0]=a/r,n[1]=0,n[2]=0,n[3]=0,n[4]=0,n[5]=a,n[6]=0,n[7]=0,n[8]=0,n[9]=0,n[11]=-1,n[12]=0,n[13]=0,n[15]=0,null!=e&&e!==1/0?(i=1/(o-e),n[10]=(e+o)*i,n[14]=2*e*o*i):(n[10]=-1,n[14]=-2*o),n};const S=[];function O(t,r=n){let o;const e=new Set;function a(n){if(i(t,n)&&(t=n,o)){const n=!S.length;for(const n of e)n[1](),S.push(n,t);if(n){for(let n=0;n<S.length;n+=2)S[n][0](S[n+1]);S.length=0}}}function c(n){a(n(t))}return{set:a,update:c,subscribe:function(i,s=n){const l=[i,s];return e.add(l),1===e.size&&(o=r(a,c)||n),i(t),()=>{e.delete(l),0===e.size&&o&&(o(),o=null)}}}}function N(t,r,i){const c=!Array.isArray(t),s=c?[t]:t;if(!s.every(Boolean))throw new Error("derived() expects stores as input, got a falsy value");const l=r.length<2;return f=(t,i)=>{let f=!1;const u=[];let p=0,g=n;const d=()=>{if(p)return;g();const o=r(c?u[0]:u,t,i);l?t(o):g=e(o)?o:n},h=s.map(((n,t)=>a(n,(n=>{u[t]=n,p&=~(1<<t),f&&d()}),(()=>{p|=1<<t}))));return f=!0,d(),function(){o(h),g(),f=!1}},{subscribe:O(i,f).subscribe};var f}const U=(n,t)=>((n,t)=>r=>Function.constructor(...n,`return \`${t}\``)(...r))(Object.keys(n),t)(Object.values(n));function k(n,t){var r=t[0],o=t[1],e=t[2],i=r*r+o*o+e*e;return i>0&&(i=1/Math.sqrt(i)),n[0]=t[0]*i,n[1]=t[1]*i,n[2]=t[2]*i,n}function G(n,t,r,o){var e=t[0],i=t[1],a=t[2];return n[0]=e+o*(r[0]-e),n[1]=i+o*(r[1]-i),n[2]=a+o*(r[2]-a),n}var j;function X(){return new Array(3).fill(0)}function Y(n,t){return n[0]*=t,n[1]*=t,n[2]*=t,n}j=new C(3),C!=Float32Array&&(j[0]=0,j[1]=0,j[2]=0);const H=n=>({type:"point",position:[0,0,0],color:[1,1,1],intensity:3,cutoffDistance:5,decayExponent:1,...n,shader:n=>U(n,"${declaration?\r\n`\r\n\r\nfloat pow4(const in float x) {\r\n    float x2 = x * x;\r\n    return x2 * x2;\r\n}\r\nfloat pow2(const in float x) {\r\n    return x * x;\r\n}\r\n\r\nfloat saturate(const in float a) {\r\n    return clamp(a, 0.0f, 1.0f);\r\n}\r\n\r\nstruct PointLight {\r\n    vec3 position;\r\n    vec3 color;\r\n    float cutoffDistance;\r\n    float decayExponent;\r\n};\r\n\r\nlayout(std140) uniform PointLights {\r\n    PointLight pointLights[NUM_POINT_LIGHTS];\r\n};\r\n\r\nfloat getDistanceAttenuation(const in float lightDistance, const in float cutoffDistance, const in float decayExponent) {\r\n\t// based upon Frostbite 3 Moving to Physically-based Rendering\r\n\t// page 32, equation 26: E[window1]\r\n\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\r\n    float distanceFalloff = 1.0f / max(pow(lightDistance, decayExponent), 0.01f);\r\n    if(cutoffDistance > 0.0f) {\r\n        distanceFalloff *= pow2(saturate(1.0f - pow4(lightDistance / cutoffDistance)));\r\n    }\r\n    return distanceFalloff;\r\n\r\n}\r\n\r\nvec3 calculatePointLightBrightness(vec3 lightPosition, vec3 lightColor, float cutoffDistance, float decayExponent, vec3 vertexPosition, vec3 normal) {\r\n    vec3 offset = lightPosition - vertexPosition;\r\n    float lightDistance = length(offset);\r\n    vec3 direction = normalize(offset);\r\n    vec3 irradiance = saturate(dot(normal, direction)) * lightColor;\r\n    float distanceFalloff = getDistanceAttenuation(lightDistance, cutoffDistance, decayExponent);\r\n    return vec3(irradiance * distanceFalloff);\r\n}\r\n` : ''\r\n}\r\n${irradiance?\r\n`\r\n    for(int i = 0; i < NUM_POINT_LIGHTS; i++) {\r\n        PointLight pointLight = pointLights[i];\r\n        totalIrradiance += calculatePointLightBrightness(pointLight.position, pointLight.color, pointLight.cutoffDistance, pointLight.decayExponent, vertex, vNormal);\r\n    }\r\n` : ''\r\n}\r\n"),setupLights:V,updateOneLight:K});let q=null;const z=n=>{q=n},W=()=>q;function V(n,t){return function(){const r=(n=c(n)).gl,o=n.program,e=t.filter((n=>"point"===c(n).type)),i=r.getUniformBlockIndex(o,"PointLights");r.uniformBlockBinding(o,i,0);const a=r.createBuffer();z(a),r.bindBuffer(r.UNIFORM_BUFFER,a);const s=e.length;r.bindBufferBase(r.UNIFORM_BUFFER,0,a);const l=new Float32Array(12*s);for(let n=0;n<s;n++){const t=c(e[n]),r=12*n;t.preMultipliedColor=[...t.color],Y(t.preMultipliedColor,t.intensity),l[r]=t.position[0],l[r+1]=t.position[1],l[r+2]=t.position[2],l[r+4]=t.preMultipliedColor[0],l[r+5]=t.preMultipliedColor[1],l[r+6]=t.preMultipliedColor[2],l[r+7]=t.cutoffDistance,l[r+8]=t.decayExponent,l[r+9]=.25,l[r+10]=.5,l[r+11]=.75,l[r+12]=1}r.bufferData(r.UNIFORM_BUFFER,l,r.DYNAMIC_DRAW)}}function K(n,t,r){const o=(n=c(n)).gl,e=t.filter((n=>"point"===c(n).type)).findIndex((n=>n===r)),i=W();if(-1!==e){const n=new Float32Array(12),t=12*e,a=c(r);a.preMultipliedColor=[...a.color],Y(a.preMultipliedColor,a.intensity),n[0]=a.position[0],n[1]=a.position[1],n[2]=a.position[2],n[4]=a.preMultipliedColor[0],n[5]=a.preMultipliedColor[1],n[6]=a.preMultipliedColor[2],n[7]=a.cutoffDistance,n[8]=a.decayExponent,n[9]=.25,n[10]=.5,n[11]=.75,n[12]=1,o.bindBuffer(o.UNIFORM_BUFFER,i),o.bufferSubData(o.UNIFORM_BUFFER,t*Float32Array.BYTES_PER_ELEMENT,n)}}const J=Math.PI/180;function Q(n){return function(){const t=(n=c(n)).gl,r=n.program,o=n.worldMatrix,e=t.getUniformLocation(r,"normalMatrix");n.normalMatrixLocation=e;let i=P();T(i,o),B(i,i),t.uniformMatrix4fv(e,!1,i)}}function Z(n){return function(){const t=(n=c(n)).gl.createProgram();n.program=t}}function nn(n){return function(){const t=(n=c(n)).gl,r=n.program;t.linkProgram(r),t.getProgramParameter(r,t.LINK_STATUS)||console.error("ERROR linking program!",t.getProgramInfoLog(r)),t.validateProgram(r),t.getProgramParameter(r,t.VALIDATE_STATUS)||console.error("ERROR validating program!",t.getProgramInfoLog(r)),t.useProgram(r)}}function tn(n,{color:t}){return function(){const r=(n=c(n)).gl,o=n.program,e=r.getUniformLocation(o,"color");r.uniform3fv(e,new Float32Array(t))}}function rn(n,t){return function(){const r=(n=c(n)).gl,o=n.program,e=r.getUniformLocation(o,"projection"),i=t.fov*J;const a=n.canvas.width/n.canvas.height,s=t.near,l=t.far;let f=new Float32Array(16);f=D(f,i,a,s,l),r.uniformMatrix4fv(e,!1,f);const u=r.getUniformLocation(o,"view"),p=new Float32Array(16);!function(n,t,r,o){var e,i,a,c,s,l,f,u,p,g,d=t[0],h=t[1],m=t[2],v=o[0],x=o[1],b=o[2],M=r[0],A=r[1],_=r[2];Math.abs(d-M)<$&&Math.abs(h-A)<$&&Math.abs(m-_)<$?I(n):(f=d-M,u=h-A,p=m-_,e=x*(p*=g=1/Math.hypot(f,u,p))-b*(u*=g),i=b*(f*=g)-v*p,a=v*u-x*f,(g=Math.hypot(e,i,a))?(e*=g=1/g,i*=g,a*=g):(e=0,i=0,a=0),c=u*a-p*i,s=p*e-f*a,l=f*i-u*e,(g=Math.hypot(c,s,l))?(c*=g=1/g,s*=g,l*=g):(c=0,s=0,l=0),n[0]=e,n[1]=c,n[2]=f,n[3]=0,n[4]=i,n[5]=s,n[6]=u,n[7]=0,n[8]=a,n[9]=l,n[10]=p,n[11]=0,n[12]=-(e*d+i*h+a*m),n[13]=-(c*d+s*h+l*m),n[14]=-(f*d+u*h+p*m),n[15]=1)}(p,t.position,t.target,t.up),r.uniformMatrix4fv(u,!1,p)}}function on(n,t){return function(){const r=(n=c(n)).gl,o=n.program;t||I(t=new Float32Array(16)),n.worldMatrix=t;const e=r.getUniformLocation(o,"world");r.uniformMatrix4fv(e,!1,t)}}const en=n=>{const t=O(n),{subscribe:r,set:o,update:e}=t,i={subscribe:r,set:n=>{e((t=>(un&&c(un).program&&t.updateOneLight(un,c(an).lights,i),{...t,...n})))}};return i},an=function(){const{subscribe:n,set:t,update:r}=O({backgroundColor:[2.55,2.55,2.55,1],canvas:null,camera:null,meshes:[],lights:[],toneMappings:[],loop:null});return{subscribe:n,setCamera:(n=[0,0,-1],t=[0,0,0],o=80,e=.1,i=1e3,a=[0,1,0])=>r((r=>(r.camera={fov:o,near:e,far:i,position:n,target:t,up:a},r))),addMesh:n=>r((t=>(t.meshes=[...t.meshes,n],t))),addLight:n=>{const t=en(n);return r((n=>(n.lights=[...n.lights,t],n))),{remove:()=>r((t=>(t.lights=t.lights.filter((t=>t!==n)),t))),store:t}},addToneMapping:n=>r((t=>(t.toneMappings=[...t.toneMappings,n],t))),setLoop:n=>r((t=>(t.loop=n,t))),setCanvas:n=>r((t=>(t.canvas=n,t))),setBackgroundColor:n=>r((t=>(t.backgroundColor=n,t)))}}(),cn=new Float32Array(16);I(cn);const sn=(()=>{const{subscribe:n,set:t}=O(cn);return{subscribe:n,set:n=>(t(n),un&&c(un).program&&(1===c(ln).length?function(n,t){const r=(n=c(n)).gl,o=n.program,e=r.getUniformLocation(o,"world");r.uniformMatrix4fv(e,!1,t)}(un,n):fn.set({init:!1})),n)}})(),ln=N(an,(n=>n.meshes.map((n=>({createProgram:Z,mesh:n,attributes:n.attributes,uniforms:n.uniforms,createShaders:function(n){return function(){const t=(n=c(n)).gl,r=n.program,o=t.createShader(t.VERTEX_SHADER);t.shaderSource(o,"#version 300 es\r\nprecision mediump float;\r\n    \r\nin vec3 position;\r\nin vec3 normal;\r\n\r\nuniform mat4 world;\r\nuniform mat4 view;\r\nuniform mat4 projection;\r\nuniform mat4 normalMatrix;\r\n\r\n// Pass the color attribute down to the fragment shader\r\nout vec3 vertexColor;\r\nout vec3 vNormal;\r\nout vec3 vertex;\r\n\r\nvoid main() {\r\n    \r\n\r\n    // Pass the color down to the fragment shader\r\n    vertexColor = vec3(1.27,1.27,1.27);\r\n    // Pass the vertex down to the fragment shader\r\n    vertex = vec3(world * vec4(position, 1.0));\r\n    // Pass the normal down to the fragment shader\r\n    vNormal = vec3(normalMatrix * vec4(normal, 1.0));\r\n    //vNormal = normal;\r\n    \r\n    // Pass the position down to the fragment shader\r\n    gl_Position = projection * view * world * vec4(position, 1.0);\r\n}"),t.compileShader(o);const e=U({defines:(i={...n.numPointLights?{NUM_POINT_LIGHTS:n.numPointLights}:void 0},["",...Object.entries(i).map((([n,t])=>`#define ${n} ${t}`))].join("\n")),declarations:[...n.numPointLights?[n.pointLightShader({declaration:!0,irradiance:!1})]:void 0,...n.toneMappings.length>0?[...n.toneMappings.map((n=>n.shader({declaration:!0,exposure:n.exposure,color:!1})))]:void 0].join("\n"),irradiance:[...n.numPointLights?[n.pointLightShader({declaration:!1,irradiance:!0})]:void 0].join("\n"),toneMapping:[...n.toneMappings.length>0?[...n.toneMappings.map((n=>n.shader({declaration:!1,exposure:!1,color:!0})))]:void 0].join("\n"),numPointLights:n.numPointLights},"#version 300 es\r\nprecision mediump float;\r\n\r\n${defines}\r\n\r\n#define RECIPROCAL_PI 0.3183098861837907\r\n\r\nuniform vec3 color;\r\n\r\nin vec3 vertex;\r\nin vec3 vNormal;\r\n\r\nout vec4 fragColor;\r\n\r\n\r\n${declarations}\r\n\r\nvoid main() {\r\n    vec3 totalIrradiance = vec3(0.0f);\r\n    ${irradiance}\r\n\r\n    //debug normals\r\n    //fragColor = vec4(normalize(vNormal) * 0.5 + 0.5, 1.0);\r\n    fragColor = vec4(RECIPROCAL_PI * color * totalIrradiance, 1.0f);\r\n    ${toneMapping}\r\n}");var i;console.log(e);const a=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(a,e),t.compileShader(a),t.attachShader(r,o),t.attachShader(r,a)}},endProgramSetup:nn})))));const fn=function(){const{subscribe:n,set:t}=O({init:!1});return{subscribe:n,set:t}}();const un=function(){const{subscribe:n,update:t}=O({});return{subscribe:n,update:t}}(),pn=O(null),gn=N(sn,(n=>{const t=P();T(t,n||cn),B(t,t);const r=c(un);if(!r.gl)return t;const o=r.gl,e=r.program,i=o.getUniformLocation(e,"normalMatrix");return o.uniformMatrix4fv(i,!1,t),t})),dn=N([an,ln,sn],(([n,t,r])=>{if(!(n&&t&&n.canvas&&0!==t.length&&n.camera&&0!==n.lights.length))return console.log("no renderer or programs or canvas"),[];const o=n.lights.filter((n=>"point"===c(n).type)).length,e=c(n.lights.find((n=>"point"===c(n).type))).shader;let i={canvas:n.canvas,backgroundColor:n.backgroundColor,...n.toneMappings.length>0?{toneMappings:n.toneMappings}:void 0,...o>0?{numPointLights:o,pointLightShader:e}:void 0};const a=[];var s;return!c(fn).init&&a.push(function(n,t){return function(){const r=n.canvas.getBoundingClientRect();n.canvas.width=r.width,n.canvas.height=r.height;const o=n.gl=n.canvas.getContext("webgl2");t.update((t=>({...t,...n}))),o.viewportWidth=n.canvas.width,o.viewportHeight=n.canvas.height,o.clearColor.apply(o,n.backgroundColor),o.clear(o.COLOR_BUFFER_BIT|o.DEPTH_COLOR_BIT),o.enable(o.DEPTH_TEST),o.enable(o.CULL_FACE),o.frontFace(o.CCW),o.cullFace(o.BACK),fn.set({init:!0})}}(i,un)),!c(fn).init&&a.push(...t.reduce(((t,r)=>{return pn.set(r),[...t,r.createProgram(un),r.createShaders(un),r.endProgramSetup(un),...r.mesh.uniforms?.color?[tn(un,r.uniforms)]:[],(o=un,e=r.mesh,function(){const n=(o=c(o)).gl,t=o.program;o.attributeLength=e.attributes.elements?e.attributes.elements.length:e.attributes.positions.length/3;const r=new Float32Array(e.attributes.positions),i=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,i),n.bufferData(n.ARRAY_BUFFER,r,n.STATIC_DRAW);const a=n.getAttribLocation(t,"position");n.bindBuffer(n.ARRAY_BUFFER,i),n.vertexAttribPointer(a,3,n.FLOAT,!1,0,0),n.enableVertexAttribArray(a);const s=new Float32Array(e.attributes.normals),l=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,l),n.bufferData(n.ARRAY_BUFFER,s,n.STATIC_DRAW);const f=n.getAttribLocation(t,"normal");if(n.bindBuffer(n.ARRAY_BUFFER,l),n.vertexAttribPointer(f,3,n.FLOAT,!1,0,0),n.enableVertexAttribArray(f),e.attributes.elements){o.hasElements=!0;const t=new Uint16Array(e.attributes.elements),r=n.createBuffer();n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,r),n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)}}),rn(un,n.camera),on(un,c(sn)),Q(un),...[...n.lights.reduce(((n,t)=>{const r=c(t);return n.set(r.type,r.setupLights),n}),new Map)].map((([t,r])=>r(un,n.lights)))];var o,e}),[])),a.push((s=un,function(){const n=(s=c(s)).gl;n.clear(n.COLOR_BUFFER_BIT|n.DEPTH_BUFFER_BIT),s.loop&&s.loop(),s.hasElements?n.drawElements(n.TRIANGLES,s.attributeLength,n.UNSIGNED_SHORT,0):n.drawArrays(n.TRIANGLES,0,s.attributeLength)})),a}));function hn(n){const t=n.slice();return function(n){for(let t=0,r=n.length;t<r;t+=3){const r=n[t+0],o=n[t+1],e=n[t+2],i=1/Math.sqrt(r*r+o*o+e*e);n[t+0]*=i,n[t+1]*=i,n[t+2]*=i}}(t),t}const mn=(1+Math.sqrt(5))/2,vn=1/mn,xn=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-vn,-mn,0,-vn,mn,0,vn,-mn,0,vn,mn,-vn,-mn,0,-vn,mn,0,vn,-mn,0,vn,mn,0,-mn,0,-vn,mn,0,-vn,-mn,0,vn,mn,0,vn],bn=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];function Mn(t){let r;return{c(){var n;n="canvas",r=document.createElement(n)},m(n,o){!function(n,t,r){n.insertBefore(t,r||null)}(n,r,o),t[2](r)},p:n,i:n,o:n,d(n){n&&l(r),t[2](null)}}}function An(n,t,r){let o,e,i,a;function c(){const n=performance.now()/1e3/6*Math.PI,t=new Float32Array(16);I(t),function(n,t,r){var o=Math.sin(r),e=Math.cos(r),i=t[0],a=t[1],c=t[2],s=t[3],l=t[8],f=t[9],u=t[10],p=t[11];t!==n&&(n[4]=t[4],n[5]=t[5],n[6]=t[6],n[7]=t[7],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n[0]=i*e-l*o,n[1]=a*e-f*o,n[2]=c*e-u*o,n[3]=s*e-p*o,n[8]=i*o+l*e,n[9]=a*o+f*e,n[10]=c*o+u*e,n[11]=s*o+p*e}(t,t,n),function(n,t,r){var o=Math.sin(r),e=Math.cos(r),i=t[4],a=t[5],c=t[6],s=t[7],l=t[8],f=t[9],u=t[10],p=t[11];t!==n&&(n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=t[3],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n[4]=i*e+l*o,n[5]=a*e+f*o,n[6]=c*e+u*o,n[7]=s*e+p*o,n[8]=l*e-i*o,n[9]=f*e-a*o,n[10]=u*e-c*o,n[11]=p*e-s*o}(t,t,n),function(n,t,r){var o=Math.sin(r),e=Math.cos(r),i=t[0],a=t[1],c=t[2],s=t[3],l=t[4],f=t[5],u=t[6],p=t[7];t!==n&&(n[8]=t[8],n[9]=t[9],n[10]=t[10],n[11]=t[11],n[12]=t[12],n[13]=t[13],n[14]=t[14],n[15]=t[15]),n[0]=i*e+l*o,n[1]=a*e+f*o,n[2]=c*e+u*o,n[3]=s*e+p*o,n[4]=l*e-i*o,n[5]=f*e-a*o,n[6]=u*e-c*o,n[7]=p*e-s*o}(t,t,n);const r=2*Math.sin(performance.now()/1e3),e=2*Math.cos(performance.now()/1e3),i=.5*Math.sin(performance.now()/250)+.5,s=.5*Math.cos(performance.now()/500)+.5,l=.5*Math.sin(performance.now()/1e3)+.5;var f;a.store.set({position:[r,e,-3],color:[i,s,l]}),o=t,f=o,sn.set(f),requestAnimationFrame(c)}return s(n,sn,(n=>r(4,o=n))),s(n,gn,(n=>r(5,n))),s(n,dn,(n=>r(1,e=n))),p((()=>{const n=((n,t,r)=>{const o=[];!function(n){const t=X(),r=X(),o=X();for(let e=0;e<bn.length;e+=3)i(bn[e+0],t),i(bn[e+1],r),i(bn[e+2],o),a(t,r,o,n)}(t),function(n){const t=X();for(let r=0;r<o.length;r+=3)t[0]=o[r+0],t[1]=o[r+1],t[2]=o[r+2],k(t,t),Y(t,n),o[r+0]=t[0],o[r+1]=t[1],o[r+2]=t[2]}(n);let e=r(o);return{positions:o,normals:e};function i(n,t){const r=3*n;t[0]=xn[r+0],t[1]=xn[r+1],t[2]=xn[r+2]}function a(n,t,r,o){const e=o+1,i=[];for(let o=0;o<=e;o++){i[o]=[];let a=X();G(a,[...n],r,o/e);let c=X();G(c,[...t],r,o/e);const s=e-o;for(let n=0;n<=s;n++)if(0===n&&o===e)i[o][n]=a;else{let t=X();G(t,[...a],c,n/s),i[o][n]=t}}for(let n=0;n<e;n++)for(let t=0;t<2*(e-n)-1;t++){const r=Math.floor(t/2);t%2==0?(c(i[n][r+1]),c(i[n+1][r]),c(i[n][r])):(c(i[n][r+1]),c(i[n+1][r+1]),c(i[n+1][r]))}}function c(n){o.push(...n)}})(1,7,hn);an.setCanvas(i),an.setBackgroundColor([0,0,0,1]),an.setCamera([0,0,-3]),an.addMesh({attributes:n,uniforms:{color:[1,1,1]}}),a=an.addLight(H({position:[-2,2,-3],color:[1,1,1],intensity:3,cutoffDistance:5,decayExponent:1})),an.addLight(H({position:[1,-2,0],color:[1,1,0],intensity:2,cutoffDistance:5,decayExponent:1})),an.addToneMapping({exposure:`${{exposure:1}.exposure.toLocaleString("en",{minimumFractionDigits:1})}f`,shader:n=>U(n,"${declaration?\r\n`\r\n// tone mapping taken from three.js\r\nfloat toneMappingExposure = ${exposure};\r\n\r\n    // Matrices for rec 2020 <> rec 709 color space conversion\r\n    // matrix provided in row-major order so it has been transposed\r\n    // https://www.itu.int/pub/R-REP-BT.2407-2017\r\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(vec3(1.6605f, -0.1246f, -0.0182f), vec3(-0.5876f, 1.1329f, -0.1006f), vec3(-0.0728f, -0.0083f, 1.1187f));\r\n\r\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(vec3(0.6274f, 0.0691f, 0.0164f), vec3(0.3293f, 0.9195f, 0.0880f), vec3(0.0433f, 0.0113f, 0.8956f));\r\n\r\n    // https://iolite-engine.com/blog_posts/minimal_agx_implementation\r\n    // Mean error^2: 3.6705141e-06\r\nvec3 agxDefaultContrastApprox(vec3 x) {\r\n\r\n    vec3 x2 = x * x;\r\n    vec3 x4 = x2 * x2;\r\n\r\n    return +15.5f * x4 * x2 - 40.14f * x4 * x + 31.96f * x4 - 6.868f * x2 * x + 0.4298f * x2 + 0.1191f * x - 0.00232f;\r\n\r\n}\r\n\r\nvec3 AgXToneMapping(vec3 color) {\r\n\r\n        // AgX constants\r\n    const mat3 AgXInsetMatrix = mat3(vec3(0.856627153315983f, 0.137318972929847f, 0.11189821299995f), vec3(0.0951212405381588f, 0.761241990602591f, 0.0767994186031903f), vec3(0.0482516061458583f, 0.101439036467562f, 0.811302368396859f));\r\n\r\n        // explicit AgXOutsetMatrix generated from Filaments AgXOutsetMatrixInv\r\n    const mat3 AgXOutsetMatrix = mat3(vec3(1.1271005818144368f, -0.1413297634984383f, -0.14132976349843826f), vec3(-0.11060664309660323f, 1.157823702216272f, -0.11060664309660294f), vec3(-0.016493938717834573f, -0.016493938717834257f, 1.2519364065950405f));\r\n\r\n        // LOG2_MIN      = -10.0\r\n        // LOG2_MAX      =  +6.5\r\n        // MIDDLE_GRAY   =  0.18\r\n    const float AgxMinEv = -12.47393f;  // log2( pow( 2, LOG2_MIN ) * MIDDLE_GRAY )\r\n    const float AgxMaxEv = 4.026069f;    // log2( pow( 2, LOG2_MAX ) * MIDDLE_GRAY )\r\n\r\n    color *= toneMappingExposure;\r\n\r\n    color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\r\n\r\n    color = AgXInsetMatrix * color;\r\n\r\n        // Log2 encoding\r\n    color = max(color, 1e-10f); // avoid 0 or negative numbers for log2\r\n    color = log2(color);\r\n    color = (color - AgxMinEv) / (AgxMaxEv - AgxMinEv);\r\n\r\n    color = clamp(color, 0.0f, 1.0f);\r\n\r\n        // Apply sigmoid\r\n    color = agxDefaultContrastApprox(color);\r\n\r\n        // Apply AgX look\r\n        // v = agxLook(v, look);\r\n\r\n    color = AgXOutsetMatrix * color;\r\n\r\n        // Linearize\r\n    color = pow(max(vec3(0.0f), color), vec3(2.2f));\r\n\r\n    color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\r\n\r\n        // Gamut mapping. Simple clamp for now.\r\n    color = clamp(color, 0.0f, 1.0f);\r\n\r\n    return color;\r\n\r\n}\r\n` : ''\r\n}\r\n${color?\r\n`\r\n    fragColor = vec4(AgXToneMapping(fragColor.xyz),1.0f);\r\n` : ''\r\n}")}),c()})),n.$$.update=()=>{2&n.$$.dirty&&e&&e.forEach((n=>{n()}))},[i,e,function(n){d[n?"unshift":"push"]((()=>{i=n,r(0,i)}))}]}class _n extends F{constructor(n){super(),w(this,n,An,Mn,i,{})}}export{_n as default};
